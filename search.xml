<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>k8s的Service的底层网络转发机制</title>
      <link href="../2021/02/26/k8s%E7%9A%84Service%E7%9A%84%E5%BA%95%E5%B1%82%E7%BD%91%E7%BB%9C%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
      <url>../2021/02/26/k8s%E7%9A%84Service%E7%9A%84%E5%BA%95%E5%B1%82%E7%BD%91%E7%BB%9C%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>k8s的Service转发依赖于kube-proxy组件，虽然是使用了底层的Netfilter作为数据转发面，但是也是kube-proxy负责监控k8s集群的配置，然后动态地配置这些规则（iptables的规则）。</p><p>本文以k8s支持的Service的两种类型：<code>ClusterIP</code> 和 <code>NodePort</code>的底层转发的设置。</p><h1 id="2-部署一个模拟业务"><a href="#2-部署一个模拟业务" class="headerlink" title="2. 部署一个模拟业务"></a>2. 部署一个模拟业务</h1><p>   部署一个后端和ClusterIP（Service的默认类型）、NodePort，分别检查其底层设置的iptables规则是什么。</p>   <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">debian-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">debian</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">debian</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">debian</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">debian</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">debian</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;tail&quot;</span>]</span><br><span class="line">        <span class="attr">args:</span> [<span class="string">&quot;-f&quot;</span>, <span class="string">&quot;/dev/null&quot;</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-debian</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">my-debian</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">debian</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-debian-nodeport</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">my-debian-nodeport</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">nodePort:</span> <span class="number">32767</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">debian</span></span><br></pre></td></tr></table></figure><p>   部署好两个Serice后，检查其CLUSTER-IP(vip)是什么。</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n lijiancai get service</span><br><span class="line">NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">my-debian            ClusterIP   11.1.246.253   &lt;none&gt;        8081/TCP       1d</span><br><span class="line">my-debian-nodeport   NodePort    11.1.255.25    &lt;none&gt;        80:32767/TCP   1d</span><br></pre></td></tr></table></figure><p>   可以看出，ClusterIP和NodePort两种Service都部署好了。</p><h2 id="2-1-检查NodePort的转发规则"><a href="#2-1-检查NodePort的转发规则" class="headerlink" title="2.1 检查NodePort的转发规则"></a>2.1 检查NodePort的转发规则</h2><p>首先看一下NodePort的转发规则，登陆其中一个k8s的Node上查看即可。<br>查看相关的规则：<br><code>iptables-save |egrep &quot;11.1.255.25|KUBE-SVC-LNV7GAXDUQDNSVVY|KUBE-SEP-J3E47UJWOXYCTXZO|KUBE-SEP-YG5NCD43FEYFCPSO|KUBE-SEP-P5NKJKBG5L2BFHIC&quot; --color</code></p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210227000521.png"></p><p>对于NodePort这个服务，我们设置的外部端口是32767和80端口，其中32767是通过kube-proxy这个进程转发的。80端口则是通过iptables的规则进行转发的。这里可以得出一个结论：其实可以在Node节点上访问ClusterIP：80，也是可以访问到真实的业务的。如果是Node外部的客户端访问，就需要访问Node：32767了，这个时候，kube-proxy就会参与转发。    </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"> <span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"> <span class="attr">metadata:</span></span><br><span class="line">   <span class="attr">name:</span> <span class="string">my-debian-nodeport</span></span><br><span class="line">   <span class="attr">labels:</span></span><br><span class="line">     <span class="attr">run:</span> <span class="string">my-debian-nodeport</span></span><br><span class="line"> <span class="attr">spec:</span></span><br><span class="line">   <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">   <span class="attr">ports:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">nodePort:</span> <span class="number">32767</span></span><br><span class="line">     <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">     <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">   <span class="attr">selector:</span></span><br><span class="line">     <span class="attr">app:</span> <span class="string">debian</span></span><br></pre></td></tr></table></figure><h2 id="2-2检查CLUSTER-IP的路由转发规则"><a href="#2-2检查CLUSTER-IP的路由转发规则" class="headerlink" title="2.2检查CLUSTER-IP的路由转发规则"></a>2.2检查CLUSTER-IP的路由转发规则</h2><p>查看CLUSTER-IP的转发规则，登陆其中一个Node上查看：<code> iptables-save |egrep &quot;11.1.246.253|KUBE-SVC-AE7Z2ITCKH72L4S6|KUBE-SEP-ITNKZ7TJM6CNT6XR|KUBE-SEP-4A3YQTBEZOS5YQXI|KUBE-SEP-GMGRS7VNE5IDYII6&quot; --color</code></p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210227001533.png"></p><p>可以看出，CLUSTER-IP与NodePort的规则相似，只不过CLUSTER-IP不需要kube-proxy的参与转发。</p><h2 id="2-3-关于SessionAffinity-粘性会话"><a href="#2-3-关于SessionAffinity-粘性会话" class="headerlink" title="2.3 关于SessionAffinity 粘性会话"></a>2.3 关于SessionAffinity 粘性会话</h2><p>iptables底层也是提供粘性会话的功能的。(支持k8s的Service的sessionAffinity: ClientIP)。</p><p>在Service的配置中，添加一个配置项sessionAffinity: ClientIP，就可以让某个客户端的ip一定会转发到同一个Pod上，对于缓存要求较高的业务可能需要这个功能。（顺便说一下，粘性会话这个功能与云原生的理念有点不一样，云原生强调的是环境是随时可以迁移的）</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210227001949.png"></p><p>设置粘性会话前后iptables的规则对比：</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210227002627.png"></p><p>设置粘性会话后，新增的规则有:</p><blockquote><p>-A KUBE-SEP-4A3YQTBEZOS5YQXI -p tcp -m recent –set –name KUBE-SEP-4A3YQTBEZOS5YQXI –mask 255.255.255.255 –rsource -m tcp -j DNAT –to-destination 172.16.44.10:80</p><p>-A KUBE-SEP-GMGRS7VNE5IDYII6 -s 172.16.47.15/32 -j KUBE-MARK-MASQ</p><p>-A KUBE-SEP-GMGRS7VNE5IDYII6 -p tcp -m recent –set –name KUBE-SEP-GMGRS7VNE5IDYII6 –mask 255.255.255.255 –rsource -m tcp -j DNAT –to-destination 172.16.47.15:80</p><p>-A KUBE-SEP-ITNKZ7TJM6CNT6XR -s 172.16.34.3/32 -j KUBE-MARK-MASQ</p><p>-A KUBE-SEP-ITNKZ7TJM6CNT6XR -p tcp -m recent –set –name KUBE-SEP-ITNKZ7TJM6CNT6XR –mask 255.255.255.255 –rsource -m tcp -j DNAT –to-destination 172.16.34.3:80</p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> K8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能火焰图打印</title>
      <link href="../2021/02/24/%E6%80%A7%E8%83%BD%E7%81%AB%E7%84%B0%E5%9B%BE%E6%89%93%E5%8D%B0/"/>
      <url>../2021/02/24/%E6%80%A7%E8%83%BD%E7%81%AB%E7%84%B0%E5%9B%BE%E6%89%93%E5%8D%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-输出函数调用火焰图"><a href="#1-输出函数调用火焰图" class="headerlink" title="1. 输出函数调用火焰图"></a>1. 输出函数调用火焰图</h1><p>要输出火焰图之前，需要获取到一些统计数据，在Linux平台需要用perf工具进行采样和统计数据的收集。收集完数据后，就是可以使用火焰图制作工具FlameGraph输出火焰图了。</p><p>以Envoy的采样作为例子，步骤如下：</p><ol><li><p>启动Envoy，并且通过ps获取到其Pid: <code>./envoy_debug -c envoy_config.yaml</code></p></li><li><p>对Envoy进行压测: <code>ab -c 10 -t 100 http://127.0.0.1:8000/</code></p></li><li><p>使用perf对Envoy进行采样：<code>perf record -F 99  -g -p 31636 -- sleep 10</code>, 其中<code>-g</code>表示使用采样调用栈，<code>-p</code>表示进程的Pid，<code>-- sleep 10</code>表示采样时间共10s。</p></li><li><p>perf record 执行结束后，会在当前的目录输出perf.data文件。（可以保存这份原始文件用于后续分析，如果不需要输出火焰图，也可以执行:<code>perf report -n --stdio</code>在当前终端输出统计信息）</p></li><li><p>预处理数据：<code>perf script &gt; out.perf</code></p></li><li><p>使用FlameGraph生成火焰图：<code>./stackcollapse-perf.pl out.perf | ./flamegraph.pl &gt; newout.svg</code>, 这个步骤用到的工具在 <a href="https://github.com/brendangregg/FlameGraph">https://github.com/brendangregg/FlameGraph</a> 。</p></li><li><p>在浏览器打开svg图片，效果如下</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210224232314.png"></p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>火焰图打印工具Repo： <a href="https://github.com/brendangregg/FlameGraph">https://github.com/brendangregg/FlameGraph</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Benchmark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>压测方法论</title>
      <link href="../2021/02/24/%E5%8E%8B%E6%B5%8B%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
      <url>../2021/02/24/%E5%8E%8B%E6%B5%8B%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="1-环境准备方面"><a href="#1-环境准备方面" class="headerlink" title="1. 环境准备方面"></a>1. 环境准备方面</h1><ol><li>性能测试的时候，应该要关闭cpu的turbo功能，否则对我们的基础性能影响很大。至少有20%的误差。<code>echo 1 | sudo tee /sys/devices/system/cpu/intel_pstate/no_turbo</code></li><li>排除当前被压测的服务机器上，有其他消耗资源较多的服务在运行。</li></ol><h1 id="2-HTTP-相关压测"><a href="#2-HTTP-相关压测" class="headerlink" title="2. HTTP 相关压测"></a>2. HTTP 相关压测</h1><ul><li><p>首先要注意的是HTTP1.0默认是请求完成后关闭TCP连接的。HTTP1.1则是默认请求完成后不关闭TCP连接。在测试RPS的时候，HTTP请求需要复用TCP连接，在测试CPS的时候，HTTP请求不能复用TCP连接。为了保证压测符合设想，可以在请求的时候主动构造Connection这个Header。</p><ul><li>不复用TCP: <code>Connection: Clost</code></li><li>复用TCP： <code>Connection: Keep-Alive </code></li></ul></li><li><p>测试RPS的时候，可以指定CPU的核，然后并发的启动压测工具，这样可以保证压测机器可以发挥最大的性能。注意： 需要后台运行压测工具。每个命令的并发数控制为``1`,因为已经单独分配好CPU，就不需要竞争了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 number-of-CPUs`; <span class="keyword">do</span></span><br><span class="line">    taskset -c <span class="variable">$i</span> wrk -t 1 -c 50 -d 180s http://Reverse-Proxy-Server-IP-address/1kb.bin &amp;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>如果只想测试TLS/SSL 的TPS，这时候可以获取返回0 byte数据的接口，这样就可以看到TLS相关的性能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 number-of-CPUs`; <span class="keyword">do</span></span><br><span class="line">    taskset -c <span class="variable">$i</span> wrk -t 1 -c 50 -d 180s -H <span class="string">&#x27;Connection: close&#x27;</span> https://Reverse-Proxy-Server-IP-address/0kb.bin &amp;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>测试吞吐的时候，获取返回1M数据量的接口即可（也可以是4k、8k等，要和实际的业务需求结合起来）。</p></li><li><p>同时测试多张网卡的话，就要访问不同IP了，由路由决定走哪张网卡。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 number-of-CPUs/2`; <span class="keyword">do</span></span><br><span class="line">    n=`<span class="built_in">echo</span> $((<span class="variable">$i</span>+number-of-CPUs/<span class="number">2</span>))`;</span><br><span class="line">    taskset -c <span class="variable">$i</span> ./wrk -t 1 -c 50 -d 180s http://Reverse-Proxy-Server-IP-address-1/1kb.bin &amp;</span><br><span class="line">    taskset -c <span class="variable">$n</span> ./wrk -t 1 -c 50 -d 180s http://Reverse-Proxy-Server-IP-address-2/1kb.bin &amp;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol><li><a href="https://www.nginx.com/blog/nginx-plus-sizing-guide-how-we-tested/">https://www.nginx.com/blog/nginx-plus-sizing-guide-how-we-tested/</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Benchmark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Istio如何注入sidecar并拉起</title>
      <link href="../2021/02/24/Istio%E5%A6%82%E4%BD%95%E6%B3%A8%E5%85%A5sidecar%E5%B9%B6%E6%8B%89%E8%B5%B7/"/>
      <url>../2021/02/24/Istio%E5%A6%82%E4%BD%95%E6%B3%A8%E5%85%A5sidecar%E5%B9%B6%E6%8B%89%E8%B5%B7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-利用K8S和Istio组件提供的机制，对Pod进行sidecar的注入"><a href="#1-利用K8S和Istio组件提供的机制，对Pod进行sidecar的注入" class="headerlink" title="1. 利用K8S和Istio组件提供的机制，对Pod进行sidecar的注入"></a>1. 利用K8S和Istio组件提供的机制，对Pod进行sidecar的注入</h1><pre><code>K8S的动态webhook机制可以使得在所有的资源请求经过APIServer的时候进行校验，有两种dynamic webhook，一是MutatingWebhook，二是ValidatingWebhook。注入sidecar的是用到MutatingWebhook，要使用MutatingWebhook需要配置一个MutatingWebhookConfiguration。查看命令： `kubectl get MutatingWebhookConfiguration istio-sidecar-injector  -o yaml -n default`,配置内容如下：</code></pre><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">admissionregistration.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">MutatingWebhookConfiguration</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">sidecarInjectorWebhook</span></span><br><span class="line">    <span class="attr">chart:</span> <span class="string">sidecarInjectorWebhook</span></span><br><span class="line">    <span class="attr">heritage:</span> <span class="string">Tiller</span></span><br><span class="line">    <span class="attr">release:</span> <span class="string">istio</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio-sidecar-injector</span></span><br><span class="line"><span class="attr">webhooks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">admissionReviewVersions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">v1beta1</span></span><br><span class="line">  <span class="attr">clientConfig:</span></span><br><span class="line">    <span class="attr">caBundle:</span> <span class="string">LS0tLS1CRUdJTiBDRVJUSUZ***************</span></span><br><span class="line">    <span class="attr">service:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">istio-sidecar-injector</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/inject</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">  <span class="attr">failurePolicy:</span> <span class="string">Fail</span></span><br><span class="line">  <span class="attr">matchPolicy:</span> <span class="string">Exact</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sidecar-injector.istio.io</span></span><br><span class="line">  <span class="attr">namespaceSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">istio-injection:</span> <span class="string">enabled</span></span><br><span class="line">  <span class="attr">objectSelector:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">reinvocationPolicy:</span> <span class="string">Never</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">apiVersions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">operations:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CREATE</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">    <span class="attr">scope:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  <span class="attr">sideEffects:</span> <span class="string">Unknown</span></span><br><span class="line">  <span class="attr">timeoutSeconds:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><pre><code>可以看到，只有 label有istio-injection: enabled的命令空间的Pod才会注入Sidecar，sidecar的配置是去命名空间istio-system下的istio-sidecar-injector 443端口下的/inject端口获取。采用的是HTTP协议。</code></pre><blockquote><p>kubectl -n istio-system get deployment istio-sidecar-injector<br>NAME                     READY   UP-TO-DATE   AVAILABLE   AGE<br>istio-sidecar-injector   2/2     2            2           32d</p></blockquote><pre><code>istio-sidecar-injector如何注入sidecar的配置，是根据一个模板生成出来的，该模板是在一个configmap中，查看方式如下：`kubectl -n istio-system get cm istio-sidecar-injector`。</code></pre><h1 id="2-sidecar-内部如何启动"><a href="#2-sidecar-内部如何启动" class="headerlink" title="2. sidecar 内部如何启动"></a>2. sidecar 内部如何启动</h1><p>sidecar的进程参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istio-p+       1  0.0  0.0 137124 35088 ?        Ssl   2020  43:32 /usr/<span class="built_in">local</span>/bin/pilot-agent proxy sidecar --domain hello-world.svc.cluster.local --configPath /etc/istio/proxy --binaryPath /usr/<span class="built_in">local</span>/bin/envoy --serviceCluster productpage.hello-world --drainDuration 45s --parentShutdownDuration 1m0s --discoveryAddress istio-pilot.istio-system:15010 --zipkinAddress zipkin.istio-system:9411 --dnsRefreshRate 300s --connectTimeout 10s --proxyAdminPort 15000 --concurrency 2 --controlPlaneAuthPolicy NONE --statusPort 15020 --applicationPorts 9080</span><br><span class="line">istio-p+      65  0.1  0.0 195476 56536 ?        Sl    2020  62:39 /usr/<span class="built_in">local</span>/bin/envoy -c /etc/istio/proxy/envoy-rev1.json --restart-epoch 1 --drain-time-s 45 --parent-shutdown-time-s 60 --service-cluster productpage.hello-world --service-node sidecar~10.216.24.213~productpage-v1-556c4c548f-ld85c.hello-world~hello-world.svc.cluster.local --max-obj-name-len 189 --local-address-ip-version v4 --log-format [Envoy (Epoch 1)] [%Y-%m-%d %T.%e][%t][%l][%n] %v -l warning --component-log-level misc:error --concurrency 2</span><br></pre></td></tr></table></figure><pre><code>可以看到，有一个代理的进程pilot-agent负责转换Istio注入的参数为Envoy的参数，并且生成Envoy的配置文件/etc/istio/proxy/envoy-rev1.json。这样，Istio就通过Pod修改配置的机制，注入了Sidecar的启动参数（通过环境变量注入），然后又通过一个代理进程负责生成Envoy的参数和配置文件，接着再拉起Envoy的进程。其中，有一个关键的参数是`--discoveryAddress istio-pilot.istio-system:15010`,此参数是Envoy的ADS的地址，Envoy就是通过ADS的地址建立GRPC连接，实现Istio的参数动态修改后，Envoy就可以发现，并且在线修改响应的配置。</code></pre><p>​    </p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Istio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Delve调试容器内Go代码</title>
      <link href="../2021/02/24/%E4%BD%BF%E7%94%A8Delve%E8%B0%83%E8%AF%95%E5%AE%B9%E5%99%A8%E5%86%85Go%E4%BB%A3%E7%A0%81/"/>
      <url>../2021/02/24/%E4%BD%BF%E7%94%A8Delve%E8%B0%83%E8%AF%95%E5%AE%B9%E5%99%A8%E5%86%85Go%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><ul><li><p>Delve是一个Go语言的调试器，跟GDB比较，Delve是专用的调试器，能够识别到go routine等语义, 是Go语言调试的不二之选。</p></li><li><p>istio调试代码，如pilot-agent或istiod等，调试的环境构建（构建）比较复杂，需要传入环境变量、参数、挂载的文件、以及运行的网络联性等。如果要在本地调试这些持续，模拟环境非常复杂。因此，需要换个思路，直接调试在k8s集群容器内部运行的代码，所以需要一个远程调试的工具来辅助。以pilot-agent为例子，演示创建调试环境的流程。</p></li></ul><h1 id="2-需要解决的问题"><a href="#2-需要解决的问题" class="headerlink" title="2. 需要解决的问题"></a>2. 需要解决的问题</h1><ol><li>替换容器的Entrypoint，这样我们才可以在容器内重启需要被调试的进程（以pilot-agent为例，不能让pilot-agent作为容器的Entrypoint（pid不能为1），这样我们就算重启pilot-agent，也不会导致容器重启）</li><li>新建一个镜像，安装好日常使用的工具：GDB、dlv（Delve）、go等常用的工具，方便调试。</li><li>sidecar注入的时候，以root的权限运行容器（这样才不会不可预见遇到权限不足的问题，因为是调试环境，权限最大也没问题）。修改容器文件系统的可读写性，文件系统改为可读可写。</li></ol><h1 id="3-准备环境"><a href="#3-准备环境" class="headerlink" title="3. 准备环境"></a>3. 准备环境</h1><ol><li><p>使用一个新的入口，来运行原来容器的Entrypoint。这里使用一个python脚本dumb.py 作为入口即可。 这个脚本会在sidecar启动的时候就会执行，脚本的参数就是原来 pilot-agent的启动命令+参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt;= <span class="number">2</span>:</span><br><span class="line">        print(<span class="string">&#x27;Not enough args&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        subprocess.run(sys.argv[<span class="number">1</span>:], check=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        time.sleep(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li><li><p>重新编译好带有调试符号的pilot-agent二进制</p><ul><li>cd istio/pilot/cmd/pilot-agent</li></ul></li></ol><ul><li>env GOOS=linux     GOARCH=amd64 go build     -gcflags=”all=-N -l”      . (因为在Mac上编译，需要添加目标平台和OS的环境变量，并且传入-gcflags=”all=-N     -l”)</li></ul><ol start="3"><li><p>准备好Devle的Linux版本的二进制</p><ul><li>找一台linux的机器：go get github.com/go-delve/delve/cmd/dlv</li></ul></li></ol><ul><li>去目录~/go/bin下找到二进制dlv</li></ul><ol start="4"><li><p>下载Go并且解压（因为Delve需要Go的运行时的，所以在容器的镜像内也要有Go）</p></li><li><p>基于原有的Istio使用的镜像，构建一个新的镜像.</p><ul><li>Dockerfile内容如下：</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> docker.io/istio/proxyv2:<span class="number">1.8</span>.<span class="number">2</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;/usr/local/go/bin:$&#123;PATH&#125;&quot;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> dumb.py /dumb.py</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> dlv /usr/<span class="built_in">local</span>/bin/dlv</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> go /usr/<span class="built_in">local</span>/go</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x /dumb.py /usr/<span class="built_in">local</span>/bin/dlv /usr/<span class="built_in">local</span>/go/bin/go \</span></span><br><span class="line"><span class="bash">&amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">&amp;&amp; apt-get install gdb vim ssh socat -y</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> pilot-agent /usr/<span class="built_in">local</span>/bin/pilot-agent</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x /usr/<span class="built_in">local</span>/bin/pilot-agent</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;/dumb.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>​    放Dockerfile文件的目录包含的资源有：</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E5%9B%BE%E7%89%87.png" alt="未命名图片"></p><ul><li>编译新的镜像：docker build ./ -t leejiancai/proxyv2:1.8.2_dlv</li></ul></li></ol><ul><li>推送新编译出来的镜像到dockerhub：docker push leejiancai/proxyv2:1.8.2_dlv</li></ul><ol start="6"><li><p>修改Istio的Sidecar-injector的配置</p><ul><li><p>修改配置文件configmap：<code>kubectl -n istio-system edit cm istio-sidecar-injector</code></p></li><li><p>修改sidecar的镜像为自定义的镜像 leejiancai/proxyv2:1.8.2_dlv</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210224030551.png"></p></li><li><p>修改isito-proxy容器的参数</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E5%9B%BE%E7%89%87111.png"></p></li><li><p>修改istio-proxy容器的文件系统可读写性和运行用户为root</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E5%9B%BE%E7%89%8721.png" alt="未命名图片21"></p></li><li><p>istio-proxy容器新增一个开放端口2345(后面进行远程调试需要用到这个端口)</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E5%9B%BE%E7%89%87123213.png" alt="未命名图片123213"></p></li></ul></li></ol><h1 id="4-使用dlv进行远程调试"><a href="#4-使用dlv进行远程调试" class="headerlink" title="4. 使用dlv进行远程调试"></a>4. 使用dlv进行远程调试</h1><ol><li><p>部署httpbin服务：<code>cd istio-1.8.2/samples/httpbin &amp;&amp; kubectl apply -f httpbin.yaml</code></p></li><li><p>进去httpbin的istio-proxy容器：<code>kubectl exec -it httpbin-74fb669cc6-nqr47 -c istio-proxy -- bash</code></p></li><li><p>kill掉pilot-agent和envoy的进程</p></li><li><p>使用dlv拉起一个新的pilot-agent进程：<br><code>dlv exec --headless --listen=:2345 --api-version=2 --accept-multiclient /usr/local/bin/pilot-agent -- proxy sidecar --domain default.svc.cluster.local --serviceCluster httpbin.default --proxyLogLevel=warning --proxyComponentLogLevel=misc:error --concurrency 2</code></p></li><li><p>在调试机器（Mac电脑上）上，使用kubectl port-forward转发当前的2345端口到httpbin的pod的2345端口中：<code>kubectl port-forward pod/httpbin-74fb669cc6-nqr47  2345</code></p></li><li><p>使用GoLAND去本地机器的2345端口进行远程调试</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210224030508.png"></p></li><li><p>在需要进行观察的函数中进行断点，然后再启动调试客户端</p><ul><li><p>断点</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210224030443.png"></p></li><li><p>调试效果</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210224030403.png"></p></li></ul></li></ol><h1 id="5-补充"><a href="#5-补充" class="headerlink" title="5. 补充"></a>5. 补充</h1><ol><li>在调试客户端不能重启调试：<br>在httpbin的Pod上，kill掉dlv、pilot-agent和envoy的进程，重新按照新调试的流程再执行即可。</li><li>实验环境是：Mac电脑上跑的Minikube实例，Istio的版本是1.8.2</li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Istio </tag>
            
            <tag> Go </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Wireshark解密Chrome和Curl的TLS包</title>
      <link href="../2021/02/23/%E4%BD%BF%E7%94%A8Wireshark%E8%A7%A3%E5%AF%86Chrome%E5%92%8CCurl%E7%9A%84TLS%E5%8C%85/"/>
      <url>../2021/02/23/%E4%BD%BF%E7%94%A8Wireshark%E8%A7%A3%E5%AF%86Chrome%E5%92%8CCurl%E7%9A%84TLS%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h1><p>本文主要介绍如何解密Chrome浏览器或Curl的TLS请求。原理是：设置环境变量SSLKEYLOGFILE，Chrome（Curl）就会输出TLS握手过程中协商出来用于数据传输加密的密钥。Wireshark读取 这个密钥就可以对传输的数据进行解密了。</p><h1 id="2-准备"><a href="#2-准备" class="headerlink" title="2. 准备"></a>2. 准备</h1><ol><li><p>在Home目录创建一个文件，用于TLS握手中间过程输出的关键数据：touch sshkeylog.log</p></li><li><p>export环境变量SSLKEYLOGFILE，这样浏览器的TLS握手信息才会输出：export SSLKEYLOGFILE=/Users/lijiancai/sshkeylog.log  （注意⚠️：这个路径，当前的用户需要有读写权限，放置在用户Home目录即可)</p></li><li><p>配置Wireshark，【Preferences】-&gt; 【Protocols】-&gt; 【TLS】-&gt; 【(Pre)-Master-Secret】</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20201221213132462.png" alt="image-20201221213132462"></p><h1 id="3-抓Chrome的包"><a href="#3-抓Chrome的包" class="headerlink" title="3. 抓Chrome的包"></a>3. 抓Chrome的包</h1><p>步骤如下：</p><ul><li><p>关闭浏览器，然后重新打开：open -a     ‘Google Chrome’  （启动前需要配置环境变量：export SSLKEYLOGFILE=/Users/lijiancai/sshkeylog.log  ）；或直接运行也可以：SSLKEYLOGFILE=/Users/lijiancai/keylog.log open -a ‘Google Chrome’</p></li><li><p>演示抓知乎的数据包，首先这只捕获的参数:host <a href="http://www.zhihu.com/">www.zhihu.com</a></p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20201221213714543.png" alt="image-20201221213714543"></p></li><li><p>过滤一下http2的流量出来，因为http2一定是使用TLS加密的。我们可以看到原始的数据内容了</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20201221214048935.png" alt="image-20201221214048935"></p></li></ul></li></ol><h1 id="4-抓Curl的包"><a href="#4-抓Curl的包" class="headerlink" title="4. 抓Curl的包"></a>4. 抓Curl的包</h1><ul><li>执行curl的时候，加上环境变量即可：<code> SSLKEYLOGFILE=/Users/lijiancai/keylog.log curl https://www.zhihu.com</code></li></ul><p>为什么curl也支持这个环境变量呢，是因为：所有使用Libcurl构建的应用（curl也是基于这个库开发的），都可以设置环境变量SSLKEYLOGFILE来获取TLS握手协商出来的密钥，去解析TLS的包。所以，检查一下你的应用是否支持Libcurl。</p><blockquote><p>curl –version<br>curl 7.64.1 (x86_64-apple-darwin20.0) libcurl/7.64.1 (SecureTransport) LibreSSL/2.8.3 zlib/1.2.11 nghttp2/1.41.0<br>Release-Date: 2019-03-27<br>Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtsp smb smbs smtp smtps telnet tftp<br>Features: AsynchDNS GSS-API HTTP2 HTTPS-proxy IPv6 Kerberos Largefile libz MultiSSL NTLM NTLM_WB SPNEGO SSL UnixSockets</p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络问题定位工具</title>
      <link href="../2021/02/23/%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E5%B7%A5%E5%85%B7/"/>
      <url>../2021/02/23/%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-网络（进程）吞吐量观测"><a href="#1-网络（进程）吞吐量观测" class="headerlink" title="1. 网络（进程）吞吐量观测"></a>1. 网络（进程）吞吐量观测</h1><ul><li><p>sar -n DEV : 用于观察每个网卡的吞吐量、包收发率和使用率等信息。</p></li><li><p>iftop： 用于观察local和remote连接的吞吐量。常用于定位本地节点与远程节点的数据传输量差别（排序等）</p></li><li><p>nethogs: 用于观察每个进程的吞吐量，可以用来定位某个进程的异常。并且会输出每个进程每个TCP连接的流量。</p><p>例子：</p></li></ul><ol><li><p>sar -n DEV: <code>sar -n DEV 1 10 </code>, 参数中1代表打印间隔为1s。10代表打印10次。输出中，IFACE代表网卡。</p><blockquote><p>sar -n DEV 1 10<br>Linux 4.19.0-5-amd64 (*<strong>****</strong>)     2021年02月23日     _x86_64_    (16 CPU)</p><p>22时54分34秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil<br>22时54分35秒      eth0      2.00      1.00      0.14      0.10      0.00      0.00      0.00      0.00<br>22时54分35秒   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00<br>22时54分35秒        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</p></blockquote></li><li><p>iftop: <code>iftop -n</code>, -n表示输出ip，而不是域名。输出如下</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20210223230610330.png"></p></li><li><p>nethogs: <code>nethogs eth0</code>, eth0代表指定网卡，也可以不指定网卡，所有网卡都输出</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20210223230610330.png" alt="image-20210223230610330"></p></li></ol><h1 id="2-TCP和UDP的观测"><a href="#2-TCP和UDP的观测" class="headerlink" title="2. TCP和UDP的观测"></a>2. TCP和UDP的观测</h1><ul><li>统计TCP和UDP统计输出<ul><li><code>ss -s</code></li></ul></li></ul><h1 id="3-网卡的观测"><a href="#3-网卡的观测" class="headerlink" title="3. 网卡的观测"></a>3. 网卡的观测</h1><ul><li><p>列出当前网络命名空间的网卡：<code>ip ad</code></p></li><li><p>网卡的发送（接收）统计、发送错误的统计： <code>ifconfig</code> 或<code>ifconfig -s</code> , -s 参数会让输出更加简洁（当然，也有一部分数据缺失）</p><blockquote><p>ifconfig -s<br>Iface      MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg<br>docker0   1500    43990      0      0 0        215435      0      0      0 BMU<br>eth0      1400  2013035      0     10 0        261414      0      0      0 BMRU<br>lo       65536     7928      0      0 0          7928      0      0      0 LRU</p></blockquote></li><li><p>网卡当前的吞吐量：<code>sar -n DEV 1 10</code></p></li><li></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Networking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Envoy的ListenerFilter的功能及其分析</title>
      <link href="../2021/02/23/Envoy%E7%9A%84ListenerFilter%E7%9A%84%E5%8A%9F%E8%83%BD%E5%8F%8A%E5%85%B6%E5%88%86%E6%9E%90/"/>
      <url>../2021/02/23/Envoy%E7%9A%84ListenerFilter%E7%9A%84%E5%8A%9F%E8%83%BD%E5%8F%8A%E5%85%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Listener-filters的处理流程"><a href="#1-Listener-filters的处理流程" class="headerlink" title="1. Listener filters的处理流程"></a>1. Listener filters的处理流程</h2><p>envoy支持的listener filter一共有五个</p><ol><li>envoy.listener.http_inspector</li><li>envoy.listener.original_dst</li><li>envoy.listener.original_src</li><li>envoy.listener.proxy_protocol</li><li>envoy.listener.tls_inspector</li></ol><p><strong>注意：</strong>我们下面讨论到的filter指的都是listener filter。</p><h3 id="1-1-回调的调用堆栈"><a href="#1-1-回调的调用堆栈" class="headerlink" title="1.1 回调的调用堆栈"></a>1.1 回调的调用堆栈</h3><p>首先看一下listener监听的socket回调时候的堆栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#0  Envoy::Server::ConnectionHandlerImpl::ActiveTcpSocket::continueFilterChain (this&#x3D;0x555559ae3810, success&#x3D;true)</span><br><span class="line">    at source&#x2F;server&#x2F;connection_handler_impl.cc:204</span><br><span class="line">#1  0x0000555557c20fa2 in Envoy::Server::ConnectionHandlerImpl::ActiveTcpListener::onAcceptWorker (</span><br><span class="line">    this&#x3D;0x555559b0e300, socket&#x3D;..., hand_off_restored_destination_connections&#x3D;false, rebalanced&#x3D;false)</span><br><span class="line">    at source&#x2F;server&#x2F;connection_handler_impl.cc:293</span><br><span class="line">#2  0x0000555557c21730 in Envoy::Server::ConnectionHandlerImpl::ActiveTcpListener::onAccept (this&#x3D;0x555559b0e300,</span><br><span class="line">    socket&#x3D;...) at source&#x2F;server&#x2F;connection_handler_impl.cc:273</span><br><span class="line">#3  0x0000555557c5d69f in Envoy::Network::ListenerImpl::listenCallback (fd&#x3D;46, remote_addr&#x3D;0x7fffeebd8508,</span><br><span class="line">    remote_addr_len&#x3D;16, arg&#x3D;0x555559b09bc0) at source&#x2F;common&#x2F;network&#x2F;listener_impl.cc:46</span><br><span class="line">#4  0x000055555834d4b9 in listener_read_cb (fd&#x3D;47, what&#x3D;2, p&#x3D;0x555559afce70)</span><br></pre></td></tr></table></figure><p>重点关注#0的continueFilterChain和#4的listener_read_cb。详见1.2和1.3。</p><h3 id="1-2-listener-read-cb的实现"><a href="#1-2-listener-read-cb的实现" class="headerlink" title="1.2 listener_read_cb的实现"></a>1.2 listener_read_cb的实现</h3><p>libevent的源码中listener_read_cb的实现大致是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">listener_read_cb(evutil_socket_t fd, short what, void *p)</span><br><span class="line">&#123;</span><br><span class="line">    ...省略</span><br><span class="line">while (1) &#123;</span><br><span class="line">struct sockaddr_storage ss;</span><br><span class="line">ev_socklen_t socklen &#x3D; sizeof(ss);</span><br><span class="line">evutil_socket_t new_fd &#x3D; evutil_accept4_(fd, (struct sockaddr*)&amp;ss, &amp;socklen, lev-&gt;accept4_flags);</span><br><span class="line">if (new_fd &lt; 0)</span><br><span class="line">break;</span><br><span class="line">if (socklen &#x3D;&#x3D; 0) &#123;</span><br><span class="line">&#x2F;* This can happen with some older linux kernels in</span><br><span class="line"> * response to nmap. *&#x2F;</span><br><span class="line">evutil_closesocket(new_fd);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        ...省略</span><br><span class="line">++lev-&gt;refcnt;</span><br><span class="line">cb &#x3D; lev-&gt;cb;</span><br><span class="line">user_data &#x3D; lev-&gt;user_data;</span><br><span class="line">UNLOCK(lev);</span><br><span class="line">cb(lev, new_fd, (struct sockaddr*)&amp;ss, (int)socklen,</span><br><span class="line">    user_data);</span><br><span class="line">    ...省略</span><br><span class="line">&#125;</span><br><span class="line">    ...省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>listen的socket收到读事件后，调用accept生成一个新的socket（新连接的socket）然后执行回调cb（#3的listenCallback）。</p><h3 id="1-3-continueFilterChain的实现"><a href="#1-3-continueFilterChain的实现" class="headerlink" title="1.3 continueFilterChain的实现"></a>1.3 continueFilterChain的实现</h3><p>continueFilterChain是取出当前listener配置的所有listener_fileters，按照配置的顺序执行每个filter，如果某个filter需要的数据（data）的数量（字节数）还不够，当前的循环会被中断，在这个filter内部会重新注册一个事件去监听socket的读事件。等到新的读事件来。continueFilterChain的处理具体逻辑先不具体讲，后面2.1讲http_inspector的时候再回头讲。</p><p>如果所有的filter执行（执行是调用每个filter的onAccept函数）都没问题，就行执行newConnection()创建一个新的connection（这里的连接不是tcp连接，而是envoy内的概念）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ConnectionHandlerImpl::ActiveTcpSocket::continueFilterChain(<span class="keyword">bool</span> success) &#123;</span><br><span class="line">  <span class="keyword">if</span> (success) &#123;</span><br><span class="line">    <span class="keyword">bool</span> no_error = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//重新开始执行循环？？ 下面有一行代码在退出前，执行了iter_ = accept_filters_.end();</span></span><br><span class="line">    <span class="keyword">if</span> (iter_ == accept_filters_.end()) &#123;</span><br><span class="line">      iter_ = accept_filters_.begin();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      iter_ = <span class="built_in">std</span>::next(iter_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; iter_ != accept_filters_.end(); iter_++) &#123;</span><br><span class="line">      Network::FilterStatus status = (*iter_)-&gt;onAccept(*<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (status == Network::FilterStatus::StopIteration) &#123;</span><br><span class="line">        <span class="comment">// The filter is responsible for calling us again at a later time to continue the filter</span></span><br><span class="line">        <span class="comment">// chain from the next filter.</span></span><br><span class="line">        <span class="comment">// 有的listener_filter需要执行完后中断本次循环</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!socket().ioHandle().isOpen()) &#123;</span><br><span class="line">          <span class="comment">// break the loop but should not create new connection</span></span><br><span class="line">          no_error = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// Blocking at the filter but no error</span></span><br><span class="line">          <span class="comment">// return 调用栈退出，等待下一个事件的到来（本次事件处理结束，把CPU让给event_base)</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Successfully ran all the accept filters.</span></span><br><span class="line">    <span class="keyword">if</span> (no_error) &#123;</span><br><span class="line">      newConnection();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Signal the caller that no extra filter chain iteration is needed.</span></span><br><span class="line">      iter_ = accept_filters_.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Filter execution concluded, unlink and delete this ActiveTcpSocket if it was linked.</span></span><br><span class="line">  <span class="keyword">if</span> (inserted()) &#123;</span><br><span class="line">  <span class="comment">// 删除ActiveTcpSocket对象，这个连接已经断了</span></span><br><span class="line">    unlink();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-listener-filters的执行顺序"><a href="#1-4-listener-filters的执行顺序" class="headerlink" title="1.4 listener filters的执行顺序"></a>1.4 listener filters的执行顺序</h3><p>在listener的配置中，listener filters的配置是在一个数组中的，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;listenerFilters&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;envoy.listener.tls_inspector&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;envoy.listener.http_inspector&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先执行的是tls_inspector再到http_inspector。</p><h2 id="2-filter的功能"><a href="#2-filter的功能" class="headerlink" title="2. filter的功能"></a>2. filter的功能</h2><h3 id="2-1envoy-listener-http-inspector功能"><a href="#2-1envoy-listener-http-inspector功能" class="headerlink" title="2.1envoy.listener.http_inspector功能"></a>2.1envoy.listener.http_inspector功能</h3><p>http_inspector的功能是：检查是否是HTTP的请求（HTTP需要是RawBuffer,不是RawBuffer，这个逻辑执行会退出，继续执行下一个filter的逻辑。 RawBuffer是没有经过加密的，换言之是不是TLS、也不是QUIC）。HTTP的请求类型包括：HTTP/1.0、 HTTP/1.1和HTTP/2（h2c)。如果不是HTTP请求，这个filter也不会截流，直接交到下一个filter处理。</p><p>来看一下具体实现的代码看continueFilterChain和http_inspector的onAccept代码：</p><p>在continueFilterChain的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for (; iter_ !&#x3D; accept_filters_.end(); iter_++) &#123;</span><br><span class="line">  Network::FilterStatus status &#x3D; (*iter_)-&gt;onAccept(*this);</span><br><span class="line">  if (status &#x3D;&#x3D; Network::FilterStatus::StopIteration) &#123;</span><br><span class="line">   </span><br><span class="line">    if (!socket().ioHandle().isOpen()) &#123;</span><br><span class="line">      &#x2F;&#x2F; break the loop but should not create new connection</span><br><span class="line">      no_error &#x3D; false;</span><br><span class="line">      break;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; Blocking at the filter but no error</span><br><span class="line">      &#x2F;&#x2F; return 调用栈退出，等待下一个事件的到来（本次事件处理结束，把CPU让给event_base)</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在continueFilterChain的(*iter_)-&gt;onAccept(*this)中执行到了http_inspector的onAccept代码。如果http_inspector返回Network::FilterStatus::StopIteration，那么这个事件的回调暂时return掉，直接退出了。http_inspector返回Network::FilterStatus::StopIteration之前做的一件事就是注册一个回调函数cb（cb最终还是会调用continueFilterChain函数）等待这个TCP连接的下一个事件到来时候重新执行cb。</p><p>http_inspector的onAccept代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Network::FilterStatus Filter::onAccept(Network::ListenerFilterCallbacks&amp; cb) &#123;</span><br><span class="line">  ENVOY_LOG(debug, &quot;http inspector: new connection accepted&quot;);</span><br><span class="line"></span><br><span class="line">  const Network::ConnectionSocket&amp; socket &#x3D; cb.socket();</span><br><span class="line"></span><br><span class="line">  const absl::string_view transport_protocol &#x3D; socket.detectedTransportProtocol();</span><br><span class="line">  &#x2F;&#x2F; 如果有其他listener filter设置了这个不是HTTP（RawBuffer是指HTTP）</span><br><span class="line">  if (!transport_protocol.empty() &amp;&amp;</span><br><span class="line">      transport_protocol !&#x3D; TransportSockets::TransportProtocolNames::get().RawBuffer) &#123;</span><br><span class="line">    ENVOY_LOG(trace, &quot;http inspector: cannot inspect http protocol with transport socket &#123;&#125;&quot;,</span><br><span class="line">              transport_protocol);</span><br><span class="line">    return Network::FilterStatus::Continue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cb_ &#x3D; &amp;cb;</span><br><span class="line">  const ParseState parse_state &#x3D; onRead();</span><br><span class="line">  switch (parse_state) &#123;</span><br><span class="line">  case ParseState::Error:</span><br><span class="line">    &#x2F;&#x2F; As per discussion in https:&#x2F;&#x2F;github.com&#x2F;envoyproxy&#x2F;envoy&#x2F;issues&#x2F;7864</span><br><span class="line">    &#x2F;&#x2F; we don&#39;t add new enum in FilterStatus so we have to signal the caller</span><br><span class="line">    &#x2F;&#x2F; the new condition.</span><br><span class="line">    cb.socket().close();</span><br><span class="line">    return Network::FilterStatus::StopIteration;</span><br><span class="line">  case ParseState::Done:</span><br><span class="line">    return Network::FilterStatus::Continue;</span><br><span class="line">  case ParseState::Continue:</span><br><span class="line">    &#x2F;&#x2F; do nothing but create the event</span><br><span class="line">    ASSERT(file_event_ &#x3D;&#x3D; nullptr);</span><br><span class="line">    file_event_ &#x3D; cb.dispatcher().createFileEvent(</span><br><span class="line">        socket.ioHandle().fd(),</span><br><span class="line">        [this](uint32_t events) &#123;</span><br><span class="line">         ..省略回调函数的实现</span><br><span class="line">        &#125;,</span><br><span class="line">        Event::FileTriggerType::Edge, Event::FileReadyType::Read | Event::FileReadyType::Closed);</span><br><span class="line">    return Network::FilterStatus::StopIteration;</span><br><span class="line">  &#125;</span><br><span class="line">  NOT_REACHED_GCOVR_EXCL_LINE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们重点关注：</p><ul><li>onRead()</li><li>cb.dispatcher().createFileEvent(）</li></ul><p>其中，onRead（详见2.1.1）做的事情就是读取(peek)当前连接的数据包（data），然后看看是不是HTTP的请求（具体实现是读取最大8K的数据，然后查看第一行的数据（每行一\r\n结尾））是否是一个HTTP的请求。</p><ul><li>如果还没读到第一行数据，并且数据没有8K，onRead就会返回ParseState::Continue。（前面讲过，http_inspector有没有检测到HTTP请求不重要，都不会截流，因此这里只关心是否读到第一行数据）</li><li>如果读到了第一行数据，onRead就会返回ParseState::Done，onAccept就会返回Network::FilterStatus::Continue，继续执行下一个filter的逻辑。</li></ul><p>我们重点关注没有读到第一行数据的情况，没有读到第一行后，onAccpet就会执行cb.dispatcher().createFileEvent（）创建一个监听read和closed的事件。注册完事件监听后，返回一个Network::FilterStatus::StopIteration让continueFilterChain让出当前的CPU（执行return）。因为cb.dispatcher().createFileEvent（）已经注册过回调函数了，下次新连接有事件到的时候，会有回调函数会被执行的。</p><p>刚刚注册的回调函数就是如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ENVOY_LOG(trace, &quot;http inspector event: &#123;&#125;&quot;, events);</span><br><span class="line">&#x2F;&#x2F; inspector is always peeking and can never determine EOF.</span><br><span class="line">&#x2F;&#x2F; Use this event type to avoid listener timeout on the OS supporting</span><br><span class="line">&#x2F;&#x2F; FileReadyType::Closed.</span><br><span class="line">bool end_stream &#x3D; events &amp; Event::FileReadyType::Closed;</span><br><span class="line"></span><br><span class="line">const ParseState parse_state &#x3D; onRead();</span><br><span class="line">switch (parse_state) &#123;</span><br><span class="line">case ParseState::Error:</span><br><span class="line">file_event_.reset();</span><br><span class="line">cb_-&gt;continueFilterChain(false);</span><br><span class="line">break;</span><br><span class="line">case ParseState::Done:</span><br><span class="line">  &#x2F;&#x2F; file_event_.reset掉，表明这个listener_filter已经处理完了本次的所有逻辑，就算没有检测到HTTP的版本，也是不会报错的。</span><br><span class="line">&#x2F;&#x2F; reset会删除事件，释放内存时候调用ImplBase的析构函数</span><br><span class="line">file_event_.reset();</span><br><span class="line">&#x2F;&#x2F; Do not skip following listener filters.</span><br><span class="line">cb_-&gt;continueFilterChain(true);</span><br><span class="line">break;</span><br><span class="line">case ParseState::Continue:</span><br><span class="line">if (end_stream) &#123;</span><br><span class="line">  &#x2F;&#x2F; Parser fails to determine http but the end of stream is reached. Fallback to</span><br><span class="line">  &#x2F;&#x2F; non-http.</span><br><span class="line">  done(false);</span><br><span class="line">  file_event_.reset();</span><br><span class="line">  cb_-&gt;continueFilterChain(true);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; do nothing but wait for the next event</span><br><span class="line">&#x2F;&#x2F; 这里面的break相当于return掉函数，直接等待下一个事件（正常是读事件，除非客户端close掉了连接）</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是内部再次执行onRead函数，读取第一行数据，如果读取到了，就调用cb_-&gt;continueFilterChain(true)重新回到下一个filter的执行逻辑中（这里又回到了continueFilterChain的逻辑了）。如果还是读不到第一行数据，就暂时return掉本次的回调，再次等到事件的到来。总之，这个filter一定会等到第一行的数据读取到（或者超过8K的数据）才执行下一个的filter的onAccept(如果配置了的话)</p><p>因此，这里就回答了continueFilterChain为什么会被多次调用的问题了。因为如果filter要读取更多的数据去决策，但是当前的数据还不够决策的时候，只能让出当前的执行CPU，等到下一次事件到来时候再去判断，再在回调函数中执行continueFilterChain函数。</p><h4 id="2-1-1-http-inspector的onRead函数"><a href="#2-1-1-http-inspector的onRead函数" class="headerlink" title="2.1.1 http inspector的onRead函数"></a>2.1.1 http inspector的onRead函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ParseState Filter::onRead() &#123;</span><br><span class="line">  auto&amp; os_syscalls &#x3D; Api::OsSysCallsSingleton::get();</span><br><span class="line">  const Network::ConnectionSocket&amp; socket &#x3D; cb_-&gt;socket();</span><br><span class="line">  const Api::SysCallSizeResult result &#x3D;</span><br><span class="line">      os_syscalls.recv(socket.ioHandle().fd(), buf_, Config::MAX_INSPECT_SIZE, MSG_PEEK);</span><br><span class="line">  ENVOY_LOG(trace, &quot;http inspector: recv: &#123;&#125;&quot;, result.rc_);</span><br><span class="line">  if (result.rc_ &#x3D;&#x3D; -1 &amp;&amp; result.errno_ &#x3D;&#x3D; EAGAIN) &#123;</span><br><span class="line">    return ParseState::Continue;</span><br><span class="line">  &#125; else if (result.rc_ &lt; 0) &#123;</span><br><span class="line">    config_-&gt;stats().read_error_.inc();</span><br><span class="line">    return ParseState::Error;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const auto parse_state &#x3D;</span><br><span class="line">      parseHttpHeader(absl::string_view(reinterpret_cast&lt;const char*&gt;(buf_), result.rc_));</span><br><span class="line">  switch (parse_state) &#123;</span><br><span class="line">  case ParseState::Continue:</span><br><span class="line">    &#x2F;&#x2F; do nothing but wait for the next event</span><br><span class="line">    return ParseState::Continue;</span><br><span class="line">  case ParseState::Error:</span><br><span class="line">    done(false);</span><br><span class="line">    return ParseState::Done;</span><br><span class="line">  case ParseState::Done:</span><br><span class="line">    done(true);</span><br><span class="line">    return ParseState::Done;</span><br><span class="line">  &#125;</span><br><span class="line">  NOT_REACHED_GCOVR_EXCL_LINE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是PEEK一下当前的连接的数据包（并不是真正读取出来，然后执行parseHttpHeader的函数（具体不再深入，怎么判断一个请求是HTTP请求了）。</p><h3 id="2-2-envoy-listener-tls-inspector的功能"><a href="#2-2-envoy-listener-tls-inspector的功能" class="headerlink" title="2.2 envoy.listener.tls_inspector的功能"></a>2.2 envoy.listener.tls_inspector的功能</h3><p>tls的处理逻辑跟http inspector大同小异，也是通过读取一些数据来判断，跟continueFilterChain的交互流程相似，不再细说，下面只讨论功能。</p><p><strong>功能：</strong>检查是否是tls的请求，如果是tls请求则:</p><ol><li>设置当前的requestServerName</li></ol><blockquote><p>cb_-&gt;socket().setRequestedServerName(name);</p></blockquote><ol start="2"><li>这是transportProtocol为TLS</li></ol><blockquote><p>cb_-&gt;socket().setDetectedTransportProtocol(<br>        TransportSockets::TransportProtocolNames::get().Tls);</p></blockquote><p>如果不是tls请求，则跳过（认为没有问题），不会因为这个请求没有加密（tls）就不让请求通过</p><h3 id="2-3-envoy-listener-original-dst的功能"><a href="#2-3-envoy-listener-original-dst的功能" class="headerlink" title="2.3 envoy.listener.original_dst的功能"></a>2.3 envoy.listener.original_dst的功能</h3><p>功能：获取原始的目的地址，修改local_address(因为envoy的local地址就是客户端的dst地址）</p><p>代码逻辑比较简单，不需要读取数据，只需要看当前连接的一些信息就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Network::FilterStatus OriginalDstFilter::onAccept(Network::ListenerFilterCallbacks&amp; cb) &#123;</span><br><span class="line">  ENVOY_LOG(debug, &quot;original_dst: New connection accepted&quot;);</span><br><span class="line">  Network::ConnectionSocket&amp; socket &#x3D; cb.socket();</span><br><span class="line">  const Network::Address::Instance&amp; local_address &#x3D; *socket.localAddress();</span><br><span class="line"></span><br><span class="line">  if (local_address.type() &#x3D;&#x3D; Network::Address::Type::Ip) &#123;</span><br><span class="line">    Network::Address::InstanceConstSharedPtr original_local_address &#x3D;</span><br><span class="line">        getOriginalDst(socket.ioHandle().fd());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; A listener that has the use_original_dst flag set to true can still receive</span><br><span class="line">    &#x2F;&#x2F; connections that are NOT redirected using iptables. If a connection was not redirected,</span><br><span class="line">    &#x2F;&#x2F; the address returned by getOriginalDst() matches the local address of the new socket.</span><br><span class="line">    &#x2F;&#x2F; In this case the listener handles the connection directly and does not hand it off.</span><br><span class="line">    if (original_local_address) &#123;</span><br><span class="line">      &#x2F;&#x2F; Restore the local address to the original one.</span><br><span class="line">      socket.restoreLocalAddress(original_local_address);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Network::FilterStatus::Continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重点关注</p><ul><li>original_local_address =<pre><code>getOriginalDst(socket.ioHandle().fd())</code></pre></li><li>socket.restoreLocalAddress(original_local_address);</li></ul><p>流程就是获取原来的目的地址（只有经过DNAT或REDIRECT才有原来的目的地址），如果获取到了原来的目的地址，就把当前连接的localAddress设置为原来的目的地址。localAddress其实就是envoy这边的连接地址，如果这个连接是经过DNAT（举例），然后又设置了这个filter，那么在envoy内部的元数据localAddress就改为原来的目的地址。</p><h3 id="2-4-envoy-listener-original-src的功能"><a href="#2-4-envoy-listener-original-src的功能" class="headerlink" title="2.4 envoy.listener.original_src的功能"></a>2.4 envoy.listener.original_src的功能</h3><p>数据的走向可以简化为：</p><blockquote><p>downstream &lt;–&gt; envoy &lt;–&gt; upstream</p></blockquote><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">OriginalSrcFilter::OriginalSrcFilter(const Config&amp; config) : config_(config) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Network::FilterStatus OriginalSrcFilter::onAccept(Network::ListenerFilterCallbacks&amp; cb) &#123;</span><br><span class="line">  auto&amp; socket &#x3D; cb.socket();</span><br><span class="line">  auto address &#x3D; socket.remoteAddress();</span><br><span class="line">  ASSERT(address);</span><br><span class="line"></span><br><span class="line">  ENVOY_LOG(debug,</span><br><span class="line">            &quot;Got a new connection in the original_src filter for address &#123;&#125;. Marking with &#123;&#125;&quot;,</span><br><span class="line">            address-&gt;asString(), config_.mark());</span><br><span class="line"></span><br><span class="line">  if (address-&gt;type() !&#x3D; Network::Address::Type::Ip) &#123;</span><br><span class="line">    &#x2F;&#x2F; nothing we can do with this.</span><br><span class="line">    return Network::FilterStatus::Continue;</span><br><span class="line">  &#125;</span><br><span class="line">  auto options_to_add &#x3D;</span><br><span class="line">      Filters::Common::OriginalSrc::buildOriginalSrcOptions(std::move(address), config_.mark());</span><br><span class="line">  socket.addOptions(std::move(options_to_add));</span><br><span class="line">  return Network::FilterStatus::Continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重点关注buildOriginalSrcOptions设置了和socket.addOptions。配置了一些socket的参数（没细看）使得envoy连接到upstream的时候使用的源ip地址变成downstream的地址，这样upstream就认为请求是downstream发送过来的。</p><p>官网上的功能描述比较详细：</p><ol><li>使用downstream的地址情况</li></ol><blockquote><p>The original source listener filter replicates the downstream remote address of the connection on the upstream side of Envoy. For example, if a downstream connection connects to Envoy with IP address 10.1.2.3, then Envoy will connect to the upstream with source IP 10.1.2.3.</p></blockquote><ol start="2"><li>使用pp包内部的地址情况<br>另外还有一个就是proxy Protocol和这个filter的配合使用</li></ol><blockquote><p>Interaction with Proxy Protocol<br>If the connection has not had its source address translated or proxied, then Envoy can simply use the existing connection information to build the correct downstream remote address. However, if this is not true, a Proxy Protocol filter may be used to extract the downstream remote address.</p></blockquote><p>也就是说，如果这个listener配置了original_src和proxy_protocol（这个先配置），那么连接到upstream时候使用的源地址改为pp包内的地址。</p><h3 id="2-5-envoy-listener-proxy-protocol的功能"><a href="#2-5-envoy-listener-proxy-protocol的功能" class="headerlink" title="2.5 envoy.listener.proxy_protocol的功能"></a>2.5 envoy.listener.proxy_protocol的功能</h3><p>功能：读取（首先是PEEK，如果PEEK到时发现是pp包就真正读取出来）连接的数据，获取到真正的源ip和源端口。需要注意的是：<strong>如果配置了这个filter，一定要带proxy protocol</strong>，不然正常的访问会得到（识别不到请求）</p><blockquote><p>lijiancai@LAPTOP-U28497J3:~$curl <a href="http://192.168.42.128:78/">http://192.168.42.128:78</a></p><p>curl: (52) Empty reply from server</p></blockquote><p>这个就是proxy_protocol与其他四个filter不一样的地方，其他四个filter不会截流，这个filter会（当然是只有在没有识别到pp包的情况下会截流）</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Envoy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Envoy扩展功能—Webassembly</title>
      <link href="../2021/02/23/Envoy%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD%E2%80%94Webassembly/"/>
      <url>../2021/02/23/Envoy%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD%E2%80%94Webassembly/</url>
      
        <content type="html"><![CDATA[<h1 id="1-软件版本声明"><a href="#1-软件版本声明" class="headerlink" title="1. 软件版本声明"></a>1. 软件版本声明</h1><ul><li>Istio的版本是release-1.8，对应的源码地址是：<a href="https://github.com/istio/istio/tree/release-1.8">https://github.com/istio/istio/tree/release-1.8</a></li><li>Envoy的版本（Istio官方自己维护了一份Envoy的代码，方便其功能扩展）是 release-1.8，对应的源码地址是：<a href="https://github.com/istio/envoy/tree/release-1.8">https://github.com/istio/envoy/tree/release-1.8</a> </li></ul><h1 id="2-Envoy目前支持Wasm扩展的功能有哪些"><a href="#2-Envoy目前支持Wasm扩展的功能有哪些" class="headerlink" title="2. Envoy目前支持Wasm扩展的功能有哪些"></a>2. Envoy目前支持Wasm扩展的功能有哪些</h1><ul><li><p>Network Filter （TCP或UDP）上扩展，代码路径是<code>source/extensions/filters/network/wasm</code></p></li><li><p>HTTP Filter 上扩展,代码路径是<code>source/extensions/filters/http/wasm</code> </p></li><li><p>Access Logger 上扩展，代码路径是<code>source/extensions/access_loggers/wasm</code></p></li><li><p>Boostrap 上扩展，代码路径是<code>source/extensions/bootstrap/wasm</code></p></li><li><p>Stat Sink 上扩展，代码路径是<code>source/extensions/stat_sinks/wasm</code></p></li></ul><h1 id="3-Wasm的运行模型和隔离性"><a href="#3-Wasm的运行模型和隔离性" class="headerlink" title="3. Wasm的运行模型和隔离性"></a>3. Wasm的运行模型和隔离性</h1><ul><li><p>代码执行过程中，不可抛异常，否则虚拟机会退出。下面代码是不能执行的，有异常捕捉。(<a href="https://github.com/envoyproxy/envoy-wasm/issues/9">https://github.com/envoyproxy/envoy-wasm/issues/9</a>)</p></li><li></li></ul><h1 id="4-Network-Filter中的Wasm插件开发和部署"><a href="#4-Network-Filter中的Wasm插件开发和部署" class="headerlink" title="4. Network Filter中的Wasm插件开发和部署"></a>4. Network Filter中的Wasm插件开发和部署</h1><p>Demo的代码如下,重点放在ExampleContext::onDownstreamData和ExampleContext::onUpstreamData上，这两个函数是是Neteork Filter中会被调用的。至于Envoy是如何和这两个函数联系在一起以及其运行的模型，需要较大的篇幅描述，放在一篇独立的文章中详述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;proxy_wasm_intrinsics.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleRootContext</span> :</span> <span class="keyword">public</span> RootContext &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; count&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ExampleRootContext</span><span class="params">(<span class="keyword">uint32_t</span> id, <span class="built_in">std</span>::string_view root_id)</span></span></span><br><span class="line"><span class="function">      : <span class="title">RootContext</span><span class="params">(id, root_id)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">atomicAdd</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count++; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">onStart</span><span class="params">(<span class="keyword">size_t</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">onConfigure</span><span class="params">(<span class="keyword">size_t</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleContext</span> :</span> <span class="keyword">public</span> Context &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ExampleContext</span><span class="params">(<span class="keyword">uint32_t</span> id, RootContext* root)</span> : <span class="title">Context</span><span class="params">(id, root)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">FilterHeadersStatus <span class="title">onRequestHeaders</span><span class="params">(<span class="keyword">uint32_t</span> headers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">bool</span> end_of_stream)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">FilterDataStatus <span class="title">onRequestBody</span><span class="params">(<span class="keyword">size_t</span> body_buffer_length,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">bool</span> end_of_stream)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">FilterHeadersStatus <span class="title">onResponseHeaders</span><span class="params">(<span class="keyword">uint32_t</span> headers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">bool</span> end_of_stream)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">FilterStatus <span class="title">onUpstreamData</span><span class="params">(<span class="keyword">size_t</span> bz, <span class="keyword">bool</span> end)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">FilterStatus <span class="title">onDownstreamData</span><span class="params">(<span class="keyword">size_t</span> bz, <span class="keyword">bool</span> end)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">FilterStatus <span class="title">onNewConnection</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">FilterDataStatus <span class="title">onResponseBody</span><span class="params">(<span class="keyword">size_t</span> body_buffer_length,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">bool</span> end_of_stream)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onDone</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onLog</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onDelete</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterContextFactory <span class="title">register_ExampleContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    CONTEXT_FACTORY(ExampleContext), ROOT_FACTORY(ExampleRootContext),</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;network_filter_demo&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ExampleRootContext::onStart</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>&#123;</span><br><span class="line">  LOG_TRACE(<span class="string">&quot;onStart&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ExampleRootContext::onConfigure</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>&#123;</span><br><span class="line">  LOG_TRACE(<span class="string">&quot;onConfigure&quot;</span>);</span><br><span class="line">  proxy_set_tick_period_milliseconds(<span class="number">1000</span>);  <span class="comment">// 1 sec</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleRootContext::onTick</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleContext::onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LOG_WARN(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;onCreate &quot;</span> + <span class="built_in">std</span>::to_string(id())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FilterStatus <span class="title">ExampleContext::onNewConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FilterStatus::Continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FilterStatus <span class="title">ExampleContext::onDownstreamData</span><span class="params">(<span class="keyword">size_t</span> bz, <span class="keyword">bool</span> end)</span> </span>&#123;</span><br><span class="line">  LOG_WARN(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;onDownStreamData recieve bytes size:&quot;</span> + <span class="built_in">std</span>::to_string(bz)));</span><br><span class="line">  <span class="keyword">return</span> FilterStatus::Continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FilterStatus <span class="title">ExampleContext::onUpstreamData</span><span class="params">(<span class="keyword">size_t</span> bz, <span class="keyword">bool</span> end)</span> </span>&#123;</span><br><span class="line">  LOG_WARN(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;onUpstreamData recieve bytes size:&quot;</span> + <span class="built_in">std</span>::to_string(bz)));</span><br><span class="line">  <span class="keyword">return</span> FilterStatus::Continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FilterHeadersStatus <span class="title">ExampleContext::onRequestHeaders</span><span class="params">(<span class="keyword">uint32_t</span>, <span class="keyword">bool</span>)</span> </span>&#123;</span><br><span class="line">  LOG_DEBUG(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;onRequestHeaders &quot;</span>) + <span class="built_in">std</span>::to_string(id()));</span><br><span class="line">  <span class="keyword">return</span> FilterHeadersStatus::Continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FilterHeadersStatus <span class="title">ExampleContext::onResponseHeaders</span><span class="params">(<span class="keyword">uint32_t</span>, <span class="keyword">bool</span>)</span> </span>&#123;</span><br><span class="line">  LOG_DEBUG(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;onResponseHeaders &quot;</span>) + <span class="built_in">std</span>::to_string(id()));</span><br><span class="line">  <span class="keyword">return</span> FilterHeadersStatus::Continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FilterDataStatus <span class="title">ExampleContext::onRequestBody</span><span class="params">(<span class="keyword">size_t</span> body_buffer_length,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">bool</span> <span class="comment">/* end_of_stream */</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FilterDataStatus::Continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FilterDataStatus <span class="title">ExampleContext::onResponseBody</span><span class="params">(<span class="keyword">size_t</span> <span class="comment">/* body_buffer_length */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">bool</span> <span class="comment">/* end_of_stream */</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FilterDataStatus::Continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleContext::onDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LOG_WARN(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;onDone &quot;</span> + <span class="built_in">std</span>::to_string(id())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleContext::onLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LOG_WARN(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;onLog &quot;</span> + <span class="built_in">std</span>::to_string(id())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleContext::onDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LOG_WARN(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;onDelete &quot;</span> + <span class="built_in">std</span>::to_string(id())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExampleContext::onDownstreamData是客户端（DownStream）发送数据到Envoy的时候会被调用，ExampleContext::onUpstreamData是上游服务器中（Upstream）发送数据回Envoy的时候会被调用。</p><p>envoy的配置文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">admin:</span></span><br><span class="line">  <span class="attr">access_log_path:</span> <span class="string">&quot;/home/lijiancai/admin_access.log&quot;</span></span><br><span class="line">  <span class="attr">address:</span></span><br><span class="line">    <span class="attr">socket_address:</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">      <span class="attr">port_value:</span> <span class="number">9901</span></span><br><span class="line"><span class="attr">static_resources:</span></span><br><span class="line">  <span class="attr">listeners:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">listener_0</span></span><br><span class="line">      <span class="attr">address:</span></span><br><span class="line">        <span class="attr">socket_address:</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">          <span class="attr">port_value:</span> <span class="number">10000</span></span><br><span class="line">      <span class="attr">filter_chains:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.network.wasm</span></span><br><span class="line">              <span class="attr">typed_config:</span></span><br><span class="line">                <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/udpa.type.v1.TypedStruct</span></span><br><span class="line">                <span class="attr">type_url:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.network.wasm.v3.Wasm</span></span><br><span class="line">                <span class="attr">value:</span></span><br><span class="line">                  <span class="attr">config:</span></span><br><span class="line">                    <span class="attr">name:</span> <span class="string">my_plugin</span></span><br><span class="line">                    <span class="attr">root_id:</span> <span class="string">network_filter_demo</span></span><br><span class="line">                    <span class="attr">vm_config:</span></span><br><span class="line">                      <span class="attr">runtime:</span> <span class="string">envoy.wasm.runtime.v8</span></span><br><span class="line">                      <span class="attr">vm_id:</span> <span class="string">demo1</span></span><br><span class="line">                      <span class="attr">code:</span></span><br><span class="line">                        <span class="attr">local:</span></span><br><span class="line">                          <span class="attr">filename:</span> <span class="string">&quot;./network_filter_demo.wasm&quot;</span></span><br><span class="line">                      <span class="attr">allow_precompiled:</span> <span class="literal">true</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.network.tcp_proxy</span></span><br><span class="line">              <span class="attr">typed_config:</span></span><br><span class="line">                <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy</span></span><br><span class="line">                <span class="attr">stat_prefix:</span> <span class="string">service_goole_tcp</span></span><br><span class="line">                <span class="attr">cluster:</span> <span class="string">service_google</span></span><br><span class="line">  <span class="attr">clusters:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">service_google</span></span><br><span class="line">      <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">LOGICAL_DNS</span></span><br><span class="line">      <span class="attr">dns_lookup_family:</span> <span class="string">V4_ONLY</span></span><br><span class="line">      <span class="attr">lb_policy:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line">      <span class="attr">load_assignment:</span></span><br><span class="line">        <span class="attr">cluster_name:</span> <span class="string">service_google</span></span><br><span class="line">        <span class="attr">endpoints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">                  <span class="attr">address:</span></span><br><span class="line">                    <span class="attr">socket_address:</span></span><br><span class="line">                      <span class="attr">address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">                      <span class="attr">port_value:</span> <span class="number">8888</span></span><br></pre></td></tr></table></figure><p>调试步骤：</p><ol><li><p>启动upstream ：<code>nc -l -p 8888</code></p></li><li><p>启动envoy： ./envoy -c network_filter_demo.yaml</p></li><li><p>启动downstream: nc 127.0.0.1 10000</p></li><li><p>在upstream和downstream都发送一些数据看一下日志输出，日志输出如下</p><blockquote><p>[2021-02-23 16:34:17.408][23601][warning][wasm] [source/extensions/common/wasm/context.cc:1168] wasm log: [envoy-wasm-demo/network_filter_demo.cc:70]::onDownstreamData() onDownStreamData recieve bytes size:2<br>[2021-02-23 16:34:19.189][23601][warning][wasm] [source/extensions/common/wasm/context.cc:1168] wasm log: [envoy-wasm-demo/network_filter_demo.cc:70]::onDownstreamData() onDownStreamData recieve bytes size:4<br>[2021-02-23 16:34:22.677][23601][warning][wasm] [source/extensions/common/wasm/context.cc:1168] wasm log: [envoy-wasm-demo/network_filter_demo.cc:75]::onUpstreamData() onUpstreamData recieve bytes size:5<br>[2021-02-23 16:34:25.094][23601][warning][wasm] [source/extensions/common/wasm/context.cc:1168] wasm log: [envoy-wasm-demo/network_filter_demo.cc:75]::onUpstreamData() onUpstreamData recieve bytes size:3</p></blockquote></li></ol><h1 id="5-HTTP-Filter中的Wasm插件开发和部署"><a href="#5-HTTP-Filter中的Wasm插件开发和部署" class="headerlink" title="5. HTTP Filter中的Wasm插件开发和部署"></a>5. HTTP Filter中的Wasm插件开发和部署</h1><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Envoy </tag>
            
            <tag> Webassembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络性能指标</title>
      <link href="../2021/02/23/%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/"/>
      <url>../2021/02/23/%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h1 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h1><p>在讨论网络相关的性能压测工具前，需要知道有哪些指标是用来观察网络性能的。常见的网络性能指标有：</p><ul><li><p>带宽： 链路理论上最大的传输速率，单位是b/s</p></li><li><p>吞吐量：链路在不丢包的情况下最大的数据传输率。</p></li><li><p>网络链路使用率：吞吐量/带宽 ，因为带宽只是理论上的最大传输速率（但是理论往往是比较难达到的），因此在测量的时候，一般都是测量吞吐量（或使用率）。</p></li><li><p>延时： 网络请求发出后，一直到收到响应为止。在不同的维度，延时的意涵有所区别，比如在TCP握手常见，延时表示TCP连接建立时间；如果在3层的数据包的维度，延时就是数据包往返的时间RTT；如果是在TLS握手的维度，延时又是对称加密的密钥协商的用时。主要用于评估网络在不同的压力情况下，网络延时是否符合需求。如果网络压力过大，中间的节点可能会出现排队导致延时变大。</p></li><li><p>PPS：Packet Per Second，表示网络包（以包为单位）的传输速率，常用于评估网络的转发能力。</p></li><li><p>CPS： Connection Per Second，每秒新建连接数，主要用于评估处理新增连接的能力。</p></li><li><p>QPS：Query Per Second，每秒查询数量，主要用于评估业务处理请求的极限。在短连接的场景，QPS～=CPS；在长连接的场景CPS&lt;QPS。</p></li></ul><p>上述的网络指标中，不同的使用场景，需要关注的指标又不太一样。比如</p><ul><li>Web应用或APP等应用层，我们一般需要关注的是HTTP（s）/GRPC的性能，这时候我们关注的是业务的QPS或CPS。</li><li>对于一些游戏服务器或IM的应用，为了支持更大的同时在线人数，通常会基于TCP或UDP的基础上进行客户端和服务端的连接，这些场景需要测试TCP或UDP的性能，关注的指标可以是PPS和延时。</li><li>虚拟化网络设备的运行服务器场景，更多的是3层上的路由转发或UDP包处理，这时候更多关注的是PPS。</li></ul><h1 id="转发层面的性能测试"><a href="#转发层面的性能测试" class="headerlink" title="转发层面的性能测试"></a>转发层面的性能测试</h1><h2 id="带宽测试"><a href="#带宽测试" class="headerlink" title="带宽测试"></a>带宽测试</h2><p>使用工具iperf，步骤如下：</p><ol><li>需要准备两台机器，一台为server，一台为client。在server端，监听一个TCP端口：<code>iperf -s</code>, 此命令会让服务器监听5001端口。</li><li>客户对服务端进行带宽测试，执行 : <code>iperf -c server_ip -t 5</code></li></ol><p>测试报告，客户端输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------</span><br><span class="line">Client connecting to *.*.*.s, TCP port 5001</span><br><span class="line">TCP window size: 64.0 KByte (default)</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">[  3] <span class="built_in">local</span> *.*.*.c port 36582 connected with *.*.*.s port 5001</span><br><span class="line">[ ID] Interval       Transfer     Bandwidth</span><br><span class="line">[  3]  0.0- 5.1 sec   437 MBytes   713 Mbits/sec</span><br></pre></td></tr></table></figure><p>可以看到带宽是713Mb/s,iperf默认是使用TCP进行压测。也可以使用UDP。在业务使用场景，压测时间应该调得更大，减少误差。</p><h2 id="PPS测试"><a href="#PPS测试" class="headerlink" title="PPS测试"></a>PPS测试</h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Networking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go性能基础测试</title>
      <link href="../2021/02/23/Go%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E6%B5%8B%E8%AF%95/"/>
      <url>../2021/02/23/Go%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Go的性能测试Demo"><a href="#Go的性能测试Demo" class="headerlink" title="Go的性能测试Demo"></a>Go的性能测试Demo</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> letterBytes = <span class="string">&quot;dfads;joasdjIFIOSHUIOFHwfhjad;fhjSIDphdfads&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomString</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> b &#123;</span><br><span class="line">b[i]= letterBytes[rand.Intn(<span class="built_in">len</span>(letterBytes))]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> genString <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringsBuilder</span><span class="params">(n <span class="keyword">int</span>, s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> builder strings.Builder</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">builder.WriteString(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> builder.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bytesBuffer</span><span class="params">(n <span class="keyword">int</span>, s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">buf.WriteString(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmark</span><span class="params">(b *testing.B, f genString)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s = randomString(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">f(<span class="number">10000</span>, s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStringsBuilderConcat</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">benchmark(b, stringsBuilder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkBytesBufferConcat</span><span class="params">(b *testing.B)</span></span>  &#123;</span><br><span class="line">benchmark(b, bytesBuffer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行下面的命令，即可进行基准测试。<code>go test -bench=&quot;.*&quot; -benchmem .</code></p><p>输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: helloWorld</span><br><span class="line">BenchmarkStringsBuilderConcat-8             5256            198909 ns/op         1120229 B/op         25 allocs/op</span><br><span class="line">BenchmarkBytesBufferConcat-8                6309            189714 ns/op          903523 B/op         14 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      helloWorld      3.295s</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符编码格式</title>
      <link href="../2021/02/22/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/"/>
      <url>../2021/02/22/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Unicode"><a href="#什么是Unicode" class="headerlink" title="什么是Unicode"></a>什么是Unicode</h1><p>Unicode可以理解为字符集，由一个国际组织给每个字符分配一个编号（或者叫ID）。记住：Unicode只负责分配ID。</p><p>计算机只能保存0101的二进制格式的数据，所谓在一个字符保存到计算机中其实有两个步骤：</p><ul><li>找到某个字符的Unicode字符编号</li><li>根据字符编号，选择响应的编码格式生成对应的二机制数据</li></ul><p>举个例子：</p><p>Unicode字符集中，“中”的编码编号是4E2D，“国”的编码编号是56FD。但是编码编号相当于一个数字，怎么保存到计算机的存储设备上呢？这时候就是编码对应的存储格式的任务的，Unicode的存储格式有UTF-8、utf-16等存储格式。其中UTF-8的应用比较广泛，就以UTF-8 为例子：“中”的UTF-8格式是：E4B8AD。“国”的UTF-8格式是：E59BBD。 UTF-8是真正保存在计算机存储设备上的数据格式。</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20201230175802402.png" alt="image-20201230175802402"></p><p>Unicode可以理解为一本字典，里面记录了每个字符的编号。至于这些编号怎么对应保存到计算机中呢？就是UTF-8把Unicode的编号转义后保存到计算机中去。因此，Unicode与uft-8不是同一个层次上的东西，UTF-8格式可以说是Unicode的一种实现方式而已。</p><p>因此，我们可以看到Unicode经常推出一些新的字符、表情（😊）等emoji，其实就是在做字符编码编号的事情，给每个字符一个ID。</p><p>资源链接：</p><ul><li>中文的Unicode编码编号查询：<a href="http://www.chi2ko.com/tool/CJK.htm">http://www.chi2ko.com/tool/CJK.htm</a></li><li>中文的UTF-8格式查询：<a href="http://www.shabsin.com/~rshabsin/chineseutf8chars.html">http://www.shabsin.com/~rshabsin/chineseutf8chars.html</a></li><li>Unicode组织的官网：<a href="https://home.unicode.org/">https://home.unicode.org/</a></li></ul><p>编码格式全景图：</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20201230162147496.png" alt="image-20201230162147496"></p><h1 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h1><p>ASCII全称<strong>American Standard Code for Information Interchange</strong>，只有128个字符，从名字就能看出来，一开始设置的时候只考虑到了英文字符的编码，毕竟美帝128个字符就够用了。但是随着计算机技术的发展和普及，非英文语系国家使用就会出现字符编码的问题的。所以就出现了Unicode、GBK和GB2312这些编码格式。</p><p>ASCII编码表：</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/875px-ASCII-Table-wide.svg.png" alt="ASCII - Simple English Wikipedia, the free encyclopedia"></p><h1 id="UTF-8编码格式"><a href="#UTF-8编码格式" class="headerlink" title="UTF-8编码格式"></a>UTF-8编码格式</h1><p>UTF-8编码格式是一种变长的编码格式，从一个字节到四个字节不等，并且兼容ASCII格式，这也就是为什么UTF-8格式为什么这么流行和被这么多系统采用的原因。因为兼容ASCII，原来使用ASCII格式保存的数据，可以直接使用UTF-8格式的解码系统解码，并且不会增加原有文档的使用空间。如果UTF-8是定长的，比如四个字节，那么原来有ASCII保存的文件是1KB的，使用UTF-8编码后，占用的空间就需要4KB了。</p><p>现在我们来探讨一下UTF-8怎么实现变成编码和兼容ASCII格式的。编码规则有两条</p><ul><li>1个字节的符号，字节第一位设置0。后面7位作为这个符号的Unicode码。因此，UTF-8就可以与ASCII兼容了</li><li>对于n个字节的符号（n&gt;1&amp;&amp;n&lt;=4)。第1个字节的前n位都是1，第n+1位是0。后面的n-1个字节的前两位都设置为10。剩余没有提及到的bit，为这个符号的Unicode码。</li></ul><p>Unicode字符集和UTF-8编码的对应表格如下：</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/utf8-encoding-table.png"></p><ul><li>Unicode编码是00到7F的，使用一个字节表示。所以0xxx xxxx中的x表示，x可以为0也可以为1，取决于这个编码是什么。</li><li>Unicode编码是80到7FF的，使用2个字节表示。110x xxxx 10xx xxxx是固定的格式，剩余的11个x，表示只有11个bits用来填充Unicode</li><li>Unicode编码是800到FFFF的，使用3个字节表示</li><li>Unicode编码是10000到10FFFF的，使用4个字节表示。</li></ul><p>“中”的Unicode编码是4E2D，“国”的Unicode编码是56FD，都需要使用3个字节表示。三个字节表示的UTF-8编码中，1110 xxxx 10xx xxxx 10xx xxxx都是固定的格式，剩余的x就需要使用Unicode的二进制( 国：101011011111101)，从最右边的x开始填充，如果不够就填Unicode的二进制编码0。下面以“国”字为例子，演示转换的过程</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20201230172653720.png" alt="image-20201230172653720"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Envoy-Wasm</title>
      <link href="../2021/02/22/Envoy-Wasm/"/>
      <url>../2021/02/22/Envoy-Wasm/</url>
      
        <content type="html"><![CDATA[<h1 id="1-架构模型"><a href="#1-架构模型" class="headerlink" title="1. 架构模型"></a>1. 架构模型</h1><ul><li>VM采用<code>vm_id</code>标记不同的VM。</li><li>每个VM都是线程间唯一的，换言之即使是同一个<code>vm_id</code>,在不同的线程中都是唯一的，这样就不存在锁开销。</li><li>在同一个线程中，同一个VM的是共享的。</li></ul><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210222195759.png"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Envoy </tag>
            
            <tag> Istio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello world</title>
      <link href="../2021/02/22/hello-world/"/>
      <url>../2021/02/22/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>hello world</p><p>20210224</p><p>test 123</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">static_resources:</span></span><br><span class="line">  <span class="attr">listeners:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span></span><br><span class="line">      <span class="attr">socket_address:</span></span><br><span class="line">        <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        <span class="attr">port_value:</span> <span class="number">8001</span></span><br><span class="line">    <span class="attr">filter_chains:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">filters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.network.http_connection_manager</span></span><br><span class="line">        <span class="attr">typed_config:</span></span><br><span class="line">          <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager</span></span><br><span class="line">          <span class="attr">codec_type:</span> <span class="string">auto</span></span><br><span class="line">          <span class="attr">stat_prefix:</span> <span class="string">ingress_http</span></span><br><span class="line">          <span class="attr">route_config:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">local_route</span></span><br><span class="line">            <span class="attr">virtual_hosts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">local_service</span></span><br><span class="line">              <span class="attr">domains:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">              <span class="attr">request_headers_to_add:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">header:</span></span><br><span class="line">                  <span class="attr">key:</span> <span class="string">host</span></span><br><span class="line">                  <span class="attr">value:</span> <span class="string">www.baidu.com</span></span><br><span class="line">                <span class="attr">append:</span> <span class="literal">false</span></span><br><span class="line">              <span class="attr">routes:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">                  <span class="attr">prefix:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">                <span class="attr">route:</span></span><br><span class="line">                  <span class="attr">cluster:</span> <span class="string">web_service</span></span><br><span class="line">          <span class="attr">http_filters:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.wasm</span></span><br><span class="line">            <span class="attr">typed_config:</span></span><br><span class="line">              <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/udpa.type.v1.TypedStruct</span></span><br><span class="line">              <span class="attr">type_url:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm</span></span><br><span class="line">              <span class="attr">value:</span></span><br><span class="line">                <span class="attr">config:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">&quot;my_plugin2&quot;</span></span><br><span class="line">                  <span class="attr">root_id:</span> <span class="string">&quot;my_root_id2&quot;</span></span><br><span class="line">                  <span class="attr">configuration:</span></span><br><span class="line">                    <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">&quot;type.googleapis.com/google.protobuf.StringValue&quot;</span></span><br><span class="line">                    <span class="attr">value:</span> <span class="string">|</span></span><br><span class="line">                      &#123;&#125;</span><br><span class="line">                  <span class="attr">vm_config:</span></span><br><span class="line">                    <span class="attr">runtime:</span> <span class="string">&quot;envoy.wasm.runtime.v8&quot;</span></span><br><span class="line">                    <span class="attr">vm_id:</span> <span class="string">&quot;my_vm_id&quot;</span></span><br><span class="line">                    <span class="attr">code:</span></span><br><span class="line">                      <span class="attr">local:</span></span><br><span class="line">                        <span class="attr">filename:</span> <span class="string">&quot;envoy_filter_http_wasm_example.wasm&quot;</span></span><br><span class="line">                    <span class="attr">configuration:</span> &#123;&#125;</span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.router</span></span><br><span class="line">            <span class="attr">typed_config:</span> &#123;&#125;</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span></span><br><span class="line">      <span class="attr">socket_address:</span></span><br><span class="line">        <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        <span class="attr">port_value:</span> <span class="number">8000</span></span><br><span class="line">    <span class="attr">filter_chains:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">filters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.network.http_connection_manager</span></span><br><span class="line">        <span class="attr">typed_config:</span></span><br><span class="line">          <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager</span></span><br><span class="line">          <span class="attr">codec_type:</span> <span class="string">auto</span></span><br><span class="line">          <span class="attr">stat_prefix:</span> <span class="string">ingress_http</span></span><br><span class="line">          <span class="attr">route_config:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">local_route</span></span><br><span class="line">            <span class="attr">virtual_hosts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">local_service</span></span><br><span class="line">              <span class="attr">domains:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">              <span class="attr">request_headers_to_add:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">header:</span></span><br><span class="line">                  <span class="attr">key:</span> <span class="string">host</span></span><br><span class="line">                  <span class="attr">value:</span> <span class="string">www.baidu.com</span></span><br><span class="line">                <span class="attr">append:</span> <span class="literal">false</span></span><br><span class="line">              <span class="attr">routes:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">                  <span class="attr">prefix:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">                <span class="attr">route:</span></span><br><span class="line">                  <span class="attr">cluster:</span> <span class="string">web_service</span></span><br><span class="line">          <span class="attr">http_filters:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.wasm</span></span><br><span class="line">            <span class="attr">typed_config:</span></span><br><span class="line">              <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/udpa.type.v1.TypedStruct</span></span><br><span class="line">              <span class="attr">type_url:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm</span></span><br><span class="line">              <span class="attr">value:</span></span><br><span class="line">                <span class="attr">config:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">&quot;my_plugin&quot;</span></span><br><span class="line">                  <span class="attr">root_id:</span> <span class="string">&quot;my_root_id&quot;</span></span><br><span class="line">                  <span class="attr">configuration:</span></span><br><span class="line">                    <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">&quot;type.googleapis.com/google.protobuf.StringValue&quot;</span></span><br><span class="line">                    <span class="attr">value:</span> <span class="string">|</span></span><br><span class="line">                      &#123;&#125;</span><br><span class="line">                  <span class="attr">vm_config:</span></span><br><span class="line">                    <span class="attr">runtime:</span> <span class="string">&quot;envoy.wasm.runtime.v8&quot;</span></span><br><span class="line">                    <span class="attr">vm_id:</span> <span class="string">&quot;my_vm_id&quot;</span></span><br><span class="line">                    <span class="attr">code:</span></span><br><span class="line">                      <span class="attr">local:</span></span><br><span class="line">                        <span class="attr">filename:</span> <span class="string">&quot;envoy_filter_http_wasm_example.wasm&quot;</span></span><br><span class="line">                    <span class="attr">configuration:</span> &#123;&#125;</span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.router</span></span><br><span class="line">            <span class="attr">typed_config:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">clusters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web_service</span></span><br><span class="line">    <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">LOGICAL_DNS</span></span><br><span class="line">    <span class="attr">lb_policy:</span> <span class="string">round_robin</span></span><br><span class="line">    <span class="attr">load_assignment:</span></span><br><span class="line">      <span class="attr">cluster_name:</span> <span class="string">service1</span></span><br><span class="line">      <span class="attr">endpoints:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">            <span class="attr">address:</span></span><br><span class="line">              <span class="attr">socket_address:</span></span><br><span class="line">                <span class="attr">address:</span> <span class="string">www.baidu.com</span></span><br><span class="line">                <span class="attr">port_value:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Demo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcp-protocol</title>
      <link href="../2020/06/09/tcp-protocol/"/>
      <url>../2020/06/09/tcp-protocol/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP协议是什么？"><a href="#TCP协议是什么？" class="headerlink" title="TCP协议是什么？"></a>TCP协议是什么？</h2><p>​        TCP（Transmission Control Protoco 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内。如图1所示，TCP工作在4层，它的下一层是网络层，主要的协议有IP协议。</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190610001644.png"></p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图1 OSI七层模型</p><h2 id="TCP握手和挥手"><a href="#TCP握手和挥手" class="headerlink" title="TCP握手和挥手"></a>TCP握手和挥手</h2><p>本文先讲述TCP的握手和挥手的流程，让大家对TCP连接的建立以及连接的断开先有一个感性的认识。</p><p>实践：</p><ol><li><p>监听一个端口：nc -l -p 1234</p></li><li><p>查看系统当前的监听的端口：ss -l4 -t -n</p></li></ol><blockquote><p>​     State      Recv-Q Send-Q       Local Address:Port         Peer Address:Port      LISTEN     0           1                        *:1234                            <em>:</em></p></blockquote><ol start="3"><li><p>握手的建立： nc 127.0.0.1 1234</p></li><li><p>使用tcpdump保存当前握手的过程：tcpdump -i any port 1234 -w 1234.pcap</p></li><li><p>使用Wireshark查看保存的1234.pcap文件：</p></li></ol><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190610001714.png"></p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图2 TCP握手的抓包</p><h3 id="TCP握手的流程："><a href="#TCP握手的流程：" class="headerlink" title="TCP握手的流程："></a>TCP握手的流程：</h3><p>​       首先发起TCP连接的客户端，发送一个SYN包（序列号seq=A）到服务端，服务端收到SYN包后，回复一个SYN-ACK包（seq=B，ack=A+1），ack=A+1指的是确认了客户端发来的序列号seq为A的包，接着客户端收到SYN-ACK包后又回复了ACK包（seq=A+1,ack=B+1)的包。双方三次握手后建立了连接，服务端和客户端都进入了ESTABLISHED状态。 连接建立后，双方可以进行数据的传输。</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190610001854.png"></p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图3 TCP握手过程</p><h3 id="TCP挥手的流程："><a href="#TCP挥手的流程：" class="headerlink" title="TCP挥手的流程："></a>TCP挥手的流程：</h3><p>TCP连接的端口，称之为挥手。在协议中是经过四个步骤完成连接的断开。</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190610001922.png"></p><p>​                                        图4 TCP挥手的抓包</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190610001940.png"></p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图5 TCP挥手过程</p><p>​    在图5中，描述的是TCP挥手过程的完整流程（当然是在协议中）。为了方便描述，下面主动断开连接的一方称为client，被动关闭的一方称为server。</p><ol><li>client发送一个FIN包（seq=M）给server，表示client将要断开连接，请server也做相应的准备和回复确认。</li><li>server收到FIN包后，回复一个ACK包（ack=M+1）给client，表示我已经收到你的断开连接请求了，等我准备好了后告诉你断开连接，现在还不能断开连接。</li><li>server再接着发送一个FIN包（seq=N）给client端，表示我已经准备好断开连接了。</li><li>client收到FIN包后，回复一个ACK包（ack=N+1）表示我也收到你断开连接的请求了，我们可以愉快地一起断开连接。</li></ol><p>​    经过上述的四个步骤，TCP的连接断开了。但是看图4我们知道，真正实现TCP协议上是有优化的，优化后的步骤是：</p><ol><li>client发送一个FIN-ACK包（seq=M，ack=N）给server，表示client将要断开连接。为什么这里没有一个单独的FIN包，而是有一个ACK包也在里面？后面再详细解说</li><li>server收到FIN-ACK包后，知道client要断开连接，此时server端已经没有要发送的数据了，可以立即断开连接，因此回复的一个FIN-ACK包（seq=N，ack=M+1）的包给client。其实就是讲上面的2和3步骤一起做了，在一个TCP包里发过去，提高效率。</li><li>client收到FIN-ACK包后，回复一个ACK包（ack=N+1）给server端，完成连接的断开。</li></ol><p>​    上述第一个步骤中，为什么client会发送一个FIN-ACK包，而不是协议中的FIN包给server呢？原因是，在一个TCP的包中，ACK的包只是协议中的一个字段，这个字段的有置位，表示这个包是ACK包，另外ack号也是TCP包中一个预留的字段。换言之，一个FIN包和一个FIN-ACK包的大小是一样大的。在网络传输过程中，并不会增加任何的代价。另外我们知道，网络是不稳定的，在client断开连接前，绝大部分情况大都会有数据传输的发送，因此，在client挥手前，必然有发送过一个ACK包给server端，那么这个ACK包在网络中有可能丢失，后续client有可能要重发，所以在client断开连接的时候，也把最近一个的ACK包也一起发过去（不发白不发，反正不占用额外的带宽）。所以，发一个FIN-ACK包不会带来额外的代价，带来的收益是减少重发一个ACK包的可能，何乐而不为。关于FIN-ACK包，你也可以参考：<a href="https://cs.stackexchange.com/questions/76393/tcp-connection-termination-fin-fin-ack-ack">https://cs.stackexchange.com/questions/76393/tcp-connection-termination-fin-fin-ack-ack</a></p><h2 id="TCP协议的状态"><a href="#TCP协议的状态" class="headerlink" title="TCP协议的状态"></a>TCP协议的状态</h2><p>了解TCP协议，一定要了解TCP协议的状态，以及状态之间的转换。</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190610002755.png"></p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图6 TCP的状态</p><p><strong>各个状态之间的含义：</strong></p><ol><li>CLOSED ：初始化状态，以及连接断开后，双方都会进入的状态</li><li>LISTEN：监听状态，只有服务端调用了listen系统调用后才会进入</li><li>SYN SENT：SYN包已发送，只有客户端才有的状态</li><li>SYN RECEIVED：SYN包已收到，只有服务端才有的转态</li><li>ESTABLISHED：连接已建立状态</li><li>FIN WAIT 1：主动断开连接一放发送FIN包后进入的转态，等待ACK包回来</li><li>FIN WAIT 2：FIN WAIT 1状态的一端收到ACK包后进入的转态</li><li>CLOSING： 主动断开连接的一端发了FIN1包，还没收到这个FIN1包的ACK1包之前就收到对端的FIN2包，并且发送回ACK2后进入的状态</li><li>TIME WAIT：主动断开连接的放，发送完最后一个ACK包后进入的状态</li><li>CLOSE WAIT：被动关闭一端收到FIN包，并且回复此FIN包的ACK包后进入的状态</li><li>LAST ACK：被动关闭一端发送FIN包后进入的状态</li></ol><blockquote><p>PS：状态转换图中，每一个状态之间的连线有一个标签 FIN/ACK、CLOSE/FIN之类的，指的是：收到的包/发送出去的包。比如FIN WAIT 1和 CLOSING 之间的线有个标签FIN/ACK,表示的是，一个对象从FIN WAIT 1状态转换到CLOSING状态，需要经过收到一个FIN包，再发送一个ACK包后才能完成转换。另外如果标签中有-表示null，不需要操作。</p></blockquote><p><strong>TIME WAIT状态的补充说明，主动关闭一端在四次挥手的最后一个ACK包发送后，会进入TIME WAIT状态，并且经过一段时间超时后才进入CLOSED状态。</strong></p><p><strong>为什么要有TIME WAIT状态？</strong></p><blockquote><p>TCP握手过程关闭连接，TIME WAIT状态的作用是尽力保证TCP连接的正常关闭。当关闭TCP连接时，主动关闭的一端（A）在发送最后的ACK后，如果这个ACK消息丢失，那么另会超时未收到这个ACK而重传FIN，因此A端必须在TIME WAIT状态下保留连接的状态信息等待着可能再次收到FIN时进⾏行行ACK答复。如果不设置TIME WAIT状态，那么A端再次FIN消息时，则是返回RST信息，B端收到RST信息时则认为连接非正常关闭。虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME WAIT状态就是用来重发可能丢失的ACK报文。</p></blockquote><p><strong>超时时间是多少？</strong></p><blockquote><p>2MSL（maximum segment lifetime），这个和操作系统有关，一般根据RFC793的定义，MSL时间是2分钟，即TIME WAIT的时间为4分钟，但实际应用上MSL也有定义为30秒、1分钟的。Linux上一般是1分钟（cat /proc/sys/net/ipv4/tcp_fin_timeout 可以看到超时时间）</p></blockquote><h3 id="TCP滑动窗口协议"><a href="#TCP滑动窗口协议" class="headerlink" title="TCP滑动窗口协议"></a>TCP滑动窗口协议</h3><p>滑动窗口协议解决的是什么问题？</p><blockquote><p>提高TCP的传输效率。如果每次client给server发送包的时候，都要等到上一个包的确认ack已回来，那么整个TCP的传输效率会非常低下。</p></blockquote><p>TCP中有两个窗口，一个是发送端的窗口( congestion window ，cwnd)，一个是接收端的窗口（receiver window， rwnd）。发送端的窗口值取两者的最小值，用数学方式表达就是：发送方窗口的上限值 = Min [ rwnd, cwnd ]。窗口的协商在握手的过程中有，在数据传输的过程中，接收端也会按需动态调整接收端的窗口值。</p><p>所谓滑动窗口协议就是，发送端根据下面的变量，决定当前是否还能发送数据包：</p><blockquote><p>发送方窗口的上限值（Min [ rwnd, cwnd ]）<br>已发送当还没确认的数据size1<br>还没发送的数据size2</p></blockquote><p><strong>滑动窗口的机制：</strong></p><p>对发送端的TCP buffer做一个快照，TCP buffer的数据存在四个状态：</p><ul><li>已发送并且已经确认</li><li>已发送但还没确认</li><li>未发送，但服务端已经准备好接收</li><li>未发送，服务端也还没准备好接收</li></ul><p><strong>接收方也存在对于的状态：</strong></p><ul><li><p>已接收并且已确认</p></li><li><p>未接收，但已准备好接收</p></li><li><p>未接收，也还没准备好接收</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190610003348.png"></p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图7 发送端维护的窗口1        </p></li></ul><p><strong>发送端维护的结构有</strong></p><ul><li>已发送并且已经确认（0-4 字节）</li><li>已发送但还没确认 （5-10字节）</li><li>未发送，但服务端已经准备好接收（11-16字节）</li><li>未发送，服务端也还没准备好接收 （17-21字节）</li></ul><p><strong>相关定义：</strong></p><p><strong>发送窗口：</strong>接收方允许发送方一次发送未确认的字节数：是第二和第三种类型的和，即5-16字节，共12个字节。</p><p><strong>可用窗口</strong>： 发送端目前还可以发送的的字节数，即11-16字节，共6个字节。</p><p><strong>窗口缩放：</strong>接收方会发送上一次成功接收后的最长字节数，然后发送方会根据最长字节数进行窗口缩放。</p><p>假设，已发送但还没确认的数据分为三段传输5-6，7-8，9-10，共三段，但是接收方只收到了，5-6和9-10这两段数据，这时候接收端之后返回6作为最大成功接收字节数，不选取10，因为7-8没有认为成功接收，因此发送方收到6作为最长字节数后，会将窗口缩放为：</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190610003625.png">               </p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图8 发送端维护的窗口2</p><p>接收方已经收到的9-10，在收到7-8之前不会返回确认，也不会放回10作为最长的字节数，发送端收到6作为最长字节数返回后，可将第三类窗口放大至11-18（因为对比之前有两个字节已经确认了）,然后发送端将11-18的字节发送过去，接着发送端会停止发送其他的包。</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190610003719.png">                </p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图9 发送端维护的窗口3</p><p>发送完11-18字节后的buffer状态</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190610003915.png"></p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图10 发送端维护的窗口4</p><p>滑动窗口是发送端控制的行为，发送端最多发送的数据量就是Win=MIN（rwnd，cwnd），因此，所有的这个机制的行为都在围绕这个值来。可以想象成Win值就是一个副卡牌的所有牌，要发送的每个字节都拿走一张卡牌，确认后将卡牌换回来，因此当卡牌的数量不足的时候，就不能再发送数据了。等到卡牌换回来后再发送。另外，卡牌的数量也会发生变化，随着rwnd和cwnd的值发送变化，rwnd是由接收端决定的，那么cwnd是由发送端决定的。那么cwnd的值怎么变化呢？那就跟下面要讲的拥塞控制有关。</p><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>TCP连接建立后，会进入慢启动的过程。先将cwnd设为一个MSS。</p><p><strong>慢启动算法：</strong>最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生。具体来说，当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(Round Trip Time,RTT)呈指数级增长，事实上，慢启动的速度一点也不慢，只是它的起点比较低一点而已。我们可以简单计算下：</p><blockquote><p>开始 —&gt; cwnd = 1<br>经过1个RTT后 —&gt; cwnd = 2<em>1 = 2<br>经过2个RTT后 —&gt; cwnd = 2</em>2= 4<br>经过3个RTT后 —&gt; cwnd = 4*2 = 8</p></blockquote><p>当cwnd不断指数增长，这个值就会变得很大，此时，慢启动算法就不适用了，cwnd的变化开始进入一个<strong>拥塞避免状态</strong>。</p><p><strong>拥塞避免</strong>（慢启动已经结束）：从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，但是cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，当cwnd超过该值后，慢启动过程结束，进入拥塞避免阶段。对于大多数TCP实现来说，ssthresh的值是65536(同样以字节计算)。拥塞避免的主要思想是加法增大，也就是cwnd的值不再指数级往上升，开始加法增加。此时当窗口中所有的报文段都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。</p><p>除了慢启动和拥塞避免会影响到cwnd的值，还有重传也会改变cwnd的值。其中重传有两种，一是客户端重传，而是服务端要求的快速重传。</p><p><strong>客户端重传算法：</strong>首先来看TCP是如何确定网络进入了拥塞状态的，TCP认为网络拥塞的主要依据是它重传了一个报文段。上面提到过，TCP对每一个报文段都有一个定时器，称为重传定时器(RTO)，当RTO超时且还没有得到数据确认，那么TCP就会对该报文段进行重传，当发生超时时，那么出现拥塞的可能性就很大，某个报文段可能在网络中某处丢失，并且后续的报文段也没有了消息，在这种情况下，TCP反应比较大，会有以下行为：</p><blockquote><p>1.把ssthresh降低为cwnd值的一半<br>2.把cwnd重新设置为1<br>3.重新进入慢启动过程</p></blockquote><p><strong>快速重传算法</strong>：服务端连发3个相同的ack，客户端被动进入快速重传）其实TCP还有一种情况会进行重传：那就是收到3个相同的ACK。TCP在收到乱序到达包时就会立即发送ACK，TCP利用3个相同的ACK来判定数据包的丢失，此时进行快速重传，快速重传做的事情有：</p><blockquote><p>1.把ssthresh设置为cwnd的一半<br>2.把cwnd再设置为ssthresh的值(具体实现有些为ssthresh+3)<br>3.重新进入拥塞避免阶段。</p></blockquote><p>当发送端进入快速重传算法后，必然要回复回去原来的状态，这就是快速恢复算法了。</p><p><strong>快速恢复算法</strong>：</p><blockquote><p>1.当收到3个重复ACK时，把ssthresh设置为cwnd的一半，把cwnd设置为ssthresh的值加3，然后重传丢失的报文段，加3的原因是因为收到3个重复的ACK，表明有3个“老”的数据包离开了网络。<br>2.再收到重复的ACK时，拥塞窗口增加1。<br>3.当收到新的数据包的ACK时，把cwnd设置为第一步中的ssthresh的值。原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。</p></blockquote><p>PS这里指的新ACK指：不是导致出现快速重传的ACK，而是一个ack号更大的ACK包。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p><strong>TCP协议的内容跟实现上是有出入的。其实协议就是为了peer之间有一个通信的语言，大家在这个语言框架下进行通信。从TCP的发送端的cwnd值的变化过程看得出，TCP是一个君子协议，发送端完全可以多发送数据，不用进入重传的阶段和将cwnd的值变小。</strong></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm">http://tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm</a><br><a href="https://cs.stackexchange.com/questions/76393/tcp-connection-termination-fin-fin-ack-ack">https://cs.stackexchange.com/questions/76393/tcp-connection-termination-fin-fin-ack-ack</a><br><a href="https://www.cnblogs.com/zlingh/p/6161088.html">https://www.cnblogs.com/zlingh/p/6161088.html</a><br><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">https://en.wikipedia.org/wiki/Transmission_Control_Protocol</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> networking </tag>
            
            <tag> linux </tag>
            
            <tag> tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iptables</title>
      <link href="../2020/06/06/iptables/"/>
      <url>../2020/06/06/iptables/</url>
      
        <content type="html"><![CDATA[<h3 id="First-sight-of-iptables"><a href="#First-sight-of-iptables" class="headerlink" title="First sight of iptables"></a>First sight of iptables</h3><p>​          内核防火墙模块（或者Netfilter）提供了相关的机制去管理网络防火墙，iptables就是这样一个用户态的工具，提供了一系列的接口，使得用户可以使用内核提供的能力。 </p><p>​    举个例子，使用iptables禁用所有的端口的tcp连接，除了22端口外。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -A INPUT -p tcp --dport 22  -j ACCEPT</span><br><span class="line">iptables -t filter -A INPUT -p tcp -j DROP</span><br></pre></td></tr></table></figure><p>​    通过以上两条命令，就可以使得除了SSH连接外的，其他所有tcp连接都建立不起来，注意的是，这两条命令的实行顺序不能调转，如果先执行了<strong>iptables -t filter -A INPUT -p tcp -j DROP</strong> 会使得所有的端口，包括SSH的连接都会断掉，你的机器就永远登录不了了。SSH的端口非22的，改成对应的端口即可。</p><p>​    iptables在日常的使用中，很大一部分的功能就是开放服务的端口，除了服务的端口，其他的端口都DROP掉，另外，如果某些端口，比如SSH的22端口，只开放给一部分的机器访问，那么可以添加一条规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -A INPUT -p tcp --dport 22 -s 10.10.10.10  -j ACCEPT</span><br></pre></td></tr></table></figure><p>​    -s 指定了请求的源地址，一定要是10.10.10.10的机器才能访问22端口，其他端口不匹配这条规则。通过这样，我们可以实现一个白名单的功能，使得一部分的机器可以访问受限制的端口。至于对外提供服务的端口，设置成全开放即可。-s的地址格式可以是CIDR的格式，因此可以表达一批的IP地址。</p><p>​    为什么需要配置防火墙，限制端口被访问呢？因为<strong>最小权限原则</strong>。</p><blockquote><p>在计算机科学领域中，最小权限原则是要求计算环境中的特定抽象层的每个模块如进程、用户或者计算机程序只能访问当下所必需的信息或者资源。 赋予每一个合法动作最小的权限，就是为了保护数据以及功能避免受到错误或者恶意行为的破坏。</p></blockquote><p>​    暴露更多的接口可以对外访问，意味着有更大的机会受到恶意的工具。还有也是防止系统管理员，在服务器上误操作启动了一个服务，而这个服务并不是对外开放的，这样，如果没有限制端口的开放，这个服务就暴露出去了。</p><p>​    另外，还有一条比较特殊的规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -I INPUT  -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br></pre></td></tr></table></figure><p>​    这条规则指定了两个状态，ESTABLISHED和RELATED，其中ESTABLISHED状态指定的是，如果是由服务器（本机器）本身发起的连接，那么对端其他端口发过来的请求就可以接受，因为是ESTABLISHED的状态。另外RELATED的状态指的是，在一个已经正常建立连接基础上新建的连接，也是开放对应的端口。下面详细解释一下这两种状态：</p><pre><code> 1. ESTABLISHED： 简单粗暴一点的解释是，如果是由服务器本身发起的连接，后面对端发过来的Packet都会认为是ESTABLISHED状态。对于应用层来说，就是服务器发起的连接，能够正常使用，INPUT链不需要再额外的设置。服务器发起请求的时候，在OUTPUT链出去的时候，会记录这个流的转态为NEW，那么对端返回数据包的时候能，发现状态之前是NEW，那么收到对端的时候后，认为这个流的状态就是ESATBLISHED的了。 2. RELATED： 具体实现的细节我并没有深究。FTP的场景就是这样，一个数据通道一个控制通道。FTP首先建立的是控制通道的连接，那么在传输文件的时候，会建立一条数据通道的连接。那么这条数据通道的连接就会被标记为RELATED。</code></pre><h3 id="iptables的三表五链"><a href="#iptables的三表五链" class="headerlink" title="iptables的三表五链"></a>iptables的三表五链</h3><h4 id="netfilter提供的hook"><a href="#netfilter提供的hook" class="headerlink" title="netfilter提供的hook"></a>netfilter提供的hook</h4><p>​    iptables其实是利用了内核提供的钩子，iptables通过往这些钩子中注册这些规则进去，来实现对数据流的操作。iptables就是通过检查每个数据包，看这些数据包符合了哪些规则，要是数据包匹配到了规则，就会执行指定的动作，常见的动作就是：DROP和ACCEPT。如果某一条DROP的规则，描述的是443端口的数据都DROP掉，那么443端口的连接就建立不起来。当然，出了DROP和ACCEPT还有其他的动作，后面再详述。</p><p>​    常说iptables有三表五链，其实iptables一共有五个表，常用的是三个，分别为：filter， nat，raw。还有两个表是：mangle 和 security。</p><p>​    在说五链之前，先说一下内核实现iptables功能的机制。内核的Netfilter模块提供了一个框架去跟内核的网络栈交互，一个数据包从网卡进来到网卡出去的整个生命周期。Netfilter提供了五个hook，使得用户层可以实现的数据包的控制。</p><p>五个hook分别是（懒得翻译了=.=）：</p><ul><li><code>NF_IP_PRE_ROUTING</code>: This hook will be triggered by any incoming traffic very soon after entering the network stack. This hook is processed before any routing decisions have been made regarding where to send the packet.</li><li><code>NF_IP_LOCAL_IN</code>: This hook is triggered after an incoming packet has been routed if the packet is destined for the local system.</li><li><code>NF_IP_FORWARD</code>: This hook is triggered after an incoming packet has been routed if the packet is to be forwarded to another host.</li><li><code>NF_IP_LOCAL_OUT</code>: This hook is triggered by any locally created outbound traffic as soon it hits the network stack.</li><li><code>NF_IP_POST_ROUTING</code>: This hook is triggered by any outgoing or forwarded traffic after routing has taken place and just before being put out on the wire.</li></ul><h4 id="五链"><a href="#五链" class="headerlink" title="五链"></a>五链</h4><p>​    五链其实就是对应内核模块netfilter提供的五个hook：</p><ul><li><code>PREROUTING</code>: Triggered by the <code>NF_IP_PRE_ROUTING</code> hook.</li><li><code>INPUT</code>: Triggered by the <code>NF_IP_LOCAL_IN</code> hook.</li><li><code>FORWARD</code>: Triggered by the <code>NF_IP_FORWARD</code> hook.</li><li><code>OUTPUT</code>: Triggered by the <code>NF_IP_LOCAL_OUT</code> hook.</li><li><code>POSTROUTING</code>: Triggered by the <code>NF_IP_POST_ROUTING</code> hook.</li></ul><p>​    iptables最小的管理单元就是一条规则，每个hook上面都可以注册很多的规则。一个数据包，从网卡进入到从网卡出去，在整个的生命周期中，会触发这五个hook（理论上是会触发，除非在前面的hook的某个规则DROP掉或者标记了后面不再做检查）都会被触发。整个数据的生命周期流程如下图：</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190609174841.png"></p><p>​                        </p><p>也就是说，PREROUTING上的规则会先于INPUT执行。链的执行顺序是：PREROUTING &gt; INPUT &gt; FORWARD &gt; OUTPUT &gt; POSTROUTING。 那么我们的表有什么用了，既然规则是绑定到hook上去了，那么好像表没有什么用了。其实表在实现上，只是为了方便规则的管理，还有也是将不同的规则分类，方便用户去查看不同的表。不同的表主要的功能是不一样的。比如filter表，主要是为了过滤数据包，禁止不允许的数据进入到内核；nat表就是对数据包的源地址和目的地址进行转换。将不同的业务逻辑，不同的功能的规则，放在不同的表上，方便管理。我认为这是表设计的初衷（最新内核的nftable已经开放了多个自定义的表的功能了，先挖坑，后面再写一遍关于nftable的文章）。</p><p><strong>既然hook有执行顺序，那么表有执行的顺序吗？</strong></p><p>答案是有的，表（表的执行顺序从上到下）和链（链的执行的顺序从左到右）如下图所示，同一张表并且同一条链中的执行顺序，则看规则的排列顺序了：</p><table><thead><tr><th>Tables↓/Chains→</th><th>PREROUTING</th><th>INPUT</th><th>FORWARD</th><th>OUTPUT</th><th>POSTROUTING</th></tr></thead><tbody><tr><td>(routing decision)</td><td></td><td></td><td></td><td>✓</td><td></td></tr><tr><td><strong>raw</strong></td><td>✓</td><td></td><td></td><td>✓</td><td></td></tr><tr><td>(connection tracking enabled)</td><td>✓</td><td></td><td></td><td>✓</td><td></td></tr><tr><td><strong>mangle</strong></td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td><strong>nat</strong> (DNAT)</td><td>✓</td><td></td><td></td><td>✓</td><td></td></tr><tr><td>(routing decision)</td><td>✓</td><td></td><td></td><td>✓</td><td></td></tr><tr><td><strong>filter</strong></td><td></td><td>✓</td><td>✓</td><td>✓</td><td></td></tr><tr><td><strong>security</strong></td><td></td><td>✓</td><td>✓</td><td>✓</td><td></td></tr><tr><td><strong>nat</strong> (SNAT)</td><td></td><td>✓</td><td></td><td></td><td>✓</td></tr></tbody></table><p>从上面的图标可以看出来，不是所有的表都支持五个链（hook)，因此不同的功能是要划分到不同的表中去。</p><h3 id="目标-target"><a href="#目标-target" class="headerlink" title="目标 target"></a>目标 target</h3><p>规则匹配后，会有对应的目标，目标有两大类，一类是动作，另外一类就是用户自定义的链。</p><h4 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h4><p>动作有三种（这里没有列全，只列出了常用的）：</p><ol><li>权限相关：ACCEPT、DROP、DENY、 RETURN</li><li>日志相关：LOG</li><li>地址相关：SNAT、DNAT、MASQUERADE</li></ol><h5 id="第一类动作：ACCEPT、DROP、DENY、-RETURN"><a href="#第一类动作：ACCEPT、DROP、DENY、-RETURN" class="headerlink" title="第一类动作：ACCEPT、DROP、DENY、 RETURN"></a>第一类动作：ACCEPT、DROP、DENY、 RETURN</h5><p>​    表示匹配规则后，这个包要怎么处理。ACCEPT表示，这个包允许进入下一个链的判断；DROP表示直接丢包，不响应客户端；DENY表示，返回拒绝访问给客户端；RETURN在这里有两个语义，如果是在主链（五条链）上表示不再判断这条链剩下的规则，target是什么就取决于这条链的policy。链的policy是一条链默认的target，没有匹配到规则或者被RETURN的话，都是会使用默认的规则policy的;</p><h5 id="第二类动作-LOG"><a href="#第二类动作-LOG" class="headerlink" title="第二类动作: LOG"></a>第二类动作: LOG</h5><p>就是这事一条打印日志的规则，需要注意的是，打印日志的规则是需要放在其他规则的前面，否则可能打印日志的规则还没匹配到就已经被前面的规则匹配了。dmesg 可以查看相关的日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -D POSTROUTING -d 127.0.0.1  -p tcp --dport 9000 -j LOG --log-prefix &quot;REALSANT9000:&quot;</span><br></pre></td></tr></table></figure><h5 id="第三类动作就是地址的转换：SNAT、DNAT、MASQUERADE"><a href="#第三类动作就是地址的转换：SNAT、DNAT、MASQUERADE" class="headerlink" title="第三类动作就是地址的转换：SNAT、DNAT、MASQUERADE"></a>第三类动作就是地址的转换：SNAT、DNAT、MASQUERADE</h5><p>​    SNAT是对源地址和源端口的转换；DNAT是对目的端口和目的地址转换；MASQUERADE比较特殊，它是对源地址的转换，但是它是使用网卡的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat  -I PREROUTING -p tcp --dport 7777 -j DNAT --to-destination 8.8.8.8:9000</span><br><span class="line">iptables -t nat -I POSTROUTING -p tcp -d 8.8.8.8 --dport 9000  -j MASQUERADE</span><br></pre></td></tr></table></figure><p>​    这个就是DNAT和MASQUERAED匹配使用，就可以将本地7777端口收到的流量转发到8.8.8.8机器上的9000端口，另外流量转发需要打开内核转发的模块：<strong>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</strong></p><h4 id="自定义的链"><a href="#自定义的链" class="headerlink" title="自定义的链"></a>自定义的链</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT  -p tcp --dport 2003  -j DOCKER</span><br><span class="line">iptables -I DOCKER  -p tcp -s 8.8.8.8  -j ACCEPT</span><br></pre></td></tr></table></figure><p>这里有个自定义的表作为target，那么一个端口2003的数据包匹配到这条规则的时候，它的action是什么，要由DOCKER表进行判断。DOCKER表中有一条规则，表明8.8.8.8主机访问是被允许的。</p><p>创建一个自定义的链：<strong>iptables -N DOCKER</strong> </p><p>另外一个自定义链中，如果动作是RETURN则表明剩下的规则不匹配了，跟函数的返回是一样的，再交由上一层的链处理，如果上一层的链还有规则，则再计算剩下的规则，看看哪个匹配。</p><h3 id="policy"><a href="#policy" class="headerlink" title="policy"></a>policy</h3><p>一个policy引发的转发问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ables -t nat  -I PREROUTING -p tcp --dport 7777 -j DNAT --to-destination 8.8.8.8:9000</span><br><span class="line">iptables -t nat -I POSTROUTING -p tcp -d 8.8.8.8 --dport 9000  -j MASQUERADE</span><br></pre></td></tr></table></figure><p>通过上述两条命配置好转发后，发现数据也没转发到8.8.8.8主机的9000端口，仔细检查后发现，FORWARD的链没有配置任何规则，并且policy是DROP。这就是问题所在，在数据进行转发出去的时候，DROP的policy将数据包丢了，导致数据没转出去。</p><p><strong>iptables -t filter -L -nv</strong> 查看FORWARD链的规则：</p><blockquote><p>Chain FORWARD (policy DROP 10 packets, 520 bytes)</p></blockquote><p>表示默认的动作是DROP（后面的是这条链的计数器，10个包，520个字节）</p><p>通过修改policy或者添加一个FORWARD的规则就可以了：<strong>iptables -t filter -P FORWARD ACCEPT</strong></p><h3 id="常用的命令行"><a href="#常用的命令行" class="headerlink" title="常用的命令行"></a>常用的命令行</h3><ul><li>表计数器的清空：iptables -t nat -Z</li><li>查看nat表： iptables -t nat -L -nv</li><li>查看filter表：iptables -t filter -L -nv</li><li>清空nat表的规则：iptables -F nat</li><li>查看filter表的INPUT链：iptables -t filter -L INPUT -nv</li><li>保存当前系统的iptables配置： iptables-save</li><li>应用一份iptables的配置文件: iptables-restore configFileName</li></ul><h4 id="raw表的使用"><a href="#raw表的使用" class="headerlink" title="raw表的使用"></a>raw表的使用</h4><p>​    raw表的规则作为最新匹配的规则，利用raw表，我们可以解决一部分的iptables性能问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t raw -A PREROUTING -p tcp --dport 80 -j NOTRACK</span><br><span class="line">iptables -A FORWARD -m state --state UNTRACKED -j ACCEPT</span><br></pre></td></tr></table></figure><p>比如转发到本地的WEB端口80的流量，标记为NOTRACK。</p><p>raw表中包含PREROUTING链和OUTPUT链，优先级最高，可以对数据包在进入NAT表的PREROUTING链之前对消息进行处理。当用户启用了RAW表，消息在经过RAW表的PREROUTING链处理后，将跳过NAT表和ip_conntrack处理，不再做地址转换和数据包的链接跟踪处理。所以raw表可以用在那些不需要做nat和链接跟踪的情况，提升系统性能。因为启用链接跟踪时，系统会建立一个链接跟踪表，每个消息进来时，都会去查询链接跟踪表，当系统业务量过大时，可能会引发系统CPU消耗过高。</p><h3 id="iptables的问题"><a href="#iptables的问题" class="headerlink" title="iptables的问题"></a>iptables的问题</h3><ol><li><p>iptables每次从新应用restore配置文件，首先是先flush掉所有的表，再配置规则。那么这样就存在一个中间态，这个系统是没有任何保护的。</p></li><li><p>iptables的性能问题，规则数的数量多了之后，就会存在性能问题。</p><p>因为，最新的内核推出了nftable代替iptables，志在解决上述的问题。</p></li></ol><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><a href="https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture">https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture</a></p><p><a href="https://www.linuxtopia.org/Linux_Firewall_iptables/c1265.html">https://www.linuxtopia.org/Linux_Firewall_iptables/c1265.html</a></p><p><a href="https://www.frozentux.net/iptables-tutorial/chunkyhtml/x4193.html">https://www.frozentux.net/iptables-tutorial/chunkyhtml/x4193.html</a></p><p><a href="https://www.jianshu.com/p/5f38e7253fc8">https://www.jianshu.com/p/5f38e7253fc8</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> networking </tag>
            
            <tag> tool </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="about/index.html"/>
      <url>about/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="categories/index.html"/>
      <url>categories/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>search</title>
      <link href="search/index.html"/>
      <url>search/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="tags/index.html"/>
      <url>tags/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
    </entry>
    
    
  
</search>
