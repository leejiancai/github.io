<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Envoy运行时Runtime配置</title>
      <link href="../2021/03/05/Envoy%E8%BF%90%E8%A1%8C%E6%97%B6Runtime%E9%85%8D%E7%BD%AE/"/>
      <url>../2021/03/05/Envoy%E8%BF%90%E8%A1%8C%E6%97%B6Runtime%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="1-运行时是什么"><a href="#1-运行时是什么" class="headerlink" title="1. 运行时是什么"></a>1. 运行时是什么</h2><p> 所谓的运行时，就是在Envoy在运行时候，通过某些手段修改一些配置，达到影响Envoy运行逻辑的目的的手段。xDS也可以认为是一种运行时配置管理，Envoy支持多个运行时配置方式。</p><p>  在旧版本的Envoy中，是config.bootstrap.v3.Runtime。在最新版的Envoy中，是采用的是config.bootstrap.v3.LayeredRuntime。 layeredRuntime与docker镜像的文件系统类似，上一层的文件会覆盖掉底层的文件（如果有），这样就可以实现灵活的运行时配置了。</p><p>典型的LayeredRuntime配置是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">layers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">static_layer_0</span></span><br><span class="line">  <span class="attr">static_layer:</span></span><br><span class="line">    <span class="attr">health_check:</span></span><br><span class="line">      <span class="attr">min_interval:</span> <span class="number">5</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">disk_layer_0</span></span><br><span class="line">  <span class="attr">disk_layer:</span> &#123; <span class="attr">symlink_root:</span> <span class="string">/srv/runtime/current</span>, <span class="attr">subdirectory:</span> <span class="string">envoy</span> &#125;</span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">disk_layer_1</span></span><br><span class="line">  <span class="attr">disk_layer:</span> &#123; <span class="attr">symlink_root:</span> <span class="string">/srv/runtime/current</span>, <span class="attr">subdirectory:</span> <span class="string">envoy_override</span>, <span class="attr">append_service_cluster:</span> <span class="literal">true</span> &#125;</span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">admin_layer_0</span></span><br><span class="line">    <span class="attr">admin_layer:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>LayeredRuntime可以配置多个layers，layer的类型是RuntimeLayer，目前支持四种类型的RuntimeLayer：</p><ul><li>static_layer,     一般都是放置在最底层（0层），用于设置默认的配置。</li><li>disk_layer,     这个是读取本地文件系统的。一般目录是一个链接目录（一个树状结构的目录）。这样，目录下的所有文件都可以通过链接文件重新指向别的目录，达到配置动态修改的目的。</li><li>admin_layer:     这一层是通过Envoy的管理API进行修改的，可以实现Admin动态修改Envoy的配置的目的</li><li>rtds_layer:     rtds是xDS协议的一部分，这样Envoy就可以实现订阅xDS服务器分发的配置，达到配置全局分发管理的效果。</li></ul><p>可以看出，通过上述的四种RuntimeLayer的使用，可以实现一个既配置简单（放在static_layer或disk_layer,作为系统最通用的配置），然后通过admin_layer或rtds_layer实现灵活的修改（而且是可以通过配置管理中心的工具实现）。</p><h2 id="2-典型应用场景"><a href="#2-典型应用场景" class="headerlink" title="2. 典型应用场景"></a>2. 典型应用场景</h2><p>用于Envoy的废弃特性（功能）的循序渐进的废弃的功能。Envoy中，废弃一个功能的时候，分如下的阶段：</p><ul><li><p>阶段1-warn-by-default,：在日志中输出警告日志，警告用户尽早使用其他的特性实现当前的需求</p></li><li><p>阶段2-fail-by-default：     如果配置文件中，使用了某个特性的配置，配置文件校验阶段就会拒绝，但是可以通过一个Runtime配置来继续使用将要废弃的特性的目的（此时代码还没移除）。下面例子中，可以看到hidden_envoy_deprecated_use_original_dst设置为true，use_original_dst的功能就启用了。</p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">&quot;layered_runtime&quot;</span>:&#123;</span><br><span class="line">   <span class="attr">&quot;layers&quot;</span>:[</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;deprecation&quot;</span>,</span><br><span class="line">       <span class="attr">&quot;static_layer&quot;</span>:&#123;</span><br><span class="line">         <span class="attr">&quot;envoy.deprecated_features:envoy.config.listener.v3.Listener.hidden_envoy_deprecated_use_original_dst&quot;</span>:<span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;admin&quot;</span>,</span><br><span class="line">       <span class="attr">&quot;admin_layer&quot;</span>:&#123;</span><br><span class="line">         </span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>阶段3-code removal：     代码移除了，这个功能已经真正废弃掉了。</p></li></ul><p>可以看到，经过前面两个阶段，各个版本升级之间，需要用于尽早迁移到新的特性上，满足使用需求。</p><h2 id="3-重点说一下DiskLayer"><a href="#3-重点说一下DiskLayer" class="headerlink" title="3. 重点说一下DiskLayer"></a>3. 重点说一下DiskLayer</h2><p>DiskLayer的配置参数如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> <span class="attr">&quot;symlink_root&quot;</span>: <span class="string">&quot;...&quot;</span>,</span><br><span class="line"></span><br><span class="line"> <span class="attr">&quot;subdirectory&quot;</span>: <span class="string">&quot;...&quot;</span>,</span><br><span class="line"></span><br><span class="line"> <span class="attr">&quot;append_service_cluster&quot;</span>: <span class="string">&quot;...&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>symlink_root     一般是执行一个链接目录，运行时的配置是由symlink_root+subdirectory指定的</li><li>subdirectory：     举个例子。subdirectory为zone1，symlink_root为/envoy/runtime/current,     那么参数health_check.min_interval的参数是在目录/envoy/runtime/current/zone1/health_check/min_interval中。symlink_root     可以作为一个全局的配置中心，每个subdirectory可以作为不同的区域（或机房或AZ）的一个配置。</li><li>append_service_cluster可以取true或false。subdirectory为zone1，symlink_root为/envoy/runtime/current,如果append_service_cluster是true，那么参数health_check.min_interval首先去目录/envoy/runtime/current/zone1/${cluster}/health_check/min_interval获取，如果这个文件不存在。再去/envoy/runtime/current/zone1/health_check/min_interval文件中获取。${cluster}的值是启动Envoy时候的参数–service-cluster指定的。</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Envoy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Istio挂载remote的wasm代码</title>
      <link href="../2021/03/05/Istio%E6%8C%82%E8%BD%BDremote%E7%9A%84wasm%E4%BB%A3%E7%A0%81/"/>
      <url>../2021/03/05/Istio%E6%8C%82%E8%BD%BDremote%E7%9A%84wasm%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>WebAssembly简称WASM，是Envoy扩展功能的一种机制，可以使得用户可以灵活实现需求。WASM支持多种开发语言开发，并且其性能接近原生的Envoy C++的代码，因此其灵活性和性能都是相当好的。与Envoy的lua扩展相比，WASM需要编译，在运维和操作灵活性上比lua脚本差一点，但是其扩展能力更强，并且支持多语言开发。lua的语言开发，第三方库较少。</p><h2 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2. Hello  World"></a>2. Hello  World</h2><p>Envoy的源码examples中，有一个关于wasm的demo，我们使用其作为一个Demo演示一下如何编译wasm，并且将wasm注入到已经在运行的Istio集群的Ingressgateway网关中。</p><ul><li><p>代码路径：examples/wasm-cc    </p></li><li><p>编译工具：当然是Envoy标准的Bazel</p></li><li><p>编译命令： bazel build     //examples/wasm-cc:envoy_filter_http_wasm_example.wasm</p></li><li><ul><li>这里注意，bazel在编译中，会cache很多工具到~/cache/bazel目录下，如果当前目录空间不足，需要在有充足空间的磁盘上建一个目录，然后把～/.cache/bazel软连接到新的目录中，保证编译过程中不会出现空间不足的问题。ln -s      /home/bazel_cache/bazel/ /root/.cache/bazel</li></ul></li><li><p>编译成功后的wasm文件在目录bazel-bin/examples/wasm-cc/下,文件名为envoy_filter_http_wasm_example.wasm</p></li><li><p>切换到目录bazel-bin/examples/wasm-cc/下，运行一个http server（用于后面Envoy到这里拉取wasm文件，在生产环境中需要自己部署好这些服务，并且做好维护和升级的工作）：python3 -m     http.server</p></li><li><p>使用EnvoyFilter为Istio集群的istio-system命令空间下的Ingressgateway注入一个wasm配置</p></li><li><ul><li>检查当前Ingressgateway的入口端口是什么，在v1.8.2版本中默认是8080端口，所以使用EnvoyFilter注入的时候，选择8080端口就可以了。</li></ul></li><li><p>部署好Istio官方提供的Bookinfo例子（需要在网关入口暴露productpage服务）</p></li><li><p>编写EnvoyFilter的配置文件</p></li><li><p>apply     配置文件：kubectl -n istio-system apply -f wasm_envoyfilter.yaml</p></li><li><p>检查一下wasm文件配置时候生效：</p><blockquote><p>➜** <strong>istio curl</strong> <a href="http://192.168.99.102:31318/productpage"><strong>http://192.168.99.102:31318/productpage</strong></a> <strong>-v 2&gt;&amp;1 |rg “FOO|Hello”</strong></p><p><strong>&lt; x-wasm-custom: FOO</strong></p><p>*<em>Hello, world\</em> Closing connection 0</p></blockquote></li></ul><p> <strong>可以看到**</strong>，wasm已经生效了。因为Demo就是往response中添加一个x**<strong>-wasm-custom头部和在body中添加 Hello, world</strong></p><ul><li><p><strong>总结和重点</strong>: </p></li><li><ul><li><p><strong>wasm的文件最好通过remote模式获取到，因为local的模式还要把wasm文件挂载到容器中，对容器的配置有侵入。而且放置在一个remote的文件存储管理平台，提供HTTP服务，有利于中心化管理和分发我们的wasm文件，后续可以扩展成一个repo，提供各种定制或通用的功能</strong></p></li><li><p><strong>使用remote模式挂载wasm文件，需要自定义一个Cluster，然后被wasm的remote配置引用。</strong></p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210305155415-20210305155503329.png"></p></li><li><p><strong>remote**</strong>模式引用**<strong>wasm**</strong>文件的方式是**</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210305155525.png"></p></li></ul></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Envoy源码分析-Stats功能</title>
      <link href="../2021/03/04/Envoy%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Stats%E5%8A%9F%E8%83%BD/"/>
      <url>../2021/03/04/Envoy%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Stats%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="1-Envoy中支持的Metric类型"><a href="#1-Envoy中支持的Metric类型" class="headerlink" title="1.  Envoy中支持的Metric类型"></a>1.  Envoy中支持的Metric类型</h2><p>Envoy中Stats的类型（Metric的类型）有四种</p><ul><li>Counter</li><li>Gauge</li><li>Histogram</li><li>TextReadOut</li></ul><p>观察接口curl 127.0.0.1:15000/stats返回的数据，可以看上述四种Metric的输出有：</p><table><thead><tr><th>类型</th><th>例子</th></tr></thead><tbody><tr><td>Counter</td><td>cluster.xds-grpc.assignment_timeout_received:  0</td></tr><tr><td>Gauge</td><td>cluster_manager.active_clusters:  30</td></tr><tr><td>Histogram</td><td>server.initialization_time_ms:  P0(nan,760.0) P25(nan,762.5) P50(nan,765.0) P75(nan,767.5) P90(nan,769.0)  P95(nan,769.5) P99(nan,769.9) P99.5(nan,769.95) P99.9(nan,769.99)  P100(nan,770.0)</td></tr><tr><td>TextReadOut</td><td>listener_manager.lds.version_text:  “2021-02-03T07:17:30Z/11”</td></tr></tbody></table><h2 id="2-如何触发Stats的输出和代码入口"><a href="#2-如何触发Stats的输出和代码入口" class="headerlink" title="2.  如何触发Stats的输出和代码入口"></a>2.  如何触发Stats的输出和代码入口</h2><p>首先看一下Stats的输出入口是: Http::Code StatsHandler::handlerStats(), 会获取所有counters，然后输出到all_stats中，在HTTP的响应中返回给客户端。入口的代码中，就会去读取当前的统计数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Http::Code <span class="title">StatsHandler::handlerStats</span><span class="params">(absl::string_view url,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Http::ResponseHeaderMap&amp; response_headers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Buffer::Instance&amp; response, AdminStream&amp; admin_stream)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">uint64_t</span>&gt; all_stats;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">const</span> Stats::CounterSharedPtr&amp; counter : server_.stats().counters()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldShowMetric(*counter, used_only, regex)) &#123;</span><br><span class="line">              all_stats.emplace(counter-&gt;name(), counter-&gt;value());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发handleStats()的方法是：进入Envoy执行的容器，执行 curl 127.0.0.1:15000/stats。触发后的调用栈截图如下：</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210304170557.png"></p><h2 id="3-Envoy进程内唯一一个ThreadLocalStoreImpl-对象"><a href="#3-Envoy进程内唯一一个ThreadLocalStoreImpl-对象" class="headerlink" title="3. Envoy进程内唯一一个ThreadLocalStoreImpl 对象"></a>3. Envoy进程内唯一一个ThreadLocalStoreImpl 对象</h2><p>由于Envoy是一个主线程（main thread）和多个工作线程（worker thread）的架构，因此需要一个全局的Store去管理所有的Metric。比如计数器cluster.xds-grpc.assignment_timeout_received，这个是全局唯一的（所有线程共享一个实例），但是这个计数器在每个线程都有一个索引表引用着它，这样每个线程在查询索引表拿到这个计数器的实例时候，就不需要进行加锁了。并且每个技术其对象内部的value都是原子对象（atomic），这样每个线程使用同一个技术器的时候也不会存在问题。ThreadLocalStoreImpl 对象存储的是一些全局的统计信息，但是listenre、host这些统计信息，不是放在这里的。</p><p>基本的架构图：</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210304170715.png"></p><p>下面以Counter这种类型的Metric展示Envoy内部的一些机制：</p><ul><li><p>所有工作线程引用的其实是同一个计数器对象（如果计数器的名字相同）。</p></li><li><p>计数器内部的value是原子变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterImpl</span> :</span> <span class="keyword">public</span> StatsSharedImpl&lt;Counter&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">uint64_t</span>&gt; value_&#123;<span class="number">0</span>&#125;;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>ThreadLocalStore 中有一个所有计数器对象的索引，所以在输出Stats的时候，就可以拿到所有的计数器对象了。准确来说是放在了哈希表scope_中去（absl::flat_hash_set&lt;ScopeImpl*&gt; scopes_ ABSL_GUARDED_BY(lock_);）。上层需要拿到所有的counter的时候，就调用counters()方法即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CounterSharedPtr&gt; <span class="title">ThreadLocalStoreImpl::counters</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Handle de-dup due to overlapping scopes.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CounterSharedPtr&gt; ret;</span><br><span class="line">  StatNameHashSet names;</span><br><span class="line">  <span class="function">Thread::LockGuard <span class="title">lock</span><span class="params">(lock_)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (ScopeImpl* scope : scopes_) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; counter : scope-&gt;central_cache_-&gt;counters_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (names.insert(counter.first).second) &#123;</span><br><span class="line">        ret.push_back(counter.second);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>TlsCache 和 CentralCacheEntry： TlsCahe是每个线程都有的索引表，弄这个索引表的目的是为了减少多个线程间的竞争。CentralCacheEntry是全局的索引表（用于在线程索引表中找不到的时候，再去全局索引表中获取）。下面举一个动态获取counter对象的例子，就可以看出来线程索引表和全局索引表的作用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">Counter&amp; ThreadLocalStoreImpl::ScopeImpl::counterFromStatNameWithTags(</span><br><span class="line">    <span class="keyword">const</span> StatName&amp; name, StatNameTagVectorOptConstRef stat_name_tags) &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  <span class="function">TagUtility::TagStatNameJoiner <span class="title">joiner</span><span class="params">(prefix_.statName(), name, stat_name_tags, symbolTable())</span></span>;</span><br><span class="line">  Stats::StatName final_stat_name = joiner.nameWithTags();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// We now find the TLS cache. This might remain null if we don&#x27;t have TLS</span></span><br><span class="line">  <span class="comment">// initialized currently.</span></span><br><span class="line">  StatRefMap&lt;Counter&gt;* tls_cache = <span class="literal">nullptr</span>;</span><br><span class="line">  StatNameHashSet* tls_rejected_stats = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (!parent_.shutting_down_ &amp;&amp; parent_.tls_) &#123;</span><br><span class="line">    TlsCacheEntry&amp; entry = parent_.tls_-&gt;getTyped&lt;TlsCache&gt;().insertScope(<span class="keyword">this</span>-&gt;scope_id_);</span><br><span class="line">    tls_cache = &amp;entry.counters_;</span><br><span class="line">    tls_rejected_stats = &amp;entry.rejected_stats_;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> safeMakeStat&lt;Counter&gt;(</span><br><span class="line">      final_stat_name, joiner.tagExtractedName(), stat_name_tags, central_cache_-&gt;counters_,</span><br><span class="line">      central_cache_-&gt;rejected_stats_,</span><br><span class="line">      [](Allocator&amp; allocator, StatName name, StatName tag_extracted_name,</span><br><span class="line">         <span class="keyword">const</span> StatNameTagVector&amp; tags) -&gt; CounterSharedPtr &#123;</span><br><span class="line">        <span class="keyword">return</span> allocator.makeCounter(name, tag_extracted_name, tags);</span><br><span class="line">      &#125;,</span><br><span class="line">      tls_cache, tls_rejected_stats, parent_.null_counter_);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">StatType</span>&gt;</span></span><br><span class="line">StatType&amp; ThreadLocalStoreImpl::ScopeImpl::safeMakeStat(</span><br><span class="line">    StatName full_stat_name, StatName name_no_tags,</span><br><span class="line">    <span class="keyword">const</span> absl::optional&lt;StatNameTagVector&gt;&amp; stat_name_tags,</span><br><span class="line">    StatNameHashMap&lt;RefcountPtr&lt;StatType&gt;&gt;&amp; central_cache_map,</span><br><span class="line">    StatNameStorageSet&amp; central_rejected_stats, MakeStatFn&lt;StatType&gt; make_stat,</span><br><span class="line">    StatRefMap&lt;StatType&gt;* tls_cache, StatNameHashSet* tls_rejected_stats, StatType&amp; null_stat) &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (tls_rejected_stats != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">      tls_rejected_stats-&gt;find(full_stat_name) != tls_rejected_stats-&gt;end()) &#123;</span><br><span class="line">    <span class="keyword">return</span> null_stat;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// If we have a valid cache entry, return it.</span></span><br><span class="line">  <span class="keyword">if</span> (tls_cache) &#123;</span><br><span class="line">    <span class="keyword">auto</span> pos = tls_cache-&gt;find(full_stat_name);</span><br><span class="line">    <span class="keyword">if</span> (pos != tls_cache-&gt;end()) &#123;</span><br><span class="line">      <span class="keyword">return</span> pos-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// We must now look in the central store so we must be locked. We grab a reference to the</span></span><br><span class="line">  <span class="comment">// central store location. It might contain nothing. In this case, we allocate a new stat.</span></span><br><span class="line">  <span class="function">Thread::LockGuard <span class="title">lock</span><span class="params">(parent_.lock_)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> iter = central_cache_map.find(full_stat_name);</span><br><span class="line">  RefcountPtr&lt;StatType&gt;* central_ref = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (iter != central_cache_map.end()) &#123;</span><br><span class="line">    central_ref = &amp;(iter-&gt;second);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent_.checkAndRememberRejection(full_stat_name, central_rejected_stats,</span><br><span class="line">                                               tls_rejected_stats)) &#123;</span><br><span class="line">    <span class="keyword">return</span> null_stat;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    StatNameTagHelper tag_helper(parent_, name_no_tags, stat_name_tags);</span><br><span class="line"> </span><br><span class="line">    RefcountPtr&lt;StatType&gt; stat = make_stat(</span><br><span class="line">        parent_.alloc_, full_stat_name, tag_helper.tagExtractedName(), tag_helper.statNameTags());</span><br><span class="line">    ASSERT(stat != <span class="literal">nullptr</span>);</span><br><span class="line">    central_ref = &amp;central_cache_map[stat-&gt;statName()];</span><br><span class="line">    *central_ref = stat;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// If we have a TLS cache, insert the stat.</span></span><br><span class="line">  StatType&amp; ret = **central_ref;</span><br><span class="line">  <span class="keyword">if</span> (tls_cache) &#123;</span><br><span class="line">    tls_cache-&gt;insert(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(ret.statName(), <span class="built_in">std</span>::reference_wrapper&lt;StatType&gt;(ret)));</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Finally we return the reference.</span></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li></ul><h2 id="4-cluster、host级别的Stats"><a href="#4-cluster、host级别的Stats" class="headerlink" title="4. cluster、host级别的Stats"></a>4. cluster、host级别的Stats</h2><p>  可以看到Listener的计数器是对象构造的时候就构造获取到的（也是从从一个scope中获取）</p><p>   Listener的构造函数:</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ConnectionHandlerImpl::ActiveListenerImplBase::ActiveListenerImplBase(</span><br><span class="line">    Network::ConnectionHandler&amp; parent, Network::ListenerConfig* config)</span><br><span class="line">    : stats_(&#123;ALL_LISTENER_STATS(POOL_COUNTER(config-&gt;listenerScope()),</span><br><span class="line">                                 POOL_GAUGE(config-&gt;listenerScope()),</span><br><span class="line">                                 POOL_HISTOGRAM(config-&gt;listenerScope()))&#125;),</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  以其中的POOL_COUNTER为例子。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_COUNTER(POOL) POOL_COUNTER_PREFIX(POOL, <span class="meta-string">&quot;&quot;</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_COUNTER_PREFIX(POOL, PREFIX) (POOL).counterFromString(Envoy::statPrefixJoin(PREFIX, FINISH_STAT_DECL_</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALL_LISTENER_STATS(COUNTER, GAUGE, HISTOGRAM)                                              \</span></span><br><span class="line">  COUNTER(downstream_cx_destroy)                                                                   \</span><br><span class="line">  COUNTER(downstream_cx_overflow)                                                                  \</span><br><span class="line">  COUNTER(downstream_cx_total)                                                                     \</span><br><span class="line">  COUNTER(downstream_global_cx_overflow)                                                           \</span><br><span class="line">  COUNTER(downstream_pre_cx_timeout)                                                               \</span><br><span class="line">  COUNTER(no_filter_chain_match)                                                                   \</span><br><span class="line">  GAUGE(downstream_cx_active, Accumulate)                                                          \</span><br><span class="line">  GAUGE(downstream_pre_cx_active, Accumulate)                                                      \</span><br><span class="line">  HISTOGRAM(downstream_cx_length_ms, Milliseconds)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListenerStats</span> &#123;</span></span><br><span class="line">  ALL_LISTENER_STATS(GENERATE_COUNTER_STRUCT, GENERATE_GAUGE_STRUCT, GENERATE_HISTOGRAM_STRUCT)</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GENERATE_COUNTER_STRUCT(NAME) Envoy::Stats::Counter&amp; NAME##_;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  获取Listners的统计信息入口有：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;/clusters&quot;</span>, <span class="string">&quot;upstream cluster status&quot;</span>,</span><br><span class="line">           MAKE_ADMIN_HANDLER(clusters_handler_.handlerClusters), <span class="literal">false</span>, <span class="literal">false</span>&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Envoy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grpcurl工具的使用</title>
      <link href="../2021/03/03/grpcurl%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>../2021/03/03/grpcurl%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><p>首先下载个gRPC使用的example，先不必纠结gRPC的语法。</p><ul><li>下载：<code>git clone -b v1.35.0 https://github.com/grpc/grpc-go</code></li><li>切换到example: <code>cd grpc-go/examples/route_guide</code></li><li>启动server端：<code>go run server/server.go</code></li></ul><p>执行上述的步骤准备好验证环境后，我们需要下载好grpcurl这个工具，具体步骤参考<a href="https://github.com/fullstorydev/grpcurl">https://github.com/fullstorydev/grpcurl</a></p><p>由于example的server没有提供service反射的功能，因此我们在使用grpcurl这个工具的时候，还需要拿到原始的proto文件。</p><p>grpcurl常规操作：</p><ul><li><p>list当前的server有哪些服务(根据proto文件)：<code>grpcurl -proto ./routeguide/route_guide.proto  list</code></p><blockquote><p>~/code/github/grpc-go/examples/route_guide$ grpcurl -proto ./routeguide/route_guide.proto  list<br>routeguide.RouteGuide</p></blockquote></li><li><p>list特定的服务有哪些接口：<code>grpcurl -proto ./routeguide/route_guide.proto  list  routeguide.RouteGuide</code></p><blockquote><p>~/code/github/grpc-go/examples/route_guide$ grpcurl -proto ./routeguide/route_guide.proto  list  routeguide.RouteGuide<br>routeguide.RouteGuide.GetFeature<br>routeguide.RouteGuide.ListFeatures<br>routeguide.RouteGuide.RecordRoute<br>routeguide.RouteGuide.RouteChat</p></blockquote></li><li><p>使用plain（不加密）的方式访问server的一个接口：<code>grpcurl -proto ./routeguide/route_guide.proto -plaintext  -d &#39;&#123;&quot;latitude&quot;: 409146138, &quot;longitude&quot;: -746188906&#125;&#39; 127.0.0.1:10000 routeguide.RouteGuide.GetFeature</code></p><blockquote><p>~/code/github/grpc-go/examples/route_guide/client$ grpcurl -proto ../routeguide/route_guide.proto -plaintext  -d ‘{“latitude”: 409146138, “longitude”: -746188906}’ 127.0.0.1:10000 routeguide.RouteGuide.GetFeature<br>{<br>  “name”: “Berkshire Valley Management Area Trail, Jefferson, NJ, USA”,<br>  “location”: {</p><pre><code>&quot;latitude&quot;: 409146138,&quot;longitude&quot;: -746188906</code></pre><p>  }<br>}</p></blockquote><p>参数说明：</p><ul><li>-d: 请求的参数</li><li>-proto： 制定proto文件的路径</li><li>-plaintext: 使用不加密的方式调用gRPC的server</li></ul></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> gRPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP的半连接和长连接队列</title>
      <link href="../2021/03/03/TCP%E7%9A%84%E5%8D%8A%E8%BF%9E%E6%8E%A5%E5%92%8C%E9%95%BF%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/"/>
      <url>../2021/03/03/TCP%E7%9A%84%E5%8D%8A%E8%BF%9E%E6%8E%A5%E5%92%8C%E9%95%BF%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="半连接队列和全连接队列"><a href="#半连接队列和全连接队列" class="headerlink" title="半连接队列和全连接队列"></a>半连接队列和全连接队列</h2><ul><li><p>半连接队列（half open queue/SYN queue）：TCP监听的端口收到SYN包后，会把当前连接（五元组）放到半连接队列进行管理。半连接队列的长度是以一个监听的端口为粒度的，半连接队列的最大容量计算公式为：<code>max(tcp_max_syn_backlog, 64)</code>,其中tcp_max_syn_backlog为系统参数。</p></li><li><p>全连接队列（accept queue）：TCP三次握手成功后（收到最后一个由Client发来的ACK），从半连接队列取出请求放到全连接队列。值得注意的是，当应用层的accept()调用返回后，连接会从全连接队列中移除。因此accept queue当前长度并不能代表已经建立好（accepted）的连接。全连接队列的容量计算公式为：<code>min(net.core.somaxconn, backlog)</code>,其中net.core.somaxconn为系统参数，backlog是TCP连接监听时候的参数，如</p><blockquote><p>int listen(int sockfd, int backlog);</p><p>reThe  backlog  argument  defines  the maximum length to which the queue of pending connections for sockfd may grow.  If a connection request arrives when the queue is full, the client may receive an error with an indication of</p><pre><code>ECONNREFUSED or, if the underlying protocol supports retransmission, the request may be ignored so that a later reattempt at connection succeeds</code></pre></blockquote></li><li><p>查看系统参数的方式：<code>sysctl -a|grep tcp_max_syn_backlog</code></p></li><li><p>队列满的表现和报错方式：</p><ul><li>半连接队列满了：<ul><li>当net.ipv4.tcp_syncookies=0时，SYN packet会被丢弃</li><li>当net.ipv4.tcp_syncookies=1时<ul><li>如果全连接队列满了,SYN会被丢弃</li><li>除上述情况外，生成SYN cookie并且返回SYN/ACK。</li></ul></li></ul></li><li>Server会丢弃当前连接， client 会收到connection time out；只要是 client 没有收到 SYN+ACK，3s 之后，client 会再次发送，如果依然没有收到，9s 之后会继续发送。</li><li>全连接队列满后，收到ACK packet：<ul><li>tcp_abort_on_overflow=1的情况：直接返回RST通知客户端，相应的收到read timeout 或者 connection reset by peer。</li><li>tcp_abort_on_overflow=0的情况：忽略收到的ACK包，继续让连接放在SYN Queue中，等到连接的定时器超时后会继续发送SYN/ACK包给客户端，客户端会继续发送ACK给服务端。重试的次数由参数net.ipv4.tcp_synack_retries决定。此外，当全连接队列满了之后，内核会限制请求放到SYN队列中的，因此新的请求发送SYN给服务端后，有可能SYN的packet会被丢弃，要依赖客户端重试发送SYN的机制。</li></ul></li></ul></li><li><p>队列的状态图：</p><p>注意的是，即使三次握手完成了，也是需要应用层调用accept()把请求从Accept Queue中取出，Accept Queue里面的连接才会减1</p></li></ul><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20210303110131397.png" alt="image-20210303110131397"></p><ul><li><p>观察方法：</p><ul><li><p>全连接队列的容量和当前的长度，通过如下方法就可以判断全连接队列是不是满了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ss -anlt |grep -E <span class="string">&quot;8080|State&quot;</span></span><br><span class="line">State      Recv-Q Send-Q Local Address:Port               Peer Address:Port</span><br><span class="line">LISTEN     3      2      127.0.0.1:8080                     *:*</span><br></pre></td></tr></table></figure><p>其中，处于LISTEN状态的Socket中，Send-Q 的值为当前Socket的Accept Queue的容量，为2；Recv-Q的值为当前Accept Queue的长度，为3。这里的Accept Queue长度比容量还大1，表明在具体实现上是有出入的。</p></li><li><p>半连接队列移除的报错信息，可以通过netstat工具查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -s|grep overflow</span><br><span class="line">    449 <span class="built_in">times</span> the listen queue of a socket overflowed</span><br></pre></td></tr></table></figure></li><li><p>补充ESTAB状态的连接的Send-Q和Recv-Q的参数含义：</p><p>Recv-Q代表还没拷贝到用户空间的数据字节数量。Send-Q代表发送到了对端，但是还没收到对端的ACK的数据字节数量。</p><blockquote><p>Recv-Q</p><p>Established: The count of bytes not copied by the user program connected to this socket.</p><p>Listening: Since Kernel 2.6.18 this column contains the current syn backlog. （Accept queue）</p><p>Send-Q</p><p>Established: The count of bytes not acknowledged by the remote host.</p><p>Listening: Since Kernel 2.6.18 this column contains the maximum size of the syn backlog.</p></blockquote></li></ul></li></ul><h2 id="如何防御SYN-FLOOD和SYN-cookie的机制"><a href="#如何防御SYN-FLOOD和SYN-cookie的机制" class="headerlink" title="如何防御SYN FLOOD和SYN cookie的机制"></a>如何防御SYN FLOOD和SYN cookie的机制</h2><ul><li>减少SYN-ACK的重发次数：<code>sysctl -w net.ipv4.tcp_synack_retries=3</code></li><li>使用SYN cookie的技术：<code>sysctl -w net.ipv4.tcp_syncookies=1</code></li><li>增加backlog队列的长度，这个需要应用listen时候调整，也需要内核参数调整：<code>sysctl -w net.ipv4.tcp_max_syn_backlog=2048</code></li><li>限制SYN的并发数，实际的数量需要视业务具体情况设置：<code>iptables -A INPUT -p tcp --syn -m limit --limit 1/s -j ACCEPT --limit 1/s</code></li></ul><p>SYN Cookie机制：SYN Cookie时对客户端透明的，只在服务端进行修改了。启动SYN Cookie后，服务端收到一个SYN请求，是不会把请求放到半连接上的，而是生成一个Cookie值作为SYN/ACK包的seq号（初始序列号）。当客户端收到SYN/ACK后，就会执行三次握手的最后一个阶段——返回ACK包，ACK包中的ack号就是服务器上一步返回给客户端的Cookie+1。当服务端收到最后一个ACK的时候，就会按照算法再次去计算Cookie值，Cookie值相等就认为是一个正常的连接。</p><p>因此，关键是cookie的计算过程，cookie的生成机制需要考虑：安全、性能、时效</p><ul><li><p>计算公式是：mac = MAC(A, key)。MAC是密码学中的一个消息认证码函数，也就是满足某种安全性质的带密钥的hash函数，它能够提供mac计算中需要的安全性。在Linux实现中，MAC函数为SHA1。SHA1既能兼顾安全和性能。注意mac还不是最后的cookie</p></li><li><p>key是一个服务器独有的密钥，是一组随机数。t是系统启动的时间，每60s加1，因此在网络环境不好的环境下，刚好跨越60s的界限的时候，有可能握手会失败。<strong>MSSIND</strong> 为**<code>MSS</code>**对应的索引。</p></li><li><p>cookie生成还需要能够把握手第一个包的TCP相关参数保存下来，因此还需要额外的机制。具体怎么做，后续再深入。</p></li></ul><h2 id="TCP参数调优"><a href="#TCP参数调优" class="headerlink" title="TCP参数调优"></a>TCP参数调优</h2><p>三个重要的参数需要调整，半连接队列容量、全连接队列容量和nf conntrack模块的流数量。建议值为：</p><blockquote><p>net.ipv4.tcp_max_syn_backlog = 8192 </p><p>net.core.somaxconn = 4096 </p><p>net.netfilter.nf_conntrack_max = 5000000</p></blockquote><p>除了TCP的参数外，还需要增加文件描述符的数量上限。具体配置不在这里展开。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++隐式和显式转换</title>
      <link href="../2021/03/03/c-%E9%9A%90%E5%BC%8F%E5%92%8C%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
      <url>../2021/03/03/c-%E9%9A%90%E5%BC%8F%E5%92%8C%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="隐式类型转换和显式类型转换。"><a href="#隐式类型转换和显式类型转换。" class="headerlink" title="隐式类型转换和显式类型转换。"></a>隐式类型转换和显式类型转换。</h2><ul><li><p>隐式类型转换（标准转换）</p><ul><li><p>算数转换——在混合类型的算术表达式中, 最宽的数据类型成为目标转换类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">10.0</span>;</span><br><span class="line"><span class="keyword">auto</span> result = <span class="number">10</span> + a; <span class="comment">//a被提升为double类型，因为double是最宽的</span></span><br></pre></td></tr></table></figure><p>转换原则：</p><ul><li><p>对于同类算术类型，如short 与 int，float 与 double，占用较小内存的类型将转换成另一类型。如 short+ int将被转换为 int + int。此种类型转换称为类型提升</p></li><li><p>整形将转为浮点型。如 int+ double 将被转换为 double + double</p></li><li><p>仅当无符号类型占用的内存小于有符号类型时，无符号类型才发生类型提升从而转为有符号类型，否则，有符号类型将转为无符号类型。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a &gt; <span class="number">-1</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (b &gt; <span class="number">-1</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出 1 0!</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>赋值转换——目标类型是被赋值对象的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> d = a; <span class="comment">//a被转换为目标的类型double</span></span><br></pre></td></tr></table></figure></li><li><p>函数调用转换——目标转换类型为形参的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123; <span class="keyword">return</span> a + <span class="number">10.0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> i = func(a); <span class="comment">//a被转换为double类型</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用函数func的时候，实参a本来是int类型的，但是形参是double类型，因此a被转换成了double类型。</p></li><li><p>函数返回转换——目标转换类型为函数的返回类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123; <span class="keyword">return</span> a + <span class="number">10.0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> i = func(a); <span class="comment">//函数func的返回值类型是int，但是a+10.0的类型本来是double的，需要转换为int类型</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>显式转换（强制转换cast）</p><ul><li><p>C风格转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> b = (<span class="keyword">double</span>)a;</span><br></pre></td></tr></table></figure></li><li><p>C++风格转换——推荐使用这种风格的转换</p><p>格式如下：<strong>XXX_cast</strong> &lt; type-id &gt; ( expression )</p><ul><li><p>static_cast</p><p>使用格式 :<code>static_cast&lt;type-id&gt;(expression)</code></p><p>static_cast是没有运行时类型检查确保转换的安全性的，需要开发人员确保转换的安全。</p><ul><li>能够隐式转换的地方，均可使用static_cast 进行转换</li><li>如果类型不兼容，使用static_cast，编译器会报错</li></ul><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  B() : m(<span class="number">10</span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello world, this is B!\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line">  <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  D() : m(<span class="number">11</span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello world, this is D!\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">double</span> d1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(a);</span><br><span class="line">  <span class="keyword">int</span> a1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(d1);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; d1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// char *pstr = &quot;Hello World&quot;;</span></span><br><span class="line">  <span class="comment">// int *pi_error = static_cast&lt;int*&gt;(pstr);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// downcast 演示</span></span><br><span class="line">  D d;</span><br><span class="line">  B&amp; br = d;</span><br><span class="line">  br.hello();</span><br><span class="line">  D&amp; dr = <span class="keyword">static_cast</span>&lt;D&amp;&gt;(br);</span><br><span class="line">  dr.hello();</span><br><span class="line">  <span class="comment">// upcast 演示</span></span><br><span class="line">  B b = <span class="keyword">static_cast</span>&lt;B&gt;(d);</span><br><span class="line">  b.hello();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">Hello world, this is B!</span><br><span class="line">Hello world, this is D!</span><br><span class="line">Hello world, this is B!</span><br></pre></td></tr></table></figure><pre><code>禁止隐式转换的话，可以使用static_cast进行强制的转换：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// A a1 = 10; //explicit禁止了隐式类型转换</span></span><br><span class="line">  <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  A a1 = <span class="keyword">static_cast</span>&lt;A&gt;(<span class="number">10</span>);  <span class="comment">// 强制转换允许</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>reinterpret_cast</p><p>使用格式：<strong>reinterpret_cast &lt;**<code>*new_type*</code>**&gt; (</strong><code>*expression*</code><strong>)</strong></p><p>reinterpret_cast相当于一个不受限版本static_cast, reinterpret_cast通常用于指针和整型的转换或者一些内存级别的操作时候。因此，这个转换是存在风险的。</p><blockquote><p>reinterpret_cast expression does not compile to any CPU instructions (except when converting between integers and pointers or on obscure architectures where pointer representation depends on its type). It is purely a compile-time directive which instructs the compiler to treat <em>expression</em> as if it had the type <em>new_type</em>.</p></blockquote></li><li><p>dynamic_cast</p><p>用于父类指针和子类指针之前的转换。如果是子类转换成父类，效果与static_cast是一样的，换言之，子类指针是可以转换成父类的。当父类指针转换为子类的指针的时候，就会做运行时的检查</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//要有一个虚函数，触发多态的机制</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  A* pa1 = <span class="keyword">new</span> B();</span><br><span class="line">  A* pa2 = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 都不能通过编译</span></span><br><span class="line">  <span class="comment">// B* pb1 = pa1;</span></span><br><span class="line">  <span class="comment">// B* pb2 = pa2;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们可以看到static_cast可以进行强制类型转换的。只要B的公开继承与A，换言之B的对象可以访问到A的</span></span><br><span class="line">  B* pb1 = <span class="keyword">static_cast</span>&lt;B*&gt;(pa1);</span><br><span class="line">  B* pb2 = <span class="keyword">static_cast</span>&lt;B*&gt;(</span><br><span class="line">      pa2);  <span class="comment">//虽然可以转换，但是这个转换是危险的。没有运行时的检查</span></span><br><span class="line"></span><br><span class="line">  B* pb11 = <span class="keyword">dynamic_cast</span>&lt;B*&gt;(pa1);</span><br><span class="line">  <span class="keyword">if</span> (pb11) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pb11 got&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 这一行会被输出的</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  B* pb22 = <span class="keyword">dynamic_cast</span>&lt;B*&gt;(pa2);</span><br><span class="line">  <span class="keyword">if</span> (pb22) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pb22 got&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 这一行是不会被输出的，因为pa2指向的对象是A</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>const_cast</p><p>使用格式：<strong>const_cast</strong><type-id> (expression)</p><p>用于修改类型的const或者volatile的属性。除了const或volatile的修饰符外，type-id和expression的类型是必须一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span>* b = &amp;a;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;old value is &quot;</span> &lt;&lt; *b &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出20</span></span><br><span class="line">  <span class="keyword">int</span>* c = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(b);</span><br><span class="line">  *c = <span class="number">40</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;new value is &quot;</span> &lt;&lt; *b &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出40</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a is &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出20</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const_cast后生成的对象与原来的是不一样的。因此最后a的值是没有变化的。</p></li></ul></li></ul></li></ul><h2 id="编译器默认类型检查"><a href="#编译器默认类型检查" class="headerlink" title="编译器默认类型检查"></a>编译器默认类型检查</h2><p>编译器默认会对类型转换进行检查，包括隐式转换和static_cast的转换。不能通过编译检查的情况有：</p><ul><li>父类的对象的指针绑定到子类上</li><li>基本数据类型的指针之前的转换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> A &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  A* pa = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// B* pb = pa; 这个会编译出错的，子类的指针不能指向父类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// B* pb = static_cast&lt;B*&gt;(pa);</span></span><br><span class="line">  <span class="comment">// 这个也会编译出错。这里static_cast不能强制转换的原因是：B的实例不能访问到A的实例的成员。因为B不是public继承于A的。这跟C++的对象内存模型是有关系的，具体不展开讲</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// reinterpret_cast是不会做类型检查的，需要开发人员自己保证</span></span><br><span class="line">  B* pb = <span class="keyword">reinterpret_cast</span>&lt;B*&gt;(pa);</span><br><span class="line">  <span class="keyword">delete</span> pa;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> *ptr = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">  <span class="comment">//int *pint = ptr; 类型不同，编译出错</span></span><br><span class="line">  <span class="comment">//int *pint = static_cast&lt;int*&gt;(ptr);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  A* pa1 = <span class="keyword">new</span> B();</span><br><span class="line">  A* pa2 = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 都不能通过编译</span></span><br><span class="line">  <span class="comment">// B* pb1 = pa1;</span></span><br><span class="line">  <span class="comment">// B* pb2 = pa2;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们可以看到static_cast可以进行强制类型转换的。只要B的公开继承与A，换言之B的对象可以访问到A的</span></span><br><span class="line">  B* pb1 = <span class="keyword">static_cast</span>&lt;B*&gt;(pa1);</span><br><span class="line">  B* pb2 = <span class="keyword">static_cast</span>&lt;B*&gt;(pa2); <span class="comment">//虽然可以转换，但是这个转换是危险的。没有运行时的检查</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 下面这种情况是不能用dynamic_cast的，因为dynamic_cast是用于多态父类指针转换为子类指针的。因为A没有虚函数，所以不存在多态的可能性。</span></span><br><span class="line"><span class="comment">         B* pb11 = dynamic_cast&lt;B*&gt;(pa1);</span></span><br><span class="line"><span class="comment">         if (pb11) &#123;</span></span><br><span class="line"><span class="comment">                 std::cout &lt;&lt; &quot;pb11 got&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         B* pb22 = dynamic_cast&lt;B*&gt;(pa2);</span></span><br><span class="line"><span class="comment">         if (pb11) &#123;</span></span><br><span class="line"><span class="comment">                 std::cout &lt;&lt; &quot;pb22 got&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++虚函数</title>
      <link href="../2021/03/02/c-%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>../2021/03/02/c-%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="问题1-虚构函数是否有必要定义为虚函数？"><a href="#问题1-虚构函数是否有必要定义为虚函数？" class="headerlink" title="问题1: 虚构函数是否有必要定义为虚函数？"></a>问题1: 虚构函数是否有必要定义为虚函数？</h2><p>先查看一个父类的析构函数不是虚函数，并且用父类的指针指向了子类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ~A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~A() destructor called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ~B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~B() destructor called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  A *b = <span class="keyword">new</span> B();</span><br><span class="line">  <span class="keyword">delete</span> b;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>~A() destructor called</p></blockquote><p>可以看到，B的析构函数没有被调用。这样会导致B的资源会泄漏，比如B在初始化的时候打开了一个文件，需要在B的析构函数中Close掉这个文件，但是由于我们使用了父类A指针指向了B的对象，导致了资源泄漏。</p><p>如果把A的析构函数定义为虚函数，就不会出现此问题了。修改后的代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~A() destructor called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ~B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~B() destructor called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  A *b = <span class="keyword">new</span> B();</span><br><span class="line">  <span class="keyword">delete</span> b;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>~B() destructor called<br>~A() destructor called</p></blockquote><p>总结：</p><ul><li><p>如果有需要用到父类指针引用子类这种多态的功能，需要把父类的析构函数定位为虚函数，避免资源泄漏</p></li><li><p>如果实在不想把父类的析构函数定义为虚函数，那么就把父类的虚构函数可见范围定位protected，并且不是虚函数，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  ~A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~A() destructor called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ~B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~B() destructor called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  A *b = <span class="keyword">new</span> B();</span><br><span class="line">  <span class="keyword">delete</span> b;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译的时候就会报错如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">virtualDestructor.cc: In function ‘int main(int, char**)’:</span><br><span class="line">virtualDestructor.cc:<span class="number">15</span>:<span class="number">10</span>: error: ‘A::~A()’ is <span class="keyword">protected</span> within <span class="keyword">this</span> context</span><br><span class="line">   <span class="keyword">delete</span> b;</span><br><span class="line">          ^</span><br><span class="line">virtualDestructor.cc:<span class="number">5</span>:<span class="number">3</span>: note: declared <span class="keyword">protected</span> here</span><br><span class="line">   ~A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~A() destructor called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">   ^</span><br></pre></td></tr></table></figure></li></ul><h2 id="问题2-虚函数到底有什么用？"><a href="#问题2-虚函数到底有什么用？" class="headerlink" title="问题2: 虚函数到底有什么用？"></a>问题2: 虚函数到底有什么用？</h2><p>虚函数解决的运行时多态的问题，所谓的多态就是：运行哪个类的方法。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B&#x27;s fly() called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C&#x27;s fly() called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  A *b = <span class="keyword">new</span> B();</span><br><span class="line">  A *c = <span class="keyword">new</span> C();</span><br><span class="line">  b-&gt;fly();</span><br><span class="line">  c-&gt;fly();</span><br><span class="line">  <span class="keyword">delete</span> b;</span><br><span class="line">  <span class="keyword">delete</span> c;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输出：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B<span class="string">&#x27;s fly() called</span></span><br><span class="line"><span class="string">C&#x27;</span>s fly() called</span><br></pre></td></tr></table></figure><p>B和C都是继承于A的。因此，实例化B和C后，使用A的指针引用它们，调用fly方法的时候，还是调用的是原来类B或C的fly方法。这种机制就叫多态。面向对象中，除了多态还有重载，刚刚我们说多态是运行时决定运行哪个类的方法，那么在C++中重载就是编译时决定链接某个类的哪个方法。（重载在编译时决定，其实是语言实现机制的问题，single dispatch的语言，重载是在编译是决定的。而double dispatch的语言，多态和重载都是运行时决定的）</p><p>重载：类中一个方法的参数不一样，但是函数名字一样。调用哪个方法，是在编译时候决定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B&#x27;s fly() called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B&#x27;s fly(int) called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C&#x27;s fly() called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C&#x27;s fly(int) called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  A *b = <span class="keyword">new</span> B();</span><br><span class="line">  A *c = <span class="keyword">new</span> C();</span><br><span class="line">  b-&gt;fly(<span class="number">10</span>);</span><br><span class="line">  c-&gt;fly(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">delete</span> b;</span><br><span class="line">  <span class="keyword">delete</span> c;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B<span class="number">&#x27;</span><span class="function">s <span class="title">fly</span><span class="params">(<span class="keyword">int</span>)</span> called</span></span><br><span class="line">C&#x27;s fly(int) called</span><br></pre></td></tr></table></figure><p>问题3: 纯虚函数和虚函数的关系</p><p>纯虚函数相当于Java中的接口。其中<code>virtual void fly() = 0;</code>的定义就是纯虚函数，继承A的类必须实现方法<code>void fly()</code>,不然编译阶段就会出现错误。定义纯虚函数，有两个主要的作用：</p><ul><li>保证子类肯定会实现纯虚函数的功能，在模版方法类的设计模式中，可以规定继承模版类的类必须实现某个方法。</li><li>因为拥有一个或一个以上纯虚函数的类叫虚类，虚类是不可以实例化的，因此我们可以加入一个纯虚函数保证虚类不会被实例化。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于纯虚函数，更多定义为一个协议（Contract），保证子类一定遵循这个协议：重写纯虚函数的接口。</p><p>以下例子，就是没有实现纯虚函数的子类B，在编译时候就会出现报错的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">// void fly() &#123; std::cout &lt;&lt; &quot;B&#x27;s fly() called&quot; &lt;&lt; std::endl; &#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B&#x27;s fly(int) called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C&#x27;s fly() called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C&#x27;s fly(int) called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  A *b = <span class="keyword">new</span> B();</span><br><span class="line">  A *c = <span class="keyword">new</span> C();</span><br><span class="line">  b-&gt;fly(<span class="number">10</span>);</span><br><span class="line">  c-&gt;fly(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">delete</span> b;</span><br><span class="line">  <span class="keyword">delete</span> c;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">virtualDestructor.cc: In function ‘int main(int, char**)’:</span><br><span class="line">virtualDestructor.cc:<span class="number">22</span>:<span class="number">16</span>: error: invalid <span class="keyword">new</span>-expression of abstract class type ‘B’</span><br><span class="line">   A *b = <span class="keyword">new</span> B();</span><br><span class="line">                ^</span><br><span class="line">virtualDestructor.cc:<span class="number">9</span>:<span class="number">7</span>: note:   because the following <span class="keyword">virtual</span> functions are pure within ‘B’:</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">       ^</span><br><span class="line">virtualDestructor.cc:<span class="number">5</span>:<span class="number">16</span>: note: <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A::fly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">                ^~~</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Envoy的wasm运行机制</title>
      <link href="../2021/03/02/Envoy%E7%9A%84wasm%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>../2021/03/02/Envoy%E7%9A%84wasm%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-结论"><a href="#1-结论" class="headerlink" title="1. 结论"></a>1. 结论</h2><ul><li><p>每个工作线程之间的虚拟机是相互独立的。线程之间独立的虚拟机（配置是一样的），是Envoy的TLS机制实现的。部分的代码逻辑(详细的要看下面的代码分析)</p><blockquote><p>auto callback = [plugin, this](const Common::Wasm::WasmHandleSharedPtr&amp; base_wasm) {</p><pre><code>// NB: the Slot set() call doesn&#39;t complete inline, so all arguments must outlive this call.tls_slot_-&gt;set(    [base_wasm,     plugin](Event::Dispatcher&amp; dispatcher) -&gt; std::shared_ptr&lt;ThreadLocal::ThreadLocalObject&gt; &#123;      if (!base_wasm) &#123;        return nullptr;      &#125;      return std::static_pointer_cast&lt;ThreadLocal::ThreadLocalObject&gt;(          Common::Wasm::getOrCreateThreadLocalWasm(base_wasm, plugin, dispatcher));    &#125;);</code></pre><p>  };</p></blockquote></li><li><p>同一个工作线程中，使用vm_id 和 vm_config.configuration和编译出来后的wasm字节码三个元素组合作为标志的。换言之，只有这三个元素一致才认为同一个线程中的虚拟机是相同的。如果仅仅是vm_id相同，其他有不一样的，在同一个线程中都不是属于同一个虚拟机。根据三个元素生成vm_key的使用如下：</p><blockquote><p>auto vm_key =</p><pre><code>    proxy_wasm::makeVmKey(vm_config.vm_id(), anyToBytes(vm_config.configuration()), code);</code></pre></blockquote></li><li><p>每个wasm的虚拟机只有一个rootContext，如果配置了多个filters，使用的是同一个虚拟机，引用的rootContext是同一个对象。rootContext的生命周期和wasm虚拟机一样，因此这个可以作为一个计数器。因此每次请求（4层或7层), 都会生成一个Context作为上下文管理器，并且这个Context会引用rootContext。</p></li></ul><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/wasm_context.svg" alt="image"></p><p>​            </p><h2 id="2-架构如下"><a href="#2-架构如下" class="headerlink" title="2. 架构如下"></a>2. 架构如下</h2><p>在讨论Envoy的WASM架构前，先说一下沙箱技术。所谓的沙箱技术其实是一种隔离资源的方法，沙箱并不是一个独立的进程或者线程，可以理解为提供沙箱技术的框架，这个框架实现了ABI的兼容。假设我们编译出来的Wasm字节码也是一个也是一个库，这个库要被Envoy使用，需要有一个沙箱技术的框架，把这些Wasm的字节码加载到内存中去，并且在Envoy需要调用这个库的时候，框架就可以调用到这个库的代码。另外沙箱技术就可以做一些隔离了，比如fd、内存的限制都可以作为配置的一部分。这样可以有效的对不同的用户，做资源上的隔离，也可以达到安全的目的。</p><p>线程级别的vm隔离和vm_key的架构如下：</p><p>其中虚拟机vm是由类Wasm定义的，构造Wasm生成的对象就是一个虚拟机vm。</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20210302171537548.png" alt="image-20210302171537548"></p><p>我们编写的Wasm Filter是如何被Envoy调用的呢？其实有两个关键库</p><ul><li>proxy-was-cpp-host: Envoy源码使用的，用于创建虚拟机和加载wasm code。</li><li>proxy-was-cpp-sdk： 编写Wasm Filter时候需要按照这个库的规范。</li></ul><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20210302172122218.png" alt="image-20210302172122218"></p><h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h2><p>如果我们在http_connection_manager的http_filters中添加了一个wasm的配置，如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http_filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.wasm</span></span><br><span class="line">    <span class="attr">typed_config:</span></span><br><span class="line">      <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/udpa.type.v1.TypedStruct</span></span><br><span class="line">      <span class="attr">type_url:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm</span></span><br><span class="line">      <span class="attr">value:</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">&quot;something-bar&quot;</span></span><br><span class="line">          <span class="attr">root_id:</span> <span class="string">&quot;configuration_demo&quot;</span></span><br><span class="line">          <span class="attr">configuration:</span></span><br><span class="line">            <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">&quot;type.googleapis.com/google.protobuf.StringValue&quot;</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">|</span></span><br><span class="line">              <span class="string">&quot;111111111111111111111&quot;</span></span><br><span class="line">          <span class="attr">vm_config:</span></span><br><span class="line">            <span class="attr">runtime:</span> <span class="string">&quot;envoy.wasm.runtime.v8&quot;</span></span><br><span class="line">            <span class="attr">vm_id:</span> <span class="string">&quot;vm_id_foo&quot;</span></span><br><span class="line">            <span class="attr">code:</span></span><br><span class="line">              <span class="attr">local:</span></span><br><span class="line">                <span class="attr">filename:</span> <span class="string">&quot;../bazel-bin/envoy-wasm-demo/configuration_demo.wasm&quot;</span></span><br><span class="line">            <span class="attr">configuration:</span></span><br><span class="line">              <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">&quot;type.googleapis.com/google.protobuf.StringValue&quot;</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">|-</span></span><br><span class="line">                <span class="string">fasdfdafasdf</span></span><br></pre></td></tr></table></figure><p>这份配置在Envoy初始化的时候，是会执行代码Envoy::Extensions::HttpFilters::Wasm::FilterConfig::FilterConfig（下面简称为FilterConfig）。FilterConfig只会在配置加载的时候执行一次，为每个线程都创建一个wasm的虚拟机。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">FilterConfig::FilterConfig(<span class="keyword">const</span> envoy::extensions::filters::http::wasm::v3::Wasm&amp; config,</span><br><span class="line">                           Server::Configuration::FactoryContext&amp; context)</span><br><span class="line">    : tls_slot_(context.threadLocal().allocateSlot()) &#123;</span><br><span class="line">      </span><br><span class="line">  <span class="comment">// plugin_ 拥有原始的wasm配置的参数，包括runtime的配置   </span></span><br><span class="line">  plugin_ = <span class="built_in">std</span>::make_shared&lt;Common::Wasm::Plugin&gt;(</span><br><span class="line">      config.config().name(), config.config().root_id(), config.config().vm_config().vm_id(),</span><br><span class="line">      config.config().vm_config().runtime(),</span><br><span class="line">      Common::Wasm::anyToBytes(config.config().configuration()), config.config().fail_open(),</span><br><span class="line">      context.direction(), context.localInfo(), &amp;context.listenerMetadata());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> plugin = plugin_;</span><br><span class="line">  <span class="comment">// 回调函数callback,用于给每个线程都创建或获取一个Wasm的虚拟机（调用getOrCreateThreadLocalWasm实现）。</span></span><br><span class="line">  <span class="keyword">auto</span> callback = [plugin, <span class="keyword">this</span>](<span class="keyword">const</span> Common::Wasm::WasmHandleSharedPtr&amp; base_wasm) &#123;</span><br><span class="line">    <span class="comment">// NB: the Slot set() call doesn&#x27;t complete inline, so all arguments must outlive this call.</span></span><br><span class="line">    tls_slot_-&gt;<span class="built_in">set</span>(</span><br><span class="line">        [base_wasm,</span><br><span class="line">         plugin](Event::Dispatcher&amp; dispatcher) -&gt; <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ThreadLocal::ThreadLocalObject&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (!base_wasm) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">std</span>::static_pointer_cast&lt;ThreadLocal::ThreadLocalObject&gt;(</span><br><span class="line">              Common::Wasm::getOrCreateThreadLocalWasm(base_wasm, plugin, dispatcher));</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 根据配置文件的创建wasm</span></span><br><span class="line">  <span class="keyword">if</span> (!Common::Wasm::createWasm(</span><br><span class="line">          config.config().vm_config(), plugin_, context.scope().createScope(<span class="string">&quot;&quot;</span>),</span><br><span class="line">          context.clusterManager(), context.initManager(), context.dispatcher(), context.api(),</span><br><span class="line">          context.lifecycleNotifier(), remote_data_provider_, <span class="built_in">std</span>::move(callback))) &#123;</span><br><span class="line">    <span class="keyword">throw</span> Common::Wasm::WasmException(</span><br><span class="line">        fmt::format(<span class="string">&quot;Unable to create Wasm HTTP filter &#123;&#125;&quot;</span>, plugin-&gt;name_));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用Common::Was::createWasm最终会调用到CreateWasmInternal, 其代码如下（使用local模式加载wasm代码后精简）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">createWasmInternal</span><span class="params">(<span class="keyword">const</span> VmConfig&amp; vm_config, <span class="keyword">const</span> PluginSharedPtr&amp; plugin,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">const</span> Stats::ScopeSharedPtr&amp; scope,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Upstream::ClusterManager&amp; cluster_manager,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Init::Manager&amp; init_manager, Event::Dispatcher&amp; dispatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Api::Api&amp; api, Server::ServerLifecycleNotifier&amp; lifecycle_notifier,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Config::DataSource::RemoteAsyncDataProviderPtr&amp; remote_data_provider,</span></span></span><br><span class="line"><span class="function"><span class="params">                               CreateWasmCallback&amp;&amp; cb,</span></span></span><br><span class="line"><span class="function"><span class="params">                               CreateContextFn create_root_context_for_testing = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取一个EnvoyWasm对象</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    WasmExtension* getWasmExtension() &#123;</span></span><br><span class="line"><span class="comment">      static WasmExtension* extension = wasm_extension ? wasm_extension : new EnvoyWasm();</span></span><br><span class="line"><span class="comment">      return extension;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">auto</span> wasm_extension = getWasmExtension();</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> source, code;</span><br><span class="line">    <span class="comment">// 从本地读取wasm编译后的字节码</span></span><br><span class="line">    code = Config::DataSource::read(vm_config.code().local(), <span class="literal">true</span>, api);</span><br><span class="line">    source = Config::DataSource::getPath(vm_config.code().local())</span><br><span class="line">                 .value_or(code.empty() ? EMPTY_STRING : INLINE_STRING);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> complete_cb = [cb, vm_config, plugin, scope, &amp;cluster_manager, &amp;dispatcher,</span><br><span class="line">                      &amp;lifecycle_notifier, create_root_context_for_testing,</span><br><span class="line">                      wasm_extension](<span class="built_in">std</span>::<span class="built_in">string</span> code) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (code.empty()) &#123;</span><br><span class="line">      cb(<span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据vm_id、vm的配置和wasm字节码生成一个vm_key,用于唯一标识虚拟机</span></span><br><span class="line">    <span class="keyword">auto</span> vm_key =</span><br><span class="line">        proxy_wasm::makeVmKey(vm_config.vm_id(), anyToBytes(vm_config.configuration()), code);</span><br><span class="line">    <span class="keyword">auto</span> wasm_factory = wasm_extension-&gt;wasmFactory();</span><br><span class="line">    proxy_wasm::WasmHandleFactory proxy_wasm_factory =</span><br><span class="line">        [&amp;vm_config, scope, &amp;cluster_manager, &amp;dispatcher, &amp;lifecycle_notifier,</span><br><span class="line">         wasm_factory](absl::string_view vm_key) -&gt; WasmHandleBaseSharedPtr &#123;</span><br><span class="line">      <span class="keyword">return</span> wasm_factory(vm_config, scope, cluster_manager, dispatcher, lifecycle_notifier,</span><br><span class="line">                          vm_key);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 创建虚拟机  </span></span><br><span class="line">    <span class="keyword">auto</span> wasm = proxy_wasm::createWasm(</span><br><span class="line">        vm_key, code, plugin, proxy_wasm_factory,</span><br><span class="line">        getCloneFactory(wasm_extension, dispatcher, create_root_context_for_testing),</span><br><span class="line">        vm_config.allow_precompiled());</span><br><span class="line">    Stats::ScopeSharedPtr create_wasm_stats_scope =</span><br><span class="line">        wasm_extension-&gt;lockAndCreateStats(scope, plugin);</span><br><span class="line">    wasm_extension-&gt;onEvent(toWasmEvent(wasm), plugin);</span><br><span class="line">    <span class="keyword">if</span> (!wasm || wasm-&gt;wasm()-&gt;isFailed()) &#123;</span><br><span class="line">      ENVOY_LOG_TO_LOGGER(Envoy::Logger::Registry::getLog(Envoy::Logger::Id::wasm), trace,</span><br><span class="line">                          <span class="string">&quot;Unable to create Wasm&quot;</span>);</span><br><span class="line">      cb(<span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建虚拟机成功后，执行tls的回调函数，使的每个线程都拥有一个拷贝出来的虚拟机。</span></span><br><span class="line">    cb(<span class="built_in">std</span>::static_pointer_cast&lt;WasmHandle&gt;(wasm));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> complete_cb(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proxy_wasm::createWasm调用的是proxy-wasm-cpp-host库中的函数createWasm，具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;WasmHandleBase&gt; <span class="title">createWasm</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> vm_key, <span class="built_in">std</span>::<span class="built_in">string</span> code,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PluginBase&gt; plugin,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           WasmHandleFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           WasmHandleCloneFactory clone_factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">bool</span> allow_precompiled)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;WasmHandleBase&gt; wasm_handle;</span><br><span class="line">  &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">guard</span><span class="params">(base_wasms_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!base_wasms) &#123;</span><br><span class="line">      base_wasms = <span class="keyword">new</span> <span class="built_in">std</span>::remove_reference&lt;<span class="keyword">decltype</span>(*base_wasms)&gt;::type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在同一个vm_key相同的虚拟机，直接返回即可。否则就要创建一个新的虚拟机。</span></span><br><span class="line">    <span class="keyword">auto</span> it = base_wasms-&gt;find(vm_key);</span><br><span class="line">    <span class="keyword">if</span> (it != base_wasms-&gt;end()) &#123;</span><br><span class="line">      wasm_handle = it-&gt;second.lock();</span><br><span class="line">      <span class="keyword">if</span> (!wasm_handle) &#123;</span><br><span class="line">        base_wasms-&gt;erase(it);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wasm_handle) &#123;</span><br><span class="line">      <span class="keyword">return</span> wasm_handle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据vm_key去创建一个虚拟机。这个factory就是EnvoyWasm对象中的factory.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     proxy_wasm::WasmHandleFactory proxy_wasm_factory =</span></span><br><span class="line"><span class="comment">        [&amp;vm_config, scope, &amp;cluster_manager, &amp;dispatcher, &amp;lifecycle_notifier,</span></span><br><span class="line"><span class="comment">         wasm_factory](absl::string_view vm_key) -&gt; WasmHandleBaseSharedPtr &#123;</span></span><br><span class="line"><span class="comment">      return wasm_factory(vm_config, scope, cluster_manager, dispatcher, lifecycle_notifier,</span></span><br><span class="line"><span class="comment">                          vm_key);</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    wasm_handle = factory(vm_key);</span><br><span class="line">    <span class="keyword">if</span> (!wasm_handle) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (*base_wasms)[vm_key] = wasm_handle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新创建出来的虚拟机，需要执行下面的一系列初始化的过程。</span></span><br><span class="line">  <span class="keyword">if</span> (!wasm_handle-&gt;wasm()-&gt;initialize(code, allow_precompiled)) &#123;</span><br><span class="line">    wasm_handle-&gt;wasm()-&gt;fail(FailState::UnableToInitializeCode, <span class="string">&quot;Failed to initialize Wasm code&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//配置预检查。clone_factory克隆一个wasm出来去执行相关的配置</span></span><br><span class="line">  <span class="comment">// getCloneFactory(wasm_extension, dispatcher, create_root_context_for_testing)</span></span><br><span class="line">  <span class="keyword">auto</span> configuration_canary_handle = clone_factory(wasm_handle);</span><br><span class="line">  <span class="keyword">if</span> (!configuration_canary_handle) &#123;</span><br><span class="line">    wasm_handle-&gt;wasm()-&gt;fail(FailState::UnableToCloneVM, <span class="string">&quot;Failed to clone Base Wasm&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!configuration_canary_handle-&gt;wasm()-&gt;initialize(code, allow_precompiled)) &#123;</span><br><span class="line">    wasm_handle-&gt;wasm()-&gt;fail(FailState::UnableToInitializeCode, <span class="string">&quot;Failed to initialize Wasm code&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> root_context = configuration_canary_handle-&gt;wasm()-&gt;start(plugin);</span><br><span class="line">  <span class="keyword">if</span> (!root_context) &#123;</span><br><span class="line">    configuration_canary_handle-&gt;wasm()-&gt;fail(FailState::StartFailed, <span class="string">&quot;Failed to start base Wasm&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!configuration_canary_handle-&gt;wasm()-&gt;configure(root_context, plugin)) &#123;</span><br><span class="line">    configuration_canary_handle-&gt;wasm()-&gt;fail(FailState::ConfigureFailed,</span><br><span class="line">                                              <span class="string">&quot;Failed to configure base Wasm plugin&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  configuration_canary_handle-&gt;kill();</span><br><span class="line">  <span class="keyword">return</span> wasm_handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在createWasm创建虚拟机的工厂函数的实现是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WasmHandleExtensionFactory <span class="title">EnvoyWasm::wasmFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [](<span class="keyword">const</span> VmConfig vm_config, <span class="keyword">const</span> Stats::ScopeSharedPtr&amp; scope,</span><br><span class="line">            Upstream::ClusterManager&amp; cluster_manager, Event::Dispatcher&amp; dispatcher,</span><br><span class="line">            Server::ServerLifecycleNotifier&amp; lifecycle_notifier,</span><br><span class="line">            absl::string_view vm_key) -&gt; WasmHandleBaseSharedPtr &#123;</span><br><span class="line">    <span class="comment">// 根据插件的配置去创建一个虚拟机. 使用的类是Wasm</span></span><br><span class="line">    <span class="keyword">auto</span> wasm = <span class="built_in">std</span>::make_shared&lt;Wasm&gt;(vm_config.runtime(), vm_config.vm_id(),</span><br><span class="line">                                       anyToBytes(vm_config.configuration()), vm_key, scope,</span><br><span class="line">                                       cluster_manager, dispatcher);</span><br><span class="line">    wasm-&gt;initializeLifecycle(lifecycle_notifier);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::static_pointer_cast&lt;WasmHandleBase&gt;(<span class="built_in">std</span>::make_shared&lt;WasmHandle&gt;(<span class="built_in">std</span>::move(wasm)));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后真正创建虚拟机的代码是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WasmVmPtr <span class="title">createWasmVm</span><span class="params">(absl::string_view runtime, <span class="keyword">const</span> Stats::ScopeSharedPtr&amp; scope)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  部分代码被省略；std::unique_ptr&lt;WasmVm&gt; createV8Vm() &#123; return std::make_unique&lt;V8&gt;(); &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(ENVOY_WASM_V8)</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (runtime == WasmRuntimeNames::get().V8) &#123;</span><br><span class="line">    <span class="keyword">auto</span> wasm = proxy_wasm::createV8Vm();</span><br><span class="line">    wasm-&gt;integration() = getWasmExtension()-&gt;createEnvoyWasmVmIntegration(scope, runtime, <span class="string">&quot;v8&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> wasm;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Wasm相关代码的类图"><a href="#4-Wasm相关代码的类图" class="headerlink" title="4. Wasm相关代码的类图"></a>4. Wasm相关代码的类图</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20210302173352881.png" alt="image-20210302173352881"></h2><ul><li><p>EnvoyWasm可以理解为一个工厂类，里面定义了如何创建一个虚拟机；如何根据一个虚拟机（base_vm)去克隆出另外一个虚拟机（代码层面就是拷贝构造）。</p></li><li><p>Wasm就是虚拟机的类。里面定义虚拟机的所有操作。</p></li><li><p>V8是谷歌开源的js和wasm的引擎，是虚拟机的运行时。Wasm内部有个成员wasm_vm_引用的就是虚拟机的运行时。Envoy支持三种运行时：V8，Wavm，nullVm</p></li><li><p>WasmHandle里面引用的虚拟机Wasm类构造出来的对象，另外WasmHandle继承于ThreadLocalObject,这样这个对象就可以多个线程之前独立了。这是实现每个线程的虚拟机之前隔离的重要手段。</p></li><li><p>黄色的类是Envoy的源码中的。粉色的类是proxy-wasm-cpp-host的源码中的。</p></li></ul><h2 id="5-关于WasmFilter中的onConfigure"><a href="#5-关于WasmFilter中的onConfigure" class="headerlink" title="5. 关于WasmFilter中的onConfigure"></a>5. 关于WasmFilter中的onConfigure</h2><p>编写WasmFilter的时候，RootContext的onConfigure会被执行多次（如果同一个线程中存在多个同一个vm（三个元素显通才能认为是同一个vm）的配置）。</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20210302172326136.png" alt="image-20210302172326136"></p><p>Envoy中调用on_configure会执行到RootContext的onConfigure。但是onConfigure的参数是插件plugin的配置字符串的大小。如果我们希望拿vm_config的配置，有两个做法（当然也可以把配置放在plugin中）：</p><ul><li>插件的configuration和vm的configuration一致即可。</li><li>插件的configuration的字符串长度大于vm的configuration。</li></ul><blockquote><p>auto result =<br>      wasm_-&gt;on_configure_(this, id_, static_cast<uint32_t>(plugin-&gt;plugin_configuration_.size()))<br>          .u64_ != 0;</p></blockquote><p>小结：我们的配置最好放在plugin的configuration的字段中，而不是用vm_config中的configuration。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Envoy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lua的iterator实现</title>
      <link href="../2021/03/02/lua%E7%9A%84iterator%E5%AE%9E%E7%8E%B0/"/>
      <url>../2021/03/02/lua%E7%9A%84iterator%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="使用函数实现迭代器"><a href="#使用函数实现迭代器" class="headerlink" title="使用函数实现迭代器"></a>使用函数实现迭代器</h2><p>本次演示的例子：迭代器的实现是建立在协程上的，首先来看一下如何通过一个函数封装来实现一个普通的迭代器。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">coroutine</span> = <span class="built_in">coroutine</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">iter_something</span><span class="params">(times)</span></span></span><br><span class="line">  <span class="keyword">local</span> inter_func = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">0</span>,t <span class="keyword">do</span></span><br><span class="line">      <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(<span class="string">&quot;return by coroutine &quot;</span> .. i)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">local</span> co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(inter_func)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> ok,ret = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, times)</span><br><span class="line">    <span class="keyword">if</span> ok <span class="keyword">then</span> <span class="keyword">return</span> ret <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span>  <span class="keyword">return</span> <span class="string">&quot;fault&quot;</span> <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行函数iter_something</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> iter_something(<span class="number">10</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行后输出：</p><blockquote><p>return by coroutine 0<br>return by coroutine 1<br>return by coroutine 2<br>return by coroutine 3<br>return by coroutine 4<br>return by coroutine 5<br>return by coroutine 6<br>return by coroutine 7<br>return by coroutine 8<br>return by coroutine 9<br>return by coroutine 10</p></blockquote><p>原理分析：</p><ul><li>iter_something函数返回了一个函数对象（闭包的功能）</li><li>for value in iter_something(10) 就会去返回的函数对象resume，也会产生对inter_func的resume</li><li>当inter_func函数返回后（协程变成dead状态后），for就会马上退出。因此我们看不到”fault”的输出。</li></ul><h2 id="使用-call迭代器"><a href="#使用-call迭代器" class="headerlink" title="使用__call迭代器"></a>使用__call迭代器</h2><p>使用了lua的高级数据__call来封装一个类。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">coroutine</span> = <span class="built_in">coroutine</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">get_next</span><span class="params">(self)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">self</span>.i &gt; <span class="number">5</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in get_next &quot;</span> .. <span class="built_in">self</span>.i)</span><br><span class="line">    <span class="built_in">self</span>.i = <span class="built_in">self</span>.i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">self</span>.i</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> state_mt = &#123; <span class="built_in">__call</span> = get_next&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func_iter</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> state = &#123;</span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setmetatable</span>(state,state_mt)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> func_iter() <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>执行后输出：</p><blockquote><p>in get_next 0<br>1<br>in get_next 1<br>2<br>in get_next 2<br>3<br>in get_next 3<br>4<br>in get_next 4<br>5<br>in get_next 5<br>6</p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lua的协程的使用</title>
      <link href="../2021/03/02/lua%E7%9A%84%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>../2021/03/02/lua%E7%9A%84%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="coroutine-create"><a href="#coroutine-create" class="headerlink" title="coroutine.create"></a>coroutine.create</h2><p>创建协程有两种方法：</p><ul><li>coroutine.create</li><li>coroutine.warp</li></ul><p>使用coroutine.create创建协程并使用：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span> <span class="params">(a,b)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Inside the coroutine&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">yield</span>(a+b,a-b))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">yield</span>(a+b,a-b))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">99</span>, <span class="number">99</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="string">&quot;hello&quot;</span>,<span class="string">&quot; world&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;still running&quot;</span>)</span><br></pre></td></tr></table></figure><p>流程梳理：</p><ul><li><p>coroutine.crate 的参数是一个函数，因此创建协程的时候需要传入一个函数对象。</p></li><li><p>coroutine.crate返回后，传入的函数并不会立刻被执行，需要执行resume操作才可以。</p></li><li><p>coroutine.resume就是重新调度协程co，并且传入参数a，b到匿名函数中</p></li><li><p>匿名函数执行到yield的时候，传入的参数是（a+b, a-b ），因此<code>print(coroutine.resume(co, 20,10))</code>中的<code>coroutine.resume(co, 20,10)</code>立刻得到返回，返回值是 true，a+b(30), a-b (10），所以<code>print(coroutine.resume(co, 20,10))</code>会输出</p><blockquote><p>true, 30, 10</p></blockquote></li><li><p>等到执行<code>coroutine.resume(co, &quot;hello&quot;,&quot; world&quot;)</code>的时候，<code>print(coroutine.yield(a+b,a-b))</code>处的yield就会得到重新调度，相当于yield函数返回了，返回值为”hello”, “ world”, 所以<code>print(coroutine.yield(a+b,a-b))</code>输出</p><blockquote><p>hello world</p></blockquote></li><li><p>匿名函数return后，这个协程就变成了dead状态，是不能再resume的，因此调用<code>print(coroutine.resume(co))</code>时候，会返回错误，因为co在前面已经return掉了。虽然协程调度出错，但是lua的代码执行是继续的。</p></li></ul><p>上述代码执行后的输出结果是：</p><blockquote><p>Inside the coroutine<br>true    30    10<br>hello     world<br>true    30    10<br>1    2    3<br>true    99    99<br>false    cannot resume dead coroutine<br>still running</p></blockquote><h2 id="coroutine-wrap"><a href="#coroutine-wrap" class="headerlink" title="coroutine.wrap"></a>coroutine.wrap</h2><p>wrap返回的是一个函数：类似 coroutine.create ， coroutine.wrap 这个函数也将创建一个 coroutine ， 但是它并不返回 coroutine 本身，而是返回一个函数取而代之。一旦你调用这个返回函数，就会切入 coroutine 运行。 所有传入这个函数的参数等同于传入 coroutine.resume 的参数。 coroutine.wrap 会返回所有应该由除第一个（错误代码的那个布尔量） 之外的由 coroutine.resume 返回的值。 和 coroutine.resume 不同， coroutine.wrap 不捕获任何错误； 所有的错误都应该由调用者自己传递。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> co = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(<span class="function"><span class="keyword">function</span> <span class="params">(a,b)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;co&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(a+b,a-b))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;co&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(a+b,a-b))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">99</span>, <span class="number">99</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">print</span>(co(<span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(co(<span class="number">44</span>,<span class="number">55</span>))</span><br><span class="line"><span class="built_in">print</span>(co(<span class="number">22</span>,<span class="number">33</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>30    10<br> co    44    55<br> 30    10<br> co    22    33<br> 99    99</p></blockquote><h2 id="使用协程实现生产者和消费者模型"><a href="#使用协程实现生产者和消费者模型" class="headerlink" title="使用协程实现生产者和消费者模型"></a>使用协程实现生产者和消费者模型</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">produce</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> x = <span class="built_in">io</span>.<span class="built_in">read</span>()</span><br><span class="line">        send(x)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consume</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> x = receive()</span><br><span class="line">        <span class="built_in">io</span>.<span class="built_in">write</span>(x, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receive</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">status</span>, value = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(producer)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(x)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">producer = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(produce)</span><br><span class="line">consume()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用协程实现生产者、Filter和消费者模型"><a href="#使用协程实现生产者、Filter和消费者模型" class="headerlink" title="使用协程实现生产者、Filter和消费者模型"></a>使用协程实现生产者、Filter和消费者模型</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receive</span><span class="params">(prod)</span></span></span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">status</span>, value = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(prod)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(x)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">local</span> x = <span class="built_in">io</span>.<span class="built_in">read</span>()</span><br><span class="line">            send(x)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span><span class="params">(prod)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">        <span class="keyword">local</span> line = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">local</span> x = receive(prod)</span><br><span class="line">            x = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%5d %s&quot;</span>, line, x)</span><br><span class="line">            send(x)</span><br><span class="line">            line = line + <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consumer</span><span class="params">(prod)</span></span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> x = receive(prod)</span><br><span class="line">        <span class="built_in">io</span>.<span class="built_in">write</span>(x, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">p = producer()</span><br><span class="line">f = filter(p)</span><br><span class="line">consumer(f)</span><br><span class="line"></span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lua面向对象和继承使用</title>
      <link href="../2021/03/02/lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%BB%A7%E6%89%BF%E4%BD%BF%E7%94%A8/"/>
      <url>../2021/03/02/lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%BB%A7%E6%89%BF%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="lua的面向对象"><a href="#lua的面向对象" class="headerlink" title="lua的面向对象"></a>lua的面向对象</h2><p>lua作为一种小巧的脚本语言，也是支持面向对象的。lua的面向对象是基于“原型”模式实现的，需要使用到lua的高级特性metatable和setmetatable()。</p><p>先通过一个简单的例子来说明一下lua的原型模型的面向对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env /usr/local/openresty/bin/resty</span><br><span class="line"></span><br><span class="line">local proto = &#123;foo = <span class="string">&quot;hello&quot;</span>&#125; -- 原型</span><br><span class="line"></span><br><span class="line">function proto:go() -- 添加一个方法，类似C++类的方法一样</span><br><span class="line">    print(<span class="string">&quot;go()-&gt; &quot;</span> .. self.foo)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local mt = &#123;__index = proto&#125; -- 重载了__index</span><br><span class="line"></span><br><span class="line">local obj = setmetatable(proto, mt) -- 设置元表，后面对obj.key操作就会去到mt的__index去寻找</span><br><span class="line"></span><br><span class="line">obj:go() -- obj是proto的克隆（构造出来的新对象）</span><br><span class="line"></span><br><span class="line">obj.foo = <span class="string">&quot;world&quot;</span></span><br><span class="line">obj:go()</span><br></pre></td></tr></table></figure><p> 执行脚本后输出如下：</p><blockquote><p>go()-&gt; hello<br>go()-&gt; world</p></blockquote><h2 id="对象的继承和封装模块"><a href="#对象的继承和封装模块" class="headerlink" title="对象的继承和封装模块"></a>对象的继承和封装模块</h2><p>首先在同一个目录创建object.lua和test.lua两个文件，其中object.lua可以认为是一个库文件，里面定义了两个类retangle和shape，其中retangle是继承于shape的。我们来看看lua中怎么实现继承和模块的封装。</p><p>object.lua的内容：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> shape = &#123;area=<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shape:new</span><span class="params">(side)</span></span></span><br><span class="line">    <span class="keyword">local</span> mt = &#123;<span class="built_in">__index</span> = shape&#125;</span><br><span class="line">    <span class="keyword">local</span> obj = <span class="built_in">setmetatable</span>(&#123;&#125;, mt)</span><br><span class="line">    side = side <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">    obj.area = side*side</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shape:show</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Area of shape is &quot;</span> .. <span class="built_in">self</span>.area)</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shape:text</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am shape.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> retangle = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">retangle:new</span><span class="params">(side)</span></span></span><br><span class="line">    <span class="keyword">local</span> mt = &#123;<span class="built_in">__index</span> = retangle&#125;</span><br><span class="line">    <span class="keyword">local</span> parent = shape:new(side)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setmetatable</span>(parent, mt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">retangle:show</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Area of retangle is &quot;</span> .. <span class="built_in">self</span>.area)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">retangle:text</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am retangle&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    retangle = retangle,</span><br><span class="line">    shape = shape,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>test.lua的代码内容如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env /usr/<span class="keyword">local</span>/openresty/bin/resty</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span> <span class="string">&quot;luarocks.loader&quot;</span></span><br><span class="line"><span class="built_in">package</span>.<span class="built_in">path</span> = <span class="string">&quot;./?.lua;./?/init.lua;&quot;</span> .. <span class="built_in">package</span>.<span class="built_in">path</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> object = <span class="built_in">require</span> <span class="string">&quot;object&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> ret = object.retangle:new(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">ret:show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> shape = object.shape:new(<span class="number">20</span>)</span><br><span class="line">shape:show()</span><br></pre></td></tr></table></figure><p>关于模块封装方面，object.lua返回一个local的table。这个table中符号就可以被使用者调用（使用者要先require这个模块）。</p><p>关于继承方面，重点看一下retangle的new函数</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> retangle = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">retangle:new</span><span class="params">(side)</span></span></span><br><span class="line">    <span class="keyword">local</span> mt = &#123;<span class="built_in">__index</span> = retangle&#125; <span class="comment">-- 定义元表mt</span></span><br><span class="line">    <span class="keyword">local</span> parent = shape:new(side) <span class="comment">-- 继承了shape就是在这里</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setmetatable</span>(parent, mt)  <span class="comment">-- 设置即将要克隆出来的新对象的元表，新对象是优先去自己的元表里面检索成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lua使用ffi使用正常的c编译动态库</title>
      <link href="../2021/03/01/lua%E4%BD%BF%E7%94%A8ffi%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%B8%B8%E7%9A%84c%E7%BC%96%E8%AF%91%E5%8A%A8%E6%80%81%E5%BA%93/"/>
      <url>../2021/03/01/lua%E4%BD%BF%E7%94%A8ffi%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%B8%B8%E7%9A%84c%E7%BC%96%E8%AF%91%E5%8A%A8%E6%80%81%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="RSA签名和验签的例子"><a href="#RSA签名和验签的例子" class="headerlink" title="RSA签名和验签的例子"></a>RSA签名和验签的例子</h2><p>首先使用openssl的命令行，展示一下如何使用命令行的方式，用RSA的私钥对数据进行签名和用RSA的公钥对签名后的数据验签。</p><p>RSA其实有两种工作模式：</p><ul><li>私钥签名，公钥验签</li><li>公钥加密，私钥解密</li></ul><p>验证流程如下：</p><ol><li><p>生成RSA的公私钥：</p><ul><li>生成私钥：<code>openssl genrsa -out private.pem 2048</code></li><li>根据私钥生成公钥：<code>openssl rsa -in private.pem -outform PEM -pubout -out public.pem</code></li></ul></li><li><p>使用私钥签名：<code>echo &quot;hello world&quot; | openssl rsautl -inkey private.pem -sign -out sig</code></p></li><li><p>使用公钥验签：<code>openssl  rsautl -verify -inkey public.pem -in sig -pubin</code></p><p>验签后得到：<code>hello world</code></p></li></ol><h2 id="lua代码中使用c编译后的动态库"><a href="#lua代码中使用c编译后的动态库" class="headerlink" title="lua代码中使用c编译后的动态库"></a>lua代码中使用c编译后的动态库</h2><p>C代码的工具资源比较多，而且C可以操作比较底层的数据，这是使用lua时候比较难办到的。正常编译的动态库，不能直接被lua的代码使用，因此ABI都不一样，因此需要在lua代码和c的动态库中添加一个shim（垫片）作为中间层。ffi就是这样一个库，用来作为lua代码和c代码之间的桥梁。</p><p>试验代码：</p><h3 id="使用者lua代码test-lua"><a href="#使用者lua代码test-lua" class="headerlink" title="使用者lua代码test.lua"></a>使用者lua代码test.lua</h3><p>使用了一个rsa库，rsa库是使用c动态编库的。</p><p>构造数据的方法：</p><ul><li>public_key： <code>cat public.pem |base64  |tr -d &quot;\n&quot;</code></li><li>signed_data: <code>cat sig |base64 |tr -d &quot;\n&quot;</code></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env /usr/<span class="keyword">local</span>/openresty/bin/resty</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span> <span class="string">&quot;luarocks.loader&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">package</span>.<span class="built_in">path</span> = <span class="string">&quot;./?.lua;./?/init.lua;&quot;</span> .. <span class="built_in">package</span>.<span class="built_in">path</span></span><br><span class="line"><span class="keyword">local</span> rsa = <span class="built_in">require</span> <span class="string">&quot;rsa&quot;</span></span><br><span class="line"><span class="keyword">local</span> decode_base64 = ngx.decode_base64</span><br><span class="line"></span><br><span class="line"><span class="comment">--local public_key = &quot;aGVsbG8K&quot;</span></span><br><span class="line"><span class="keyword">local</span> public_key = <span class="string">[[LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUF5YkIyM0VUWEZNZjhXbVJTVkFBMgpVOHNHUFN6WWpYbWl6WFZKemFCbERjTlFZYlVNd2F5YVNoK05hOU1paFl3VnBsZVlTS05UVmNQU1ZYV2t0ejFLCnRWdVU5OGVOZ0F3L0t6VElKTFhHVWdTZm4vSmtpVzExZGJpVzZ1NEkwK0pGc2NSRnRuK1BaT0RLTGd2OVRRcmMKdW5SQjZHNXFRdE41SjJNSGI3TE1zT0cxOVQ0VStlS3llTEs2SkMxT0VUQ1hWcnJnektsWlhhZVhBQk8yMVpvUAoxZnBubTBDRnBIS2prYmMvR1NLZ0hPYnNscGJVWHZmUWNaY3FMZUk0WmoydHVSZnNnQzluR0VQU1o1TFI0ZHNHClNpR1BTMUhvZWhLd255WWt6Tm1pZmlUa2hxQ2ovNS9pcGRKZVNoSXZlTlJjRjFXdHkzTzE0MWcvRUJwZ1FZZlYKZ1FJREFRQUIKLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg==]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> signed_data = <span class="string">[[uL0CcHW4X+Jv6ClX2q4UKytvDsH7W3HNVSqa2qvV9QmQpG2WYTWO1tnfkChVVXYbfVcQeBsG61JghFaLqqxGuraeigWU4GWbUKyDhuYSMxeIeyOhR93P+lHTsM23S4zZdhp1bGtv5um298fgR+nk1SmSytGn/cMsq8HC9mlyOL7y4mHlfSsUtr2zGMO3d6zqu02QN0Qw86YtvDhmwpay394WCYRjmGhNNGkaCO27WPm3ylwSmuv12wb/AMvzE6cV/QhORUkOrj/ProIys7gHwhTs/a4fmakKqNTu2deEmTAvLcirvNU3vBnpEsX6uHTstCDCzoi1FIxkLpb4UgLsgQ==]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> real_public_key = decode_base64(public_key)</span><br><span class="line"><span class="keyword">local</span> data = decode_base64(signed_data)</span><br><span class="line"></span><br><span class="line">real_data = rsa.public_verify(data, real_public_key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(real_data)</span><br></pre></td></tr></table></figure><p>执行后的输出为：</p><blockquote><p>./test.lua<br>hello worlda</p></blockquote><h3 id="中间垫片层ffi"><a href="#中间垫片层ffi" class="headerlink" title="中间垫片层ffi"></a>中间垫片层ffi</h3><p>ffi作为一个翻译的中间层，需要承上启下对接lua代码和c的代码。本文只给出最终的代码rsa.lua，原理不详述。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> foo=&#123;&#125;</span><br><span class="line"><span class="keyword">local</span> ffi = <span class="built_in">require</span>(<span class="string">&quot;ffi&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> Rsa = ffi.<span class="built_in">load</span>(<span class="string">&quot;crypto&quot;</span>)</span><br><span class="line"></span><br><span class="line">ffi.cdef<span class="string">[[</span></span><br><span class="line"><span class="string">typedef struct rsa_st RSA;</span></span><br><span class="line"><span class="string">typedef struct bio_st BIO;</span></span><br><span class="line"><span class="string">typedef int pem_password_cb(char *buf, int size, int rwflag, void *userdata);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int RSA_public_encrypt(int flen, const unsigned char *from, unsigned char *to, RSA *rsa,int padding);</span></span><br><span class="line"><span class="string">int RSA_private_encrypt(int flen, const unsigned char *from, unsigned char *to, RSA *rsa,int padding);</span></span><br><span class="line"><span class="string">int RSA_public_decrypt(int flen, const unsigned char *from, unsigned char *to, RSA *rsa,int padding);</span></span><br><span class="line"><span class="string">int RSA_private_decrypt(int flen, const unsigned char *from, unsigned char *to, RSA *rsa,int padding);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">BIO *BIO_new_mem_buf(void *buf, int len);</span></span><br><span class="line"><span class="string">RSA *PEM_read_bio_RSA_PUBKEY(BIO *bp, RSA **x, pem_password_cb *cb, void *u);</span></span><br><span class="line"><span class="string">RSA *PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **x, pem_password_cb *cb, void *u);</span></span><br><span class="line"><span class="string">int RSA_size(const RSA *r);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> RSA_PKCS1_PADDING = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">init_public_key</span><span class="params">(pem_key)</span></span></span><br><span class="line">  <span class="keyword">local</span> bio = Rsa.BIO_new_mem_buf(ffi.cast(<span class="string">&quot;unsigned char *&quot;</span>, pem_key), <span class="number">-1</span>)</span><br><span class="line">  <span class="keyword">local</span> rsa = Rsa.PEM_read_bio_RSA_PUBKEY(bio, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>);</span><br><span class="line">  <span class="keyword">if</span> rsa == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">&quot;parse public key fail&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> rsa, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">init_private_key</span><span class="params">(pem_key)</span></span></span><br><span class="line">  <span class="keyword">local</span> bio = Rsa.BIO_new_mem_buf(ffi.cast(<span class="string">&quot;unsigned char *&quot;</span>, pem_key), <span class="number">-1</span>)</span><br><span class="line">  <span class="keyword">local</span> rsa = Rsa.PEM_read_bio_RSAPrivateKey(bio, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>);</span><br><span class="line">  <span class="keyword">if</span> rsa == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">&quot;parse public key fail&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> rsa, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo.public_verify</span><span class="params">(data, key)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">local</span> rsa, err = init_public_key(key)</span><br><span class="line">  <span class="keyword">if</span> err ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">local</span> size = <span class="built_in">tonumber</span>(Rsa.RSA_size(rsa))</span><br><span class="line">  <span class="keyword">local</span> decrypted = ffi.new(<span class="string">&quot;unsigned char[?]&quot;</span>, size)</span><br><span class="line">  data = ffi.cast(<span class="string">&quot;const unsigned char *&quot;</span> ,data)</span><br><span class="line">  <span class="keyword">local</span> <span class="built_in">len</span> = Rsa.RSA_public_decrypt(size, data, decrypted, rsa, RSA_PKCS1_PADDING)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span> &lt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">local</span> ret = ffi.<span class="built_in">string</span>(decrypted, <span class="built_in">len</span>)</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo.private_encrypt</span><span class="params">(data, key)</span></span></span><br><span class="line">  <span class="keyword">local</span> rsa, err = init_private_key(key)</span><br><span class="line">  <span class="keyword">if</span> err ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">local</span> size = <span class="built_in">tonumber</span>(Rsa.RSA_size(rsa))</span><br><span class="line">  <span class="keyword">local</span> encrypted = ffi.new(<span class="string">&quot;unsigned char[?]&quot;</span>, size)</span><br><span class="line">  <span class="keyword">local</span> <span class="built_in">len</span> = Rsa.RSA_private_encrypt(#data, data, encrypted, rsa, RSA_PKCS1_PADDING)</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span> &lt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> ffi.<span class="built_in">string</span>(encrypted, <span class="built_in">len</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> foo</span><br></pre></td></tr></table></figure><p>test.lua中的两行关键代码可以引用到自己编写的rsa.lua代码</p><blockquote><p>– 搜索当前路径的代码，rsa.lua和test.lua在同一个目录，可以搜索到</p><p>package.path = “./?.lua;./?/init.lua;” .. package.path</p><p>– 加载rsa库</p><p>local rsa = require “rsa”</p></blockquote><p>如果希望把rsa.lua放到一个固定的目录，可以放在luajit的库目录<code>/usr/local/openresty/lualib/</code>下，比如我把rsa.lua放到<code>/usr/local/openresty/lualib/ljc/</code>下</p><blockquote><p>ls /usr/local/openresty/lualib/ljc/<br>rsa.lua</p></blockquote><p>在test.lua引用rsa.lua的方法是</p><blockquote><p>local rsa = require “ljc.rsa”</p></blockquote><p>这样test.lua就回去luajit默认的库目录下查找。</p><h3 id="c的动态库放哪里"><a href="#c的动态库放哪里" class="headerlink" title="c的动态库放哪里"></a>c的动态库放哪里</h3><p>rsa中使用的crypto库是放在<code>/usr/lib/x86_64-linux-gnu/libcrypt.so</code>。它可以是一个软链接文件</p><blockquote><p>lrwxrwxrwx 1 root root 35 Jun 18  2017 /usr/lib/x86_64-linux-gnu/libcrypt.so -&gt; /lib/x86_64-linux-gnu/libcrypt.so.1</p></blockquote><p>crypto的库放的位置，跟Linux系统的动态库加载机制有关系了。不是luajit的机制了。因此，只需要Linux系统上有着库就可以了。</p><p>Linux的动态库搜索顺序是：</p><ol><li>编译目标代码时指定的动态库搜索路径</li><li>环境变量LD_LIBRARY_PATH指定的动态库搜索路径</li><li>配置文件/etc/ld.so.conf中指定的动态库搜索路径</li><li>默认的动态库搜索路径/lib</li><li>默认的动态库搜索路径/usr/lib</li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>除了使用ffi作为中间层使用C的动态库，也可以直接编译一个C的动态库后，不需要ffi这个中间层就可以被lua脚本调用。这个就需要在编写这个C的动态库的时候，就按照符合lua的规范去实现了。cjson就是一个这样的库，它就放在目录/usr/local/openresty/lualib/下，名为cjson.so。</p><blockquote><p>ls /usr/local/openresty/lualib/cjson.so</p></blockquote><p>至于什么写一个类似cjson的库，可以参考<a href="https://medium.com/dev-genius/how-to-add-your-c-library-in-lua-46fd246f0fa8">https://medium.com/dev-genius/how-to-add-your-c-library-in-lua-46fd246f0fa8</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++对象的生命周期</title>
      <link href="../2021/02/28/c-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>../2021/02/28/c-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="关于函数声明返回值类型和函数返回对象类型的"><a href="#关于函数声明返回值类型和函数返回对象类型的" class="headerlink" title="关于函数声明返回值类型和函数返回对象类型的"></a>关于函数声明返回值类型和函数返回对象类型的</h2><p>函数返回声明的对象的类型有：</p><ul><li>值</li><li>左值引用</li><li>右值引用</li></ul><p>函数实际返回对象的类型：</p><ul><li>lvalue （左值）</li><li>prvalue （纯右值）</li><li>xvalue （将亡值）</li></ul><p>所谓的声明类型和实际返回类型的例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A&amp; <span class="title">func_lref_lvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述的例子中，声明的对象的类型是:<strong>左值引用</strong>；实际返回的类型是：<strong>lvalue</strong></p><p>根据声明的类型和实际返回类型，组合后的结果为：</p><table><thead><tr><th>声明/实际</th><th>lvalue</th><th>prvalue</th><th>xvalue</th></tr></thead><tbody><tr><td>值</td><td>通过编译</td><td>通过编译</td><td>通过编译</td></tr><tr><td>左值引用</td><td>通过编译</td><td>不通过编译</td><td>不通过编译</td></tr><tr><td>右值引用</td><td>不通过编译</td><td>通过编译</td><td>通过编译</td></tr></tbody></table><p>根据组合的结果得出如下结论：</p><ul><li>左值引用只能被左值绑定。lvalue就是左值。</li><li>右值引用只能被右值绑定。prvalue和xvalue都是属于右值。</li></ul><p>测试的代码如下：</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">func_value_lvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">func_lref_lvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个函数是编译不了的</span></span><br><span class="line"><span class="comment">A&amp;&amp; func_rref_lvaue() &#123;</span></span><br><span class="line"><span class="comment">    A a&#123;&#125;;</span></span><br><span class="line"><span class="comment">    return a;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">func_value_prvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数编译不了</span></span><br><span class="line"><span class="comment">/*A&amp; func_lref_prvalue() &#123;</span></span><br><span class="line"><span class="comment">    return A();</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">A&amp;&amp; <span class="title">func_rref_prvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">func_value_xvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::move(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数编译不了</span></span><br><span class="line"><span class="comment">/*A&amp; func_lref_xvalue() &#123;</span></span><br><span class="line"><span class="comment">    A a&#123;&#125;;</span></span><br><span class="line"><span class="comment">    return std::move(a);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">A&amp;&amp; <span class="title">func_rref_xvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::move(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    </div></div><h2 id="关于对象周期的延长"><a href="#关于对象周期的延长" class="headerlink" title="关于对象周期的延长"></a>关于对象周期的延长</h2><p>所谓的对象生命周期延长，一般是在函数调用者和被调用者的关系中，讨论被调用者内部返回的对象的生命周期。</p><p> 比如, 下面的例子中func_value_lvalue被调用后，对象a就会被销毁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">func_value_lvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func_value_lvalue();</span><br></pre></td></tr></table></figure><p>但是另外一个例子，返回的返回值绑定到一个变量后，生命周期就会被延长了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">func_value_lvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A tmp = func_value_lvalue();</span><br></pre></td></tr></table></figure><p>根据上一节所提及的，函数声明类型和实际返回类型的讨论中，有如下六种函数可以声明（定义）</p><ul><li>声明为值类型，实际为lvalue</li><li>声明为值类型，实际为prvalue</li><li>声明为值类型，实际为xvalue</li><li>声明为左值引用，实际为lvalue</li><li>声明为右值引用，实际为prvalue</li><li>声明为右值引用，实际为xvalue</li></ul><table><thead><tr><th>函数定义/调用绑定</th><th>值</th><th>左值引用</th><th>右值引用</th></tr></thead><tbody><tr><td>声明为值类型，实际为lvalue</td><td>延长</td><td>延长</td><td>延长</td></tr><tr><td>声明为值类型，实际为prvalue</td><td>延长</td><td>编译不通过</td><td>延长</td></tr><tr><td>声明为值类型，实际为xvalue</td><td>move</td><td>编译不通过</td><td>move</td></tr><tr><td>声明为左值引用，实际为lvalue</td><td>无延长</td><td>无延长</td><td>编译不通过</td></tr><tr><td>声明为右值引用，实际为prvalue</td><td>无延长</td><td>编译不通过</td><td>无延长</td></tr><tr><td>声明为右值引用，实际为xvalue</td><td>无延长</td><td>编译不通过</td><td>无延长</td></tr></tbody></table><p>组合值的解析：</p><ul><li>延长：被调用函数内栈生成的对象，在函数调用结束后声明周期得到了延长，调用者可以拿到栈上的对象。后面对象的生命周期由调用者维护。</li><li>move：虽然被调用者栈上的对象在函数调用后销毁了，但是在销毁前通过移动构造函数，可以把对象引用的资源所有权移交给调用者，达到资源也可以给调用者的目的。</li><li>编译不通过：这种组合是不通过编译的，比如函数声明返回值为左值引用，就不能被绑定到一个右值引用的变量上。</li><li>无延长：被调用函数内栈生成的对象，在函数调用结束后就被释放了，调用者拿到的是一个无效的对象，有可能导致段错误（或拿到已释放的资源）等不可定义为错误。</li></ul><p>根据上述组合的结果得出如下结论：</p><ul><li>如果函数声明为引用类型，无论是左值引用还是右值引用，对象的声明周期都要被调用者维护的。</li><li>函数声明为值类型，能够通过编译的，栈上分配的资源都可以有效的传递给调用者，无论是通过延长生命周期还是move语言实现资源的移转的。</li></ul><p>测试的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Constructor A() &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destructor ~A() &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A(<span class="keyword">const</span> A&amp; other): x&#123;other.x&#125; &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy constructor A(const A&amp; other)&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> A&amp; other) &#123;</span><br><span class="line">        x = other.x;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy assignment operator =(const A&amp; other)&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A(A&amp;&amp; other):x&#123;other.x&#125; &#123;</span><br><span class="line">        other.x = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move constructor A(A&amp;&amp; other)&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A&amp; <span class="keyword">operator</span> = (A&amp;&amp; other) &#123;</span><br><span class="line">        x = other.x;</span><br><span class="line">        other.x = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move Assignment A(A&amp;&amp; other)&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">func_value_lvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">func_lref_lvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个函数是编译不了的</span></span><br><span class="line"><span class="comment">A&amp;&amp; func_rref_lvaue() &#123;</span></span><br><span class="line"><span class="comment">    A a&#123;&#125;;</span></span><br><span class="line"><span class="comment">    return a;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">func_value_prvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数编译不了</span></span><br><span class="line"><span class="comment">/*A&amp; func_lref_prvalue() &#123;</span></span><br><span class="line"><span class="comment">    return A();</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">A&amp;&amp; <span class="title">func_rref_prvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">func_value_xvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::move(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数编译不了</span></span><br><span class="line"><span class="comment">/*A&amp; func_lref_xvalue() &#123;</span></span><br><span class="line"><span class="comment">    A a&#123;&#125;;</span></span><br><span class="line"><span class="comment">    return std::move(a);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">A&amp;&amp; <span class="title">func_rref_xvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::move(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这种情况，编译器会做优化NRVO，直接在调用者的栈上分配内存，因此，下面案例的输出为：</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before：Value, Value, lValue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        A tmp = func_value_lvalue();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After：Value, Value, lValue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//Before：Value, Value, lValue</span></span><br><span class="line">        <span class="comment">//Constructor A() 0x7ffee2444698</span></span><br><span class="line">        <span class="comment">//After：Value, Value, lValue</span></span><br><span class="line">        <span class="comment">//Destructor ~A() 0x7ffee2444698</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 函数返回定义的是值类型，返回的值只能绑定到const left ref</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;lref, Value, lValue(Not Allowed)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//A&amp; tmp = func_value_lvalue();</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before： const lref, Value, lValue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">const</span> A&amp; tmp = func_value_lvalue();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After：const lref, Value, lValue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//lref, Value, lValue(Not Allowed)</span></span><br><span class="line">        <span class="comment">//Before： const lref, Value, lValue</span></span><br><span class="line">        <span class="comment">//Constructor A() 0x7ffee2444678</span></span><br><span class="line">        <span class="comment">//After：const lref, Value, lValue</span></span><br><span class="line">        <span class="comment">//Destructor ~A() 0x7ffee2444678</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 函数内部的</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before rref, value, lvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        A&amp;&amp; tmp = func_value_lvalue();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After rref, value, lvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//Before rref, value, lvalue</span></span><br><span class="line">        <span class="comment">//Constructor A() 0x7ffee2444668</span></span><br><span class="line">        <span class="comment">//After rref, value, lvalue</span></span><br><span class="line">        <span class="comment">//Destructor ~A() 0x7ffee2444668</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 这个操作是有问题的，引用虽然能绑定到值上，但是引用绑定前，func_rref_lvalue的对象早就释放了</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before: value, lref, lvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        A tmp = func_lref_lvalue();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After: value, lref, lvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//Before: value, lref, lvalue</span></span><br><span class="line">        <span class="comment">//Constructor A() 0x7ffee24444b8</span></span><br><span class="line">        <span class="comment">//Destructor ~A() 0x7ffee24444b8</span></span><br><span class="line">        <span class="comment">//Copy constructor A(const A&amp; other)0x7ffee2444660</span></span><br><span class="line">        <span class="comment">//After: value, lref, lvalue</span></span><br><span class="line">        <span class="comment">//Destructor ~A() 0x7ffee2444660</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 这个操作也是有问题的，func_lref_lvalue 的对象早就释放了</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before: lref, lref, lvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        A&amp; tmp = func_lref_lvalue();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After: lref, lref, lvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//Before: lref, lref, lvalue</span></span><br><span class="line">        <span class="comment">//Constructor A() 0x7ffee24444b8</span></span><br><span class="line">        <span class="comment">//Destructor ~A() 0x7ffee24444b8</span></span><br><span class="line">        <span class="comment">//After: lref, lref, lvalue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// 这个操作也是有问题的，func_lref_lvalue 的对象早就释放了</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;Before: lref, lref, lvalue&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// 编译不了</span></span><br><span class="line">        <span class="comment">//A&amp;&amp; tmp = func_lref_lvalue();</span></span><br><span class="line">       <span class="comment">// cout &lt;&lt; &quot;After: lref, lref, lvalue&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 这个操作也是有问题的，func_rref_lvalue的对象早就释放了</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before: value, rref, prvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        A tmp = func_rref_prvalue();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After: value, rref, prvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//Before: value, rref, prvalue</span></span><br><span class="line">        <span class="comment">//Constructor A() 0x7ffee24444b8</span></span><br><span class="line">        <span class="comment">//Destructor ~A() 0x7ffee24444b8</span></span><br><span class="line">        <span class="comment">//Move constructor A(A&amp;&amp; other)0x7ffee2444650</span></span><br><span class="line">        <span class="comment">//After: value, rref, prvalue</span></span><br><span class="line">        <span class="comment">//Destructor ~A() 0x7ffee2444650</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    &#123;    不能通过编译</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; &quot;Before: lvalue, rref, prvalue&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//        A&amp; tmp = func_rref_prvalue();</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; &quot;After: value, rref, prvalue&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 这个操作也是有问题的， func_rref_prvalue返回时对象就销毁了</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before: rref, rref, prvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        A&amp;&amp; tmp = func_rref_prvalue();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After: rref, rref, prvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//Before: rref, rref, prvalue</span></span><br><span class="line">        <span class="comment">//Constructor A() 0x7ffee24444b8</span></span><br><span class="line">        <span class="comment">//Destructor ~A() 0x7ffee24444b8</span></span><br><span class="line">        <span class="comment">//After: rref, rref, prvalue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 这个操作有问题，func_rref_xvalue 返回时对象就销毁了</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before: value, rref, xvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        A tmp = func_rref_xvalue();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After: value, rref, xvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// Before: value, rref, xvalue</span></span><br><span class="line">        <span class="comment">//Constructor A() 0x7ffee24444b8</span></span><br><span class="line">        <span class="comment">//Destructor ~A() 0x7ffee24444b8</span></span><br><span class="line">        <span class="comment">//Move constructor A(A&amp;&amp; other)0x7ffee2444640</span></span><br><span class="line">        <span class="comment">//After: value, rref, xvalue</span></span><br><span class="line">        <span class="comment">//Destructor ~A() 0x7ffee2444640</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// 不能通过编译</span></span><br><span class="line">       <span class="comment">// A&amp; tmp = func_rref_xvalue();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 这个操作有问题，func_rref_xvalue 返回时对象就销毁了</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before: rref, rref, xvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        A&amp;&amp; tmp = func_rref_xvalue();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After: rref, rref, xvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//Before: rref, rref, xvalue</span></span><br><span class="line">        <span class="comment">//Constructor A() 0x7ffee24444b8</span></span><br><span class="line">        <span class="comment">//Destructor ~A() 0x7ffee24444b8</span></span><br><span class="line">        <span class="comment">//After: rref, rref, xvalue</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before: value, value, prvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        A tmp = func_value_prvalue();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After: value, value, prvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 输出如下</span></span><br><span class="line">        <span class="comment">//Before: value, value, prvalue</span></span><br><span class="line">        <span class="comment">//Constructor A() 0x7ffee0c19630</span></span><br><span class="line">        <span class="comment">//After: value, value, prvalue</span></span><br><span class="line">        <span class="comment">//Destructor ~A() 0x7ffee0c19630</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        <span class="comment">//A &amp;tmp = func_value_prvalue();</span></span><br><span class="line">        <span class="comment">//A&amp; tmp = func_value_xvalue();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before: rref, value, prvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        A&amp;&amp; tmp = func_value_prvalue();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After: rref, value, prvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="comment">//Before: rref, value, prvalue</span></span><br><span class="line">        <span class="comment">//Constructor A() 0x7ffee3d18620</span></span><br><span class="line">        <span class="comment">//After: rref, value, prvalue</span></span><br><span class="line">        <span class="comment">//Destructor ~A() 0x7ffee3d18620</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before: value, value, xvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        A tmp = func_value_xvalue();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After: value, value, xvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="comment">//Before: rref, value, xvalue</span></span><br><span class="line">        <span class="comment">//Constructor A() 0x7ffee35e2430</span></span><br><span class="line">        <span class="comment">//Move constructor A(A&amp;&amp; other)0x7ffee35e2618</span></span><br><span class="line">        <span class="comment">//Destructor ~A() 0x7ffee35e2430</span></span><br><span class="line">        <span class="comment">//After: rref, value, xvalue</span></span><br><span class="line">        <span class="comment">//Destructor ~A() 0x7ffee35e2618</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Before: rref, value, xvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        A &amp;&amp;tmp = func_value_xvalue();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After: rref, value, xvalue&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="再讨论对象生命周期延长"><a href="#再讨论对象生命周期延长" class="headerlink" title="再讨论对象生命周期延长"></a>再讨论对象生命周期延长</h2><p>C++中默认所有的变量都是值的类型。除了引用和指针，任何对象的传递都会触发对象的构造（除非编译器优化了）。另外C++中移动语义是为了减少占用内存空间或者资源创建耗时的对象而存在的，被移动后原有对象对资源的所有权应该没了（指针应该置为nullptr，fd置为-1等，释放所有权，免得析构函数被调用的时候，把资源给释放掉了）</p><p>对象生命周期的延长，其实就是被调用者上生成的对象，其内存地址是属于调用者的栈的。这样就可以达到，不使用拷贝构造函数就可以把被调用者上的对象（包括其拥有的资源）移转到调用者的变量上。生命周期延长是编译器做的，目的就是优化代码，减少拷贝构造函数的调用。这种优化就叫NRVO。</p><p>以下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Constructor A() &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destructor ~A() &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A(<span class="keyword">const</span> A&amp; other): x&#123;other.x&#125; &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy constructor A(const A&amp; other)&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> A&amp; other) &#123;</span><br><span class="line">        x = other.x;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy assignment operator =(const A&amp; other)&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A(A&amp;&amp; other):x&#123;other.x&#125; &#123;</span><br><span class="line">        other.x = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move constructor A(A&amp;&amp; other)&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A&amp; <span class="keyword">operator</span> = (A&amp;&amp; other) &#123;</span><br><span class="line">        x = other.x;</span><br><span class="line">        other.x = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move Assignment A(A&amp;&amp; other)&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">func_A_ref</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line">  A a;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fuction frame is &quot;</span> &lt;&lt; &amp;c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main frmae is &quot;</span> &lt;&lt; &amp;c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;before call func_A_ref&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  A a = func_A_ref();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after call func_A_ref&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  A dumb&#123;&#125;;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;dumb address is &quot;</span> &lt;&lt; &amp;dumb &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常编译<code>clang++ --std=c++11 test.cc</code>后，输出为,可以看出func_A_ref函数中的对象a的地址是0x7ffd08d0a5c8，是属于main函数栈上的，编译器优化了，减少拷贝构造函数的调用。（栈的增长是从高地址到低地址的）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main frmae is 0x7fffb4f1c188</span><br><span class="line">before call func_A_ref</span><br><span class="line">Constructor A() 0x7fffb4f1c180</span><br><span class="line">fuction frame is 0x7fffb4f1c10c</span><br><span class="line">after call func_A_ref</span><br><span class="line">Constructor A() 0x7fffb4f1c170</span><br><span class="line">dumb address is 0x7fffb4f1c170</span><br><span class="line">Destructor ~A() 0x7fffb4f1c170</span><br><span class="line">Destructor ~A() 0x7fffb4f1c180</span><br></pre></td></tr></table></figure><p>如果禁止延长生命周期的优化后编译：<code>clang++ --std=c++11 -fno-elide-constructors test.cc</code></p><p>输出为：(使用了移动语义，而不是使用NRVO)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main frmae is 0x7ffe074bad88</span><br><span class="line">before call func_A_ref</span><br><span class="line">Constructor A() 0x7ffe074bacf8</span><br><span class="line">fuction frame is 0x7ffe074bacfc</span><br><span class="line">Move constructor A(A&amp;&amp; other)0x7ffe074bad78</span><br><span class="line">Destructor ~A() 0x7ffe074bacf8</span><br><span class="line">Move constructor A(A&amp;&amp; other)0x7ffe074bad80</span><br><span class="line">Destructor ~A() 0x7ffe074bad78</span><br><span class="line">after call func_A_ref</span><br><span class="line">Constructor A() 0x7ffe074bad68</span><br><span class="line">dumb address is 0x7ffe074bad68</span><br><span class="line">Destructor ~A() 0x7ffe074bad68</span><br><span class="line">Destructor ~A() 0x7ffe074bad80</span><br></pre></td></tr></table></figure><h2 id="编译器会尝试使用移动构造，而不是拷贝构造"><a href="#编译器会尝试使用移动构造，而不是拷贝构造" class="headerlink" title="编译器会尝试使用移动构造，而不是拷贝构造"></a>编译器会尝试使用移动构造，而不是拷贝构造</h2><p>下面的代码，编译器不能执行NRVO，因为存在分支判断的代码，因此编译器最多的优化到的程度就是使用移动构造函数代替拷贝构造函数，当然也是要类定义了移动构造函数才行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">A <span class="title">func_A_ref</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line">  A a1, a2;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fuction frame is &quot;</span> &lt;&lt; &amp;c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// 有分支判断的情况，编译器不能进行NRVO优化的，因此需要进行构造。存在移动构造函数，就优先使用移动构造函数</span></span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> a1;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> a2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main frmae is &quot;</span> &lt;&lt; &amp;c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;before call func_A_ref&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  A a = func_A_ref();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after call func_A_ref&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main frmae is 0x7ffe1368eb1c</span><br><span class="line">before call func_A_ref</span><br><span class="line">Constructor A(): 0x7ffe1368eae8</span><br><span class="line">Constructor A(): 0x7ffe1368eae4</span><br><span class="line">fuction frame is 0x7ffe1368eaec</span><br><span class="line">Move Constructor: 0x7ffe1368eb18</span><br><span class="line">Destructor: 0x7ffe1368eae4</span><br><span class="line">Destructor: 0x7ffe1368eae8</span><br><span class="line">after call func_A_ref</span><br><span class="line">Destructor: 0x7ffe1368eb18</span><br></pre></td></tr></table></figure><h2 id="std-move-好心干坏事——禁止了NRVO"><a href="#std-move-好心干坏事——禁止了NRVO" class="headerlink" title="std::move 好心干坏事——禁止了NRVO"></a>std::move 好心干坏事——禁止了NRVO</h2><p>std::move的会把一个prvalue变成一个xvalue，但是NRVO只是针对prvalue的，因此如果我们在函数返回的时候，把一个prvalue编程了一个xvalue，最多能优化到使用移动构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">A func_A_ref() &#123;</span><br><span class="line">  int c &#x3D; 10;</span><br><span class="line">  cout &lt;&lt; &quot;fuction frame is &quot; &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">  A a;</span><br><span class="line">  return std::move(a); &#x2F;&#x2F;本来NRVO可以优化掉一个移动构造函数的，因为std::move(a)后变成了一个xvalue</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int c &#x3D; 0;</span><br><span class="line">  cout &lt;&lt; &quot;main frmae is &quot; &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; &quot;before call func_A_ref&quot; &lt;&lt; endl;</span><br><span class="line">  A a &#x3D; func_A_ref();</span><br><span class="line">  cout &lt;&lt; &quot;after call func_A_ref&quot; &lt;&lt; endl; </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main frmae is 0x7fff3a19c56c</span><br><span class="line">before call func_A_ref</span><br><span class="line">fuction frame is 0x7fff3a19c53c</span><br><span class="line">Constructor A(): 0x7fff3a19c538</span><br><span class="line">Move Constructor: 0x7fff3a19c568 &#x2F;&#x2F;多了一个移动构造函数</span><br><span class="line">Destructor: 0x7fff3a19c538</span><br><span class="line">after call func_A_ref</span><br><span class="line">Destructor: 0x7fff3a19c568</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>terraform的详细使用文档</title>
      <link href="../2021/02/28/terraform%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/"/>
      <url>../2021/02/28/terraform%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="terraform的使用"><a href="#terraform的使用" class="headerlink" title="terraform的使用"></a>terraform的使用</h2><ul><li>资源相关的概念<ul><li>provider: 基础设施资源的提供者，比如kong、aws的相关配置。描述的是如何访问该资源。</li><li>plugin：插件，每个云服务都可以抽象成一个插件</li><li>resource：基础设施提供出来的资源，比如kong提供的资源有service、route、consumer等等</li><li>data_source ：data source是获取基础设施的资源相关信息，比如aws有哪些机房，机房的id是什么。那么配置文件就可以动态地获取机房的id，不用修改配置文件。</li><li>state：kong的状态信息，描述的是基础设施已存在的资源，terraform根据状态信息对资源的生命周期进行管理。</li><li>backend：存储state文件的存储介质，可以是本地的文件系统，也可以是s3等外置存储。</li><li>module：模块，terraform的资源可以模块化，然后进行导入。</li></ul></li><li>操作相关的概念<ul><li>init ：初始化项目，backend的初始化以及module的导入</li><li>apply: 应用配置文件，相当于将配置文件的描述的资源部署到真实环境</li><li>plan： 查看如果要执行部署（apply），将会产生什么变化，用来查看部署后的变化，但不会真正执行部署</li><li>destroy：删除已经部署的资源。</li><li>import：导入当前已经存在的资源，可以用来state文件丢失或者之前不是使用terraform部署的资源导入，然后terraform就可以对这些资源进行管理。</li></ul></li><li>hello world  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  access_key &#x3D; &quot;ACCESS_KEY_HERE&quot;</span><br><span class="line">  secret_key &#x3D; &quot;SECRET_KEY_HERE&quot;</span><br><span class="line">  region     &#x3D; &quot;us-east-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  ami           &#x3D; &quot;ami-2757f631&quot;</span><br><span class="line">  instance_type &#x3D; &quot;t2.micro&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  示例中，provider的名字叫aws，terraform就会去加载aws这个插件，然后对插件进行初始化，初始化的输入有：access_key、secret_key、和region三个值。初始化完后，就会创建一个资源，这个资源是aws提供的aws_instance，然后输入ami和instance_type这两个值。执行terraform apply完成部署。</li><li>一个demo的部署列子（demo-SDK）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  backend &quot;s3&quot; &#123;</span><br><span class="line">    endpoint &#x3D; &quot;s3.foo.example.com&quot;</span><br><span class="line">    bucket &#x3D; &quot;hdg3-terraform-state-test&quot;</span><br><span class="line">    access_key &#x3D; &quot;************************&quot;</span><br><span class="line">    secret_key &#x3D; &quot;*************************&quot;</span><br><span class="line">    key    &#x3D; &quot;demo-terraform.tfstate&quot;</span><br><span class="line">    region &#x3D; &quot;us-west-1&quot;</span><br><span class="line">    skip_requesting_account_id &#x3D; true</span><br><span class="line">    skip_credentials_validation &#x3D; true</span><br><span class="line">    skip_get_ec2_platforms &#x3D; true</span><br><span class="line">    skip_metadata_api_check &#x3D; true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;kong&quot; &#123;</span><br><span class="line">    kong_admin_uri  &#x3D; &quot;http:&#x2F;&#x2F;someIP:8001&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;kong_service&quot; &quot;service_foo_external&quot; &#123;</span><br><span class="line">    name        &#x3D; &quot;foo_external&quot;</span><br><span class="line">    protocol    &#x3D; &quot;http&quot;</span><br><span class="line">    host        &#x3D; &quot;5.5.5.5&quot;</span><br><span class="line">    port        &#x3D; 8888</span><br><span class="line">    path        &#x3D; &quot;&#x2F;&quot;</span><br><span class="line">    retries     &#x3D; 5</span><br><span class="line">    connect_timeout &#x3D; 1000</span><br><span class="line">    write_timeout   &#x3D; 2000</span><br><span class="line">    read_timeout    &#x3D; 3000</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;kong_service&quot; &quot;service_foo_internal&quot; &#123;</span><br><span class="line">    name        &#x3D; &quot;foo_internal&quot;</span><br><span class="line">    protocol    &#x3D; &quot;http&quot;</span><br><span class="line">    host        &#x3D; &quot;7.7.7.7&quot;</span><br><span class="line">    port        &#x3D; 8888</span><br><span class="line">    path        &#x3D; &quot;&#x2F;&quot;</span><br><span class="line">    retries     &#x3D; 5</span><br><span class="line">    connect_timeout &#x3D; 1000</span><br><span class="line">    write_timeout   &#x3D; 2000</span><br><span class="line">    read_timeout    &#x3D; 3000</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;kong_service&quot; &quot;service_foo_ext_options&quot; &#123;</span><br><span class="line">    name        &#x3D; &quot;foo_external_options&quot;</span><br><span class="line">    protocol    &#x3D; &quot;http&quot;</span><br><span class="line">    host        &#x3D; &quot;6.6.6.6&quot;</span><br><span class="line">    port        &#x3D; 8888</span><br><span class="line">    path        &#x3D; &quot;&#x2F;&quot;</span><br><span class="line">    retries     &#x3D; 5</span><br><span class="line">    connect_timeout &#x3D; 1000</span><br><span class="line">    write_timeout   &#x3D; 2000</span><br><span class="line">    read_timeout    &#x3D; 3000</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;kong_route&quot; &quot;foo_external_route&quot; &#123;</span><br><span class="line">    protocols   &#x3D; [ &quot;http&quot; ]</span><br><span class="line">    methods     &#x3D; [ &quot;GET&quot;, &quot;POST&quot; , &quot;PUT&quot;, &quot;DELETE&quot;]</span><br><span class="line">    hosts       &#x3D; [ &quot;fooagw.foo.example.com&quot; ]</span><br><span class="line">    paths       &#x3D; [ &quot;&#x2F;foo&#x2F;demo&#x2F;v1&#x2F;api&quot; ]</span><br><span class="line">    strip_path  &#x3D; true</span><br><span class="line">    preserve_host   &#x3D; true</span><br><span class="line">    service_id  &#x3D; &quot;$&#123;kong_service.service_foo_external.id&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;kong_route&quot; &quot;foo_internal_route&quot; &#123;</span><br><span class="line">    protocols   &#x3D; [ &quot;http&quot;]</span><br><span class="line">    methods     &#x3D; [ &quot;GET&quot;, &quot;POST&quot; , &quot;PUT&quot;, &quot;DELETE&quot;]</span><br><span class="line">    hosts       &#x3D; [ &quot;fooagw-in.foo.example.com&quot; ]</span><br><span class="line">    paths       &#x3D; [ &quot;&#x2F;foo&#x2F;demo&#x2F;v1&#x2F;api&quot; ]</span><br><span class="line">    strip_path  &#x3D; true</span><br><span class="line">    preserve_host   &#x3D; true</span><br><span class="line">    service_id  &#x3D; &quot;$&#123;kong_service.service_foo_internal.id&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;kong_route&quot; &quot;foo_external_options_route&quot; &#123;</span><br><span class="line">    protocols   &#x3D; [ &quot;http&quot;]</span><br><span class="line">    methods     &#x3D; [ &quot;OPTIONS&quot;]</span><br><span class="line">    hosts       &#x3D; [ &quot;fooagw.foo.example.com&quot; ]</span><br><span class="line">    paths       &#x3D; [ &quot;&#x2F;foo&#x2F;demo&#x2F;v1&#x2F;api&quot; ]</span><br><span class="line">    strip_path  &#x3D; true</span><br><span class="line">    preserve_host   &#x3D; true</span><br><span class="line">    service_id  &#x3D; &quot;$&#123;kong_service.service_foo_ext_options.id&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">resource &quot;kong_plugin&quot; &quot;hmac_foo_external&quot; &#123;</span><br><span class="line">    name &#x3D; &quot;hmac-auth&quot;</span><br><span class="line"></span><br><span class="line">    service_id  &#x3D; &quot;$&#123;kong_service.service_foo_external.id&#125;&quot;</span><br><span class="line"></span><br><span class="line">    config &#x3D; &#123;</span><br><span class="line">        &quot;clock_skew&quot; &#x3D; 300,</span><br><span class="line">        &quot;algorithms&quot; &#x3D; &quot;hmac-sha256&quot;</span><br><span class="line">        &quot;validate_request_body&quot; &#x3D; &quot;true&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;kong_consumer&quot; &quot;demo&quot; &#123;</span><br><span class="line">    username &#x3D; &quot;demo&quot; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;kong_consumer_plugin_config&quot; &quot;demo_hamc_credential&quot; &#123;</span><br><span class="line">    consumer_id &#x3D; &quot;$&#123;kong_consumer.demo.id&#125;&quot;</span><br><span class="line">    plugin_name &#x3D; &quot;hmac-auth&quot;</span><br><span class="line">    config_json &#x3D; &quot;&#123;\&quot;username\&quot;:\&quot;demo-foo\&quot;, \&quot;secret\&quot;: \&quot;demokey\&quot;&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;kong_plugin&quot; &quot;auth_foo_external&quot; &#123;</span><br><span class="line">    name &#x3D; &quot;auth&quot;</span><br><span class="line">    service_id &#x3D; &quot;$&#123;kong_service.service_foo_external.id&#125;&quot;</span><br><span class="line"></span><br><span class="line">    config &#x3D; &#123;</span><br><span class="line">        &quot;token_header&quot; &#x3D; &quot;x-some-token&quot;</span><br><span class="line">        &quot;parse_token&quot; &#x3D; &quot;false&quot;</span><br><span class="line"></span><br><span class="line">        &quot;keys_to_headers&quot; &#x3D; &quot;true&quot;</span><br><span class="line">        &quot;keys_to_headers_dict&quot; &#x3D; &quot;&#123;\&quot;role\&quot; : \&quot;x-role\&quot;&#125;&quot;</span><br><span class="line"></span><br><span class="line">        &quot;ext_service_auth&quot; &#x3D; &quot;true&quot;</span><br><span class="line">        &quot;ext_service_auth_path&quot; &#x3D; &quot;8.8.8.8:8080&#x2F;identify&quot;</span><br><span class="line">        &quot;ext_service_auth_type&quot; &#x3D; &quot;http&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">resource &quot;kong_plugin&quot; &quot;ip-restriction_foo_internal&quot; &#123;</span><br><span class="line">    name &#x3D; &quot;ip-restriction&quot;</span><br><span class="line">    service_id &#x3D; &quot;$&#123;kong_service.service_foo_internal.id&#125;&quot;</span><br><span class="line">    config &#x3D; &#123;</span><br><span class="line">        &quot;whitelist&quot; &#x3D; &quot;10.0.0.1&#x2F;8&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>此配置文件声明，将state保存在S3存储上，s3存储的访问的控制就写在配置文件里。有了这一份文件，我们就可以在任意的控制机上控制kong节点的配置。provider kong里面的url指明的是如何访问到kong节点的admin api入口。后续的是跟ngsocial-SDK业务相关的配置。</p><h2 id="变量的输入和输出"><a href="#变量的输入和输出" class="headerlink" title="变量的输入和输出"></a>变量的输入和输出</h2><p>一些秘钥等敏感信息可以不放在配置文件里面，不用进行版本管理。可以在执行命令的时候输入，或者也可以在一个配置文件里定义，但是这个配置文件不会放在版本管理工具里公开。<br>变量的输出可以用于获取感兴趣的变量，用于用户管理资源。</p><h3 id="变量的输入"><a href="#变量的输入" class="headerlink" title="变量的输入"></a>变量的输入</h3><p>terraform默认会从本地目录的terraform.tfvars读取变量的值，因此我们可以在<strong>terraform.<em>tfvars</em></strong>里面定义好变量的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">amis &#x3D; &#123;</span><br><span class="line">    &quot;us-east-1&quot; &#x3D; &quot;ami-2757f631&quot;</span><br><span class="line">    &quot;us-west-2&quot; &#x3D; &quot;ami-def456&quot;</span><br><span class="line">&#125;</span><br><span class="line">access_key &#x3D; &quot;AKIAJPC3************&quot;</span><br><span class="line">secret_key &#x3D; &quot;8ocYIxwBi8wK9azxy8g****************&quot;</span><br></pre></td></tr></table></figure><p>在.tf文件定义可以是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">lijiancai@lijiancai:~&#x2F;terra$ cat terraform.tfvars</span><br><span class="line">amis &#x3D; &#123;</span><br><span class="line">  &quot;us-east-1&quot; &#x3D; &quot;ami-2757f631&quot;</span><br><span class="line">  &quot;us-west-2&quot; &#x3D; &quot;ami-def456&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">access_key &#x3D; &quot;AKIAJPC3************&quot;</span><br><span class="line">secret_key &#x3D; &quot;8ocYIxwBi8wK9azxy8g****************&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lijiancai@lijiancai:~&#x2F;terra$ cat aws_ec2.tf</span><br><span class="line">variable &quot;region&quot; &#123;&#125;</span><br><span class="line">variable &quot;amis&quot; &#123;</span><br><span class="line">  type &#x3D; &quot;map&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;access_key&quot; &#123;&#125;</span><br><span class="line">variable &quot;secret_key&quot; &#123;&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  access_key &#x3D; &quot;$&#123;var.access_key&#125;&quot;</span><br><span class="line">  secret_key &#x3D; &quot;$&#123;var.secret_key&#125;&quot;</span><br><span class="line">  region     &#x3D; &quot;$&#123;var.region&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  ami           &#x3D; &quot;$&#123;lookup(var.amis,var.region)&#125;&quot;</span><br><span class="line">  instance_type &#x3D; &quot;t2.micro&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：在terraform.tfvars里面赋值的变量，必须在.tf文件里面有声明，要使用variable关键字声明</p><p>运行apply的时候传入region的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply -var region&#x3D;us-east-1</span><br></pre></td></tr></table></figure><h3 id="变量的输出"><a href="#变量的输出" class="headerlink" title="变量的输出"></a>变量的输出</h3><ol><li>定义一个tf文件：output.tf <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output &quot;ip&quot; &#123;</span><br><span class="line">       value &#x3D; &quot;$&#123;aws_instance.example.public_ip&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li>应用后的输出：<blockquote><pre><code>lijiancai@lijiancai:~/terra$ terraform apply -var region=us-east-1aws_instance.example: Refreshing state... (ID: i-01cb39074dfba6167)Apply complete! Resources: 0 added, 0 changed, 0 destroyed.Outputs:ip = 54.205.97.129</code></pre></blockquote></li></ol><h2 id="terraform的语法"><a href="#terraform的语法" class="headerlink" title="terraform的语法"></a>terraform的语法</h2><p>terraform支持两种声明语法，一种是HCL（HashiCorp Configuration Language），另外是一种是JSON。由于JSON的可读性较差，官方推荐使用HCL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># An AMI</span><br><span class="line">variable &quot;ami&quot; &#123;</span><br><span class="line">  description &#x3D; &quot;the AMI to use&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* A multi</span><br><span class="line">   line comment. *&#x2F;</span><br><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  ami               &#x3D; &quot;$&#123;var.ami&#125;&quot;</span><br><span class="line">  count             &#x3D; 2</span><br><span class="line">  source_dest_check &#x3D; false</span><br><span class="line"></span><br><span class="line">  connection &#123;</span><br><span class="line">    user &#x3D; &quot;root&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>单行备注，以#开头</li><li>多行备注, 用/* */包裹起来</li><li>赋值操作用=，key=value，中间的空格忽略</li><li>字符串用双引号括起来</li><li>变量的插入使用${var.foo}</li><li>多行的字符串插入可以使用here-doc语法</li><li>数字默认是十进制</li><li>布尔类型的值是true和false</li><li>list类型使用[] ,比如 [“GET”, “PUT”]</li><li>map类型使用{}, 比如 { “foo”: “bar”, “bar”: “baz” }</li></ul><h2 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型"></a>变量的类型</h2><ul><li>字符串string：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;key&quot; &#123;</span><br><span class="line">  type    &#x3D; &quot;string&quot;</span><br><span class="line">  default &#x3D; &quot;value&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;long_key&quot; &#123;</span><br><span class="line">  type &#x3D; &quot;string&quot;</span><br><span class="line">  default &#x3D; &lt;&lt;EOF</span><br><span class="line">This is a long key.</span><br><span class="line">Running over several lines.</span><br><span class="line">EOF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>字典map：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;images&quot; &#123;</span><br><span class="line">  type    &#x3D; &quot;map&quot;</span><br><span class="line">  default &#x3D; &#123;</span><br><span class="line">    &quot;us-east-1&quot; &#x3D; &quot;image-1234&quot;</span><br><span class="line">    &quot;us-west-2&quot; &#x3D; &quot;image-4567&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数组list：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;users&quot; &#123;</span><br><span class="line">  type    &#x3D; &quot;list&quot;</span><br><span class="line">  default &#x3D; [&quot;admin&quot;, &quot;ubuntu&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>布尔类型boolean：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;active&quot; &#123;</span><br><span class="line">  default &#x3D; false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值可以是true(“true”)和false(“false”)</p><ul><li>数字</li></ul><h2 id="变量的优先级"><a href="#变量的优先级" class="headerlink" title="变量的优先级"></a>变量的优先级</h2><ul><li>默认值：首先，变量可以使用之前需要声明，声明的时候可以赋一个默认的值：比如main.tf中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;kong&quot; &#123;</span><br><span class="line">    alias &#x3D; &quot;k2&quot;</span><br><span class="line">    kong_admin_uri  &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1:8001&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;test&quot; &#123;</span><br><span class="line">    default &#x3D; &quot;foo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &quot;test_output&quot; &#123;</span><br><span class="line">    value &#x3D; &quot;$&#123;var.test&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test的默认值设为了”foo”,因此执行terrform apply后，输出的test_output是foo</p><ul><li><p>环境变量：可以使用环境变量输入，改变变量的值：执行 <strong>TF_VAR_test=”bar” terraform apply</strong> 输出的test_output是bar。因此环境变量能够改变test的值。环境变量的优先级比默认值高。</p></li><li><p>变量定义（definition）文件：可以在当前的目录下，创建一个terraform.tfvars的文件,内容如下</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test &#x3D; &quot;ggggg&quot;</span><br></pre></td></tr></table></figure><p>执行 <strong>TF_VAR_test=”bar” terraform apply</strong> 输出的test_output是ggggg。因此变量定义文件的优先级比环境变量高。</p><ul><li>命令行参数–var：存在环境变量和变量定义文件的情况下，执行<strong>TF_VAR_test=”bar” terraform apply –var “test=abcd”</strong>,输出的test_output是abcd</li></ul><h2 id="变量的插入-interpolation"><a href="#变量的插入-interpolation" class="headerlink" title="变量的插入 interpolation"></a>变量的插入 interpolation</h2><ul><li>字符串：${var.foo}</li><li>map： 格式是 var.MAP[“KEY”] 例子${var.amis[“us-east-1”]}</li><li>list：”${var.LIST}”， 整个列表”${var.subnets}”，列表中的某一个： ${var.subnets[idx]}</li><li>其他资源的变量： ${var.subnets[idx]}， ${aws_instance.web.*.id}</li><li>data source中的变量：${aws_instance.web.*.id}， ${data.aws_subnet.example.0.cidr_block}</li><li>模块的输出：语法是 MODULE.NAME.OUTPUT， 例子 ${module.foo.bar} </li><li>Count information， 当前resource的编号${count.index}</li><li>Path information<br>The syntax is path.TYPE. TYPE can be cwd, module, or root. cwd will interpolate the current working directory. module will interpolate the path to the current module. root will interpolate the path of the root module. In general, you probably want the path.module variabl</li></ul><p>特殊用法：”${var.name_prefix != “” ? var.name_prefix : local.default_name_prefix}” 可以使用三目运算符决定变量的值。语法是CONDITION ? TRUEVAL : FALSEVAL，另外CONDITION中还支持的运算符还有：</p><blockquote><pre><code>Equality: == and !=Numerical comparison: &gt;, &lt;, &gt;=, &lt;=Boolean logic: &amp;&amp;, ||, unary !</code></pre></blockquote><h2 id="local-value的使用"><a href="#local-value的使用" class="headerlink" title="local value的使用"></a>local value的使用</h2><p>local value的使用，像是一个函数的功能，可以返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Ids for multiple sets of EC2 instances, merged together</span><br><span class="line">locals &#123;</span><br><span class="line">  instance_ids &#x3D; &quot;$&#123;concat(aws_instance.blue.*.id, aws_instance.green.*.id)&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># A computed default name prefix</span><br><span class="line">locals &#123;</span><br><span class="line">  default_name_prefix &#x3D; &quot;$&#123;var.project_name&#125;-web&quot;</span><br><span class="line">  name_prefix         &#x3D; &quot;$&#123;var.name_prefix !&#x3D; &quot;&quot; ? var.name_prefix : local.default_name_prefix&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Local values can be interpolated elsewhere using the &quot;local.&quot; prefix.</span><br><span class="line">resource &quot;aws_s3_bucket&quot; &quot;files&quot; &#123;</span><br><span class="line">  bucket &#x3D; &quot;$&#123;local.name_prefix&#125;-files&quot;</span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中，files这个资源的bucket的值，是根据local.name_prefix返回的</p><h2 id="resource-的语法"><a href="#resource-的语法" class="headerlink" title="resource 的语法"></a>resource 的语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resource TYPE NAME &#123;</span><br><span class="line">    CONFIG ...</span><br><span class="line">    [count &#x3D; COUNT]</span><br><span class="line">    [depends_on &#x3D; [NAME, ...]]</span><br><span class="line">    [provider &#x3D; PROVIDER]</span><br><span class="line"></span><br><span class="line">    [LIFECYCLE]</span><br><span class="line"></span><br><span class="line">    [CONNECTION]</span><br><span class="line">    [PROVISIONER ...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[]方括号部分是可选部分。</p><ul><li><p>provider用于multiprovider的使用。</p></li><li><p>depends_on是用于显式地指定依赖关系。terraform会根据变量的interpolation推导依赖关系，但是有的依赖关系通过配置文件推导不出来的话，需要显式地指定依赖关系。</p></li><li><p>LIFECYCLE</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lifecycle &#123;</span><br><span class="line">    prevent_destroy &#x3D; &quot;$true&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>prevent_destroy: 表示该资源只能创建，而不能销毁</li><li>ignore_changes ：用于忽略外部资源的动态变化，比如，有个资源的值在创建后会动态调整，为了不让kong认为该资源发生了变化，需要忽略</li><li>create_before_destroy：资源的销毁前，需要先创建。比如一个资源的属性修改，需要删除后再创建。</li></ul></li><li><p>PROVISIONER： 用于在本地或远端执行命令或配置</p></li><li><p>CONNECTION：表示某PROVISIONER如何访问到本地或远端</p></li><li><p>一个特殊的resource：null_resource</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;cluster&quot; &#123;</span><br><span class="line">  count &#x3D; 3</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;null_resource&quot; &quot;cluster&quot; &#123;</span><br><span class="line">  # Changes to any instance of the cluster requires re-provisioning</span><br><span class="line">  triggers &#123;</span><br><span class="line">    cluster_instance_ids &#x3D; &quot;$&#123;join(&quot;,&quot;, aws_instance.cluster.*.id)&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # Bootstrap script can run on any instance of the cluster</span><br><span class="line">  # So we just choose the first in this case</span><br><span class="line">  connection &#123;</span><br><span class="line">    host &#x3D; &quot;$&#123;element(aws_instance.cluster.*.public_ip, 0)&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  provisioner &quot;remote-exec&quot; &#123;</span><br><span class="line">    # Bootstrap script called with private_ip of each node in the clutser</span><br><span class="line">    inline &#x3D; [</span><br><span class="line">      &quot;bootstrap-cluster.sh $&#123;join(&quot; &quot;, aws_instance.cluster.*.private_ip)&#125;&quot;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个null_resource 不会创建任何的资源，但是有resource的所有语法支持。可以更细粒度的控制provisioner的执行，或者一些依赖的控制。</p><h2 id="provision的使用"><a href="#provision的使用" class="headerlink" title="provision的使用"></a>provision的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;kong&quot; &#123;</span><br><span class="line">    alias &#x3D; &quot;k2&quot;</span><br><span class="line">    kong_admin_uri  &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1:8001&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">resource &quot;kong_consumer&quot; &quot;test111&quot; &#123;</span><br><span class="line">    provider &#x3D; &quot;kong.k2&quot;</span><br><span class="line">    username&#x3D;&quot;test111&quot;</span><br><span class="line"></span><br><span class="line">    provisioner &quot;local-exec&quot; &#123;</span><br><span class="line">        command &#x3D; &quot;echo $&#123;self.username&#125; &gt; file.txt&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个资源kong_consumer的名字是test111，在创建资源后会执行provision:local-exec提供的的命令。默认provision是在resource创建（update是包括的，仅仅是creation的时候）的时候执行，不过也可以指定阶段。</p></li><li><p>执行阶段:包括creation和destroy。默认是creation。但是使用when关键字就可以指定执行阶段了</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  provisioner &quot;local-exec&quot; &#123;</span><br><span class="line">    command &#x3D; &quot;echo first&quot;</span><br><span class="line">    when &#x3D; &quot;destroy&quot;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>multiple provisioner：按照配置文件中定义的顺序执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  provisioner &quot;local-exec&quot; &#123;</span><br><span class="line">    command &#x3D; &quot;echo first&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  provisioner &quot;local-exec&quot; &#123;</span><br><span class="line">    command &#x3D; &quot;echo second&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>on_failure: 执行provisioner执行命令失败的行为，默认是失败终止执行（fail）。可以选择continue</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  provisioner &quot;local-exec&quot; &#123;</span><br><span class="line">    command    &#x3D; &quot;echo $&#123;self.private_ip&#125; &gt; file.txt&quot;</span><br><span class="line">    on_failure &#x3D; &quot;continue&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>connection： 使用本地执行的时候不需要connection，但是在远端执行命令的时候就需要了。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">provisioner &quot;file&quot; &#123;</span><br><span class="line">  source      &#x3D; &quot;conf&#x2F;myapp.conf&quot;</span><br><span class="line">  destination &#x3D; &quot;&#x2F;etc&#x2F;myapp.conf&quot;</span><br><span class="line"></span><br><span class="line">  connection &#123;</span><br><span class="line">    type     &#x3D; &quot;ssh&quot;</span><br><span class="line">    user     &#x3D; &quot;root&quot;</span><br><span class="line">    password &#x3D; &quot;$&#123;var.root_password&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>provisioner file有一个connection，拷贝愿意远端文件到本地<br>connection描述的是如何连接到远端机器，已经相关的credentials。<br>目前terraform提供放任provisioner有：</p><blockquote><pre><code>local-exec 本地执行命令file 文件的拷贝chef： 配置管理habitat：remote-exec(支持connection)：远程执行salt-masterless</code></pre><p>详见：<a href="https://www.terraform.io/docs/provisioners/index.html">https://www.terraform.io/docs/provisioners/index.html</a></p></blockquote><h2 id="multiple-provider"><a href="#multiple-provider" class="headerlink" title="multiple provider"></a>multiple provider</h2><p>可以用于一个配置文件里面有多个provider</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;kong&quot; &#123;</span><br><span class="line">    alias &#x3D; &quot;k2&quot;</span><br><span class="line">    kong_admin_uri  &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1:8001&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">provider &quot;kong&quot; &#123;</span><br><span class="line">    alias &#x3D; &quot;k1&quot;</span><br><span class="line">    kong_admin_uri  &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1:8001&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;names&quot;  &#123;</span><br><span class="line">    default &#x3D; &#123;</span><br><span class="line">        &quot;0&quot; &#x3D; &quot;lee&quot;</span><br><span class="line">        &quot;1&quot; &#x3D; &quot;jiancai&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;kong_consumer&quot; &quot;ngsocial&quot; &#123;</span><br><span class="line">    provider &#x3D; &quot;kong.k1&quot;</span><br><span class="line">    count &#x3D; 2</span><br><span class="line">    username &#x3D; &quot;$&#123;lookup(var.names, count.index)&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;kong_consumer&quot; &quot;test&quot; &#123;</span><br><span class="line">    provider &#x3D; &quot;kong.k2&quot;</span><br><span class="line">    username &#x3D; &quot;testing&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="resource-中使用count，减少相同的参数配置多次"><a href="#resource-中使用count，减少相同的参数配置多次" class="headerlink" title="resource 中使用count，减少相同的参数配置多次"></a>resource 中使用count，减少相同的参数配置多次</h2><p>count描述的是该resource会创建多少个，每个resource都有一个特殊变量（count.index），得知是哪一个resource</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;kong&quot; &#123;</span><br><span class="line">    kong_admin_uri  &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1:8001&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;names&quot;  &#123;</span><br><span class="line">    default &#x3D; &#123;</span><br><span class="line">        &quot;0&quot; &#x3D; &quot;lee&quot;</span><br><span class="line">        &quot;1&quot; &#x3D; &quot;jiancai&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;kong_consumer&quot; &quot;ngsocial&quot; &#123;</span><br><span class="line">    count &#x3D; 2</span><br><span class="line">    username &#x3D; &quot;$&#123;lookup(var.names, count.index)&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &quot;name_1&quot; &#123;</span><br><span class="line">  value &#x3D; &quot;$&#123;kong_consumer.ngsocial.*.username[1]&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">output &quot;name_2&quot; &#123;</span><br><span class="line">  value &#x3D; &quot;$&#123;kong_consumer.ngsocial.*.username[0]&#125;&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">output &quot;name_all&quot; &#123;</span><br><span class="line">  value &#x3D; &quot;$&#123;kong_consumer.ngsocial.*.username&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取某个resource的变量，如上述output的例子，[]要放在最后面。需要索引的位置加上一个*<br>输出是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Outputs:</span><br><span class="line"></span><br><span class="line">name_1 &#x3D; jiancai</span><br><span class="line">name_2 &#x3D; lee</span><br><span class="line">name_all &#x3D; [</span><br><span class="line">    lee,</span><br><span class="line">    jiancai</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>执行terraform show显示的是，每个resource都会加入一个编号，以此来区分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@buzz-unknown142181:&#x2F;home&#x2F;lijiancai&#x2F;gatewayconf&#x2F;test# terraform show</span><br><span class="line">kong_consumer.ngsocial.0:</span><br><span class="line">  id &#x3D; 879f0000-844f-4890-adb7-21b6eace094e</span><br><span class="line">  custom_id &#x3D;</span><br><span class="line">  username &#x3D; lee</span><br><span class="line">kong_consumer.ngsocial.1:</span><br><span class="line">  id &#x3D; b5370300-1ec8-40c7-9300-dc6ea0e11268</span><br><span class="line">  custom_id &#x3D;</span><br><span class="line">  username &#x3D; jiancai</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Outputs:</span><br><span class="line"></span><br><span class="line">name_1 &#x3D; jiancai</span><br><span class="line">name_2 &#x3D; lee</span><br><span class="line">name_all &#x3D; [</span><br><span class="line">    lee,</span><br><span class="line">    jiancai</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="模板文件和count的配合使用"><a href="#模板文件和count的配合使用" class="headerlink" title="模板文件和count的配合使用"></a>模板文件和count的配合使用</h2><p>首先，先讲一个模板文件的使用，一个模板可以渲染出一个变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data &quot;template_file&quot; &quot;example&quot; &#123;</span><br><span class="line">  template &#x3D; &quot;$$&#123;hello&#125; $$&#123;world&#125;!&quot;</span><br><span class="line">  vars &#123;</span><br><span class="line">    hello &#x3D; &quot;goodnight&quot;</span><br><span class="line">    world &#x3D; &quot;moon&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &quot;rendered&quot; &#123;</span><br><span class="line">  value &#x3D; &quot;$&#123;data.template_file.example.rendered&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，渲染出来的值，同伙一个readered的值来获取。</p><p><strong>模板结合count后，可以实现配置文件的模板化。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;count&quot; &#123;</span><br><span class="line">  default &#x3D; 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;hostnames&quot; &#123;</span><br><span class="line">  default &#x3D; &#123;</span><br><span class="line">    &quot;0&quot; &#x3D; &quot;example1.org&quot;</span><br><span class="line">    &quot;1&quot; &#x3D; &quot;example2.net&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;template_file&quot; &quot;web_init&quot; &#123;</span><br><span class="line">  # Render the template once for each instance</span><br><span class="line">  count    &#x3D; &quot;$&#123;length(var.hostnames)&#125;&quot;</span><br><span class="line">  template &#x3D; &quot;$&#123;file(&quot;templates&#x2F;web_init.tpl&quot;)&#125;&quot;</span><br><span class="line">  vars &#123;</span><br><span class="line">    # count.index tells us the index of the instance we are rendering</span><br><span class="line">    hostname &#x3D; &quot;$&#123;var.hostnames[count.index]&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  # Create one instance for each hostname</span><br><span class="line">  count     &#x3D; &quot;$&#123;length(var.hostnames)&#125;&quot;</span><br><span class="line"></span><br><span class="line">  # Pass each instance its corresponding template_file</span><br><span class="line">  user_data &#x3D; &quot;$&#123;data.template_file.web_init.*.rendered[count.index]&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中，根据不同的hostname，创建出来的aws_instance的user_data都不一样，而且是根据hostname来渲染的。</p><h2 id="简单的数学运算"><a href="#简单的数学运算" class="headerlink" title="简单的数学运算"></a>简单的数学运算</h2><p>加法例子，其中count.index + 1使用了加法，另外format是terraform的内建函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;count&quot; &#123;</span><br><span class="line">  default &#x3D; 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  count &#x3D; &quot;$&#123;var.count&#125;&quot;</span><br><span class="line"></span><br><span class="line">  # Tag the instance with a counter starting at 1, ie. web-001</span><br><span class="line">  tags &#123;</span><br><span class="line">    Name &#x3D; &quot;$&#123;format(&quot;web-%03d&quot;, count.index + 1)&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持的运算符：</p><pre><code>- 浮点数：加(+)减(-)乘(*)除(/)- 整数：加(+)减(-)乘(*)除(/)和取余（%）</code></pre><h2 id="terraform的内建函数（built-in-functions）"><a href="#terraform的内建函数（built-in-functions）" class="headerlink" title="terraform的内建函数（built-in functions）"></a>terraform的内建函数（built-in functions）</h2><ul><li><p>abs(float)  一个浮点数（整数）的绝对值</p></li><li><p>basename(path) 返回路径的basename</p></li><li><p>base64decode(string) 字符串使用base64转换后的还原</p></li><li><p>base64encode(string)  字符串使用base64转换</p></li><li><p>index(list, elem) 返回列表中元素的索引</p></li><li><p>join(delim, list) 返回一个由列表被插入分隔符后的字符串</p></li><li><p>lookup(map, key, [default]) 查找map中一个key的值</p></li><li><p>md5(string) 计算md5</p></li><li><p>timestamp()  返回当前的UTC时间</p></li><li><p>merge(map1,map2) 合并两个map</p></li><li><p>format(format, args, …) 字符串的格式化</p></li><li><p>还有其他的内建函数，可参考<br><a href="https://www.terraform.io/docs/configuration/interpolation.html#built-in-functions">https://www.terraform.io/docs/configuration/interpolation.html#built-in-functions</a></p><h2 id="依赖关系的查看"><a href="#依赖关系的查看" class="headerlink" title="依赖关系的查看"></a>依赖关系的查看</h2></li><li><p>terraform graph |dot -Tsvg &gt; graph.svg 会生成一个svg文件，可在本地查看。</p></li><li><p>dot的工具：apt-get install  GraphViz<br><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20181030172332-20210228014046819.png" alt="请在这里输入图片描述"></p></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>k8s的Service的底层网络转发机制</title>
      <link href="../2021/02/26/k8s%E7%9A%84Service%E7%9A%84%E5%BA%95%E5%B1%82%E7%BD%91%E7%BB%9C%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
      <url>../2021/02/26/k8s%E7%9A%84Service%E7%9A%84%E5%BA%95%E5%B1%82%E7%BD%91%E7%BB%9C%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>k8s的Service转发依赖于kube-proxy组件，虽然是使用了底层的Netfilter作为数据转发面，但是也是kube-proxy负责监控k8s集群的配置，然后动态地配置这些规则（iptables的规则）。</p><p>本文以k8s支持的Service的两种类型：<code>ClusterIP</code> 和 <code>NodePort</code>的底层转发的设置。</p><h1 id="2-部署一个模拟业务"><a href="#2-部署一个模拟业务" class="headerlink" title="2. 部署一个模拟业务"></a>2. 部署一个模拟业务</h1><p>   部署一个后端和ClusterIP（Service的默认类型）、NodePort，分别检查其底层设置的iptables规则是什么。</p>   <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">debian-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">debian</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">debian</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">debian</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">debian</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">debian</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;tail&quot;</span>]</span><br><span class="line">        <span class="attr">args:</span> [<span class="string">&quot;-f&quot;</span>, <span class="string">&quot;/dev/null&quot;</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-debian</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">my-debian</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">debian</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-debian-nodeport</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">my-debian-nodeport</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">nodePort:</span> <span class="number">32767</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">debian</span></span><br></pre></td></tr></table></figure><p>   部署好两个Serice后，检查其CLUSTER-IP(vip)是什么。</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n lijiancai get service</span><br><span class="line">NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">my-debian            ClusterIP   11.1.246.253   &lt;none&gt;        8081/TCP       1d</span><br><span class="line">my-debian-nodeport   NodePort    11.1.255.25    &lt;none&gt;        80:32767/TCP   1d</span><br></pre></td></tr></table></figure><p>   可以看出，ClusterIP和NodePort两种Service都部署好了。</p><h2 id="2-1-检查NodePort的转发规则"><a href="#2-1-检查NodePort的转发规则" class="headerlink" title="2.1 检查NodePort的转发规则"></a>2.1 检查NodePort的转发规则</h2><p>首先看一下NodePort的转发规则，登陆其中一个k8s的Node上查看即可。<br>查看相关的规则：<br><code>iptables-save |egrep &quot;11.1.255.25|KUBE-SVC-LNV7GAXDUQDNSVVY|KUBE-SEP-J3E47UJWOXYCTXZO|KUBE-SEP-YG5NCD43FEYFCPSO|KUBE-SEP-P5NKJKBG5L2BFHIC&quot; --color</code></p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210227000521.png"></p><p>对于NodePort这个服务，我们设置的外部端口是32767和80端口，其中32767是通过kube-proxy这个进程转发的。80端口则是通过iptables的规则进行转发的。这里可以得出一个结论：其实可以在Node节点上访问ClusterIP：80，也是可以访问到真实的业务的。如果是Node外部的客户端访问，就需要访问Node：32767了，这个时候，kube-proxy就会参与转发。    </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"> <span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"> <span class="attr">metadata:</span></span><br><span class="line">   <span class="attr">name:</span> <span class="string">my-debian-nodeport</span></span><br><span class="line">   <span class="attr">labels:</span></span><br><span class="line">     <span class="attr">run:</span> <span class="string">my-debian-nodeport</span></span><br><span class="line"> <span class="attr">spec:</span></span><br><span class="line">   <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">   <span class="attr">ports:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">nodePort:</span> <span class="number">32767</span></span><br><span class="line">     <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">     <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">   <span class="attr">selector:</span></span><br><span class="line">     <span class="attr">app:</span> <span class="string">debian</span></span><br></pre></td></tr></table></figure><h2 id="2-2检查CLUSTER-IP的路由转发规则"><a href="#2-2检查CLUSTER-IP的路由转发规则" class="headerlink" title="2.2检查CLUSTER-IP的路由转发规则"></a>2.2检查CLUSTER-IP的路由转发规则</h2><p>查看CLUSTER-IP的转发规则，登陆其中一个Node上查看：<code> iptables-save |egrep &quot;11.1.246.253|KUBE-SVC-AE7Z2ITCKH72L4S6|KUBE-SEP-ITNKZ7TJM6CNT6XR|KUBE-SEP-4A3YQTBEZOS5YQXI|KUBE-SEP-GMGRS7VNE5IDYII6&quot; --color</code></p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210227001533.png"></p><p>可以看出，CLUSTER-IP与NodePort的规则相似，只不过CLUSTER-IP不需要kube-proxy的参与转发。</p><h2 id="2-3-关于SessionAffinity-粘性会话"><a href="#2-3-关于SessionAffinity-粘性会话" class="headerlink" title="2.3 关于SessionAffinity 粘性会话"></a>2.3 关于SessionAffinity 粘性会话</h2><p>iptables底层也是提供粘性会话的功能的。(支持k8s的Service的sessionAffinity: ClientIP)。</p><p>在Service的配置中，添加一个配置项sessionAffinity: ClientIP，就可以让某个客户端的ip一定会转发到同一个Pod上，对于缓存要求较高的业务可能需要这个功能。（顺便说一下，粘性会话这个功能与云原生的理念有点不一样，云原生强调的是环境是随时可以迁移的）</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210227001949.png"></p><p>设置粘性会话前后iptables的规则对比：</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210227002627.png"></p><p>设置粘性会话后，新增的规则有:</p><blockquote><p>-A KUBE-SEP-4A3YQTBEZOS5YQXI -p tcp -m recent –set –name KUBE-SEP-4A3YQTBEZOS5YQXI –mask 255.255.255.255 –rsource -m tcp -j DNAT –to-destination 172.16.44.10:80</p><p>-A KUBE-SEP-GMGRS7VNE5IDYII6 -s 172.16.47.15/32 -j KUBE-MARK-MASQ</p><p>-A KUBE-SEP-GMGRS7VNE5IDYII6 -p tcp -m recent –set –name KUBE-SEP-GMGRS7VNE5IDYII6 –mask 255.255.255.255 –rsource -m tcp -j DNAT –to-destination 172.16.47.15:80</p><p>-A KUBE-SEP-ITNKZ7TJM6CNT6XR -s 172.16.34.3/32 -j KUBE-MARK-MASQ</p><p>-A KUBE-SEP-ITNKZ7TJM6CNT6XR -p tcp -m recent –set –name KUBE-SEP-ITNKZ7TJM6CNT6XR –mask 255.255.255.255 –rsource -m tcp -j DNAT –to-destination 172.16.34.3:80</p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kong集群缓存失效机制</title>
      <link href="../2021/02/26/kong%E9%9B%86%E7%BE%A4%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E6%9C%BA%E5%88%B6/"/>
      <url>../2021/02/26/kong%E9%9B%86%E7%BE%A4%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-kong部署拓扑结构图"><a href="#1-kong部署拓扑结构图" class="headerlink" title="1. kong部署拓扑结构图"></a>1. kong部署拓扑结构图</h2><p>  目前使用的数据库是PostgreSQL,所有的kong节点都连接到同一个数据库上，kong集群间的数据同步依赖于数据库。当某一个kong节点，比如kong1节点的Admin API收到POST或PUT请求的时候，对应到数据库就是一个请求，新增、更新或者删除一条数据，会先更新数据库，然后在数据库的表cluster_events中新增一条记录，表示有更新数据库的行为，其他的节点定时去读取cluster_events这个表，发现有新的数据后，就把对应的缓存删除，重新从数据库里读取。使用数据库作为集群通讯的节点，使得kong可以快速地实现横向扩展，新增节点只需要配置好数据库和配置文件，就可以上线，不需要修改其他节点的任何东西。</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20181121113749-20210301173926356.png"></p><h2 id="2-Admin-API"><a href="#2-Admin-API" class="headerlink" title="2. Admin API"></a>2. Admin API</h2><p>kong的admin api是通过lapis的web框架实现的。在kong/api/init.lua中初始化好admin api的模块，然后具体的代码是在kong/api/routes的目录下，有关于apis、services、routes等相关CRUD操作的实现，详细可以阅读代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">routes</span><br><span class="line">├── apis.lua</span><br><span class="line">├── cache.lua</span><br><span class="line">├── certificates.lua</span><br><span class="line">├── consumers.lua</span><br><span class="line">├── kong.lua</span><br><span class="line">├── plugins.lua</span><br><span class="line">├── routes.lua</span><br><span class="line">├── services.lua</span><br><span class="line">├── snis.lua</span><br><span class="line">└── upstreams.lua</span><br></pre></td></tr></table></figure><p>另外在kong/templates/nginx_kong.lua中，在admin listener的模块中，定义了如何找到相对于的amdin api</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    default_type application&#x2F;json;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        kong.serve_admin_api()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在kong/api下还实现了一个crud_helpers.lua，对api、cache、services等操作数据库进行了抽象，调用crud_helpers提供的接口就可以实现对数据库的操作。</p><h2 id="3-dao和db"><a href="#3-dao和db" class="headerlink" title="3. dao和db"></a>3. dao和db</h2><p>kong/dao和kong/db都是kong对数据库操作query进行了封装，目前支持的数据库有postgresql和Cassandra。其中dao是0.13.0版本前（0.13.0版本的kong引入了两个新的概念service和route替代api）对数据库的操作进行了抽象。</p><ul><li><p>kong/dao/da/init.lua对数据库实现的函数有如下：<br>  <img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20181121114208-20210301173931638.png" alt="请在这里输入图片描述"><br>另外，kong/db是0.13.0版本后才出现的新的数据库模式，功能是跟kong/dao是一样的，新增加的service和route的相关抽象在这个模块下实现。</p></li><li><p>kong/db/dao/init.lua<br><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20181121114521-20210301173937644.png" alt="请在这里输入图片描述"><br>在dao和db这两个模块对数据库进行crud操作后，会有一个的操作，分别用来通知本节点内其他的workers缓存失效和其他kong节点的缓存失效（以删除一行数据为例子）。</p></li><li><p>kong/dao/dao.lua中有：</p><ul><li>self.events.post_local(“dao:crud”, “delete”, {<br>  schema    = self.schema,<br>  operation = “delete”,<br>  entity    = row,<br>})<br><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20181121114600-20210301174031369.png" alt="请在这里输入图片描述"></li></ul></li><li><p>kong/db/dao/init.lua中有：</p><ul><li> self:post_crud_event(“delete”)<br><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20181121114627-20210301173942420.png" alt="请在这里输入图片描述"></li></ul></li></ul><h2 id="4-同一个节点内缓存失效的更新机制"><a href="#4-同一个节点内缓存失效的更新机制" class="headerlink" title="4.同一个节点内缓存失效的更新机制"></a>4.同一个节点内缓存失效的更新机制</h2><p>kong同一节点内是通过事件的订阅和事件发布这种异步模式实现的。</p><ul><li>事件订阅<br><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20181121114711-20210301173955090.png" alt="请在这里输入图片描述"><br>在kong/core/handler.lua的init_worker中，在worker初始化的时候就有注册订阅事件。在worker注册订阅事件后，会等待事件的发布。这是worker的全局事件分发器，这个事件的回调函数会根据传入来的数据，再发布相对应的crud事件。<ul><li>细粒度crud事件的订阅<br><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20181121114731-20210301173950207.png" alt="请在这里输入图片描述"></li></ul></li><li>事件发布<ul><li>上述第3节中的，dao和db中，更新完数据库，返回成功后就会发布这样的事件，来通知当前worker需要处理这个事件。当然这个会进入全局的事件分发器，再发布更细粒度的事件。<br><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20181121114749-20210301174043310.png" alt="请在这里输入图片描述"></li></ul></li></ul><p>细粒度事件订阅的回调函数做的事情就比较简单，将当前worker缓存中的某一个cache的key置位失效，至于所有worker之间的cache同步，则由一个名为kong_cache的库实现，kogn_cache库又是对mlcache的封装。mlcache是三层的缓存架构，提供多个worker间的缓存同步失效机制，也有lru_cache的性能。后续再介绍这个库。<br>以route的更新为例，收到事件后，将cache中的”router:version”这个值置位无效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">worker_events.register(function()</span><br><span class="line">        log(DEBUG, &quot;[events] Route updated, invalidating router&quot;)</span><br><span class="line">        cache:invalidate(&quot;router:version&quot;)</span><br><span class="line">      end, &quot;crud&quot;, &quot;routes&quot;)</span><br></pre></td></tr></table></figure><p>核心的部分是调用：cache:invalidate,这个kong_cache提供的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function _M:invalidate(key)</span><br><span class="line">  if type(key) ~&#x3D; &quot;string&quot; then</span><br><span class="line">    return error(&quot;key must be a string&quot;)</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  self:invalidate_local(key)</span><br><span class="line"></span><br><span class="line">  local nbf</span><br><span class="line">  if self.propagation_delay &gt; 0 then</span><br><span class="line">    nbf &#x3D; ngx_now() + self.propagation_delay</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  log(DEBUG, &quot;broadcasting (cluster) invalidation for key: &#39;&quot;, key, &quot;&#39; &quot;,</span><br><span class="line">             &quot;with nbf: &#39;&quot;, nbf or &quot;none&quot;, &quot;&#39;&quot;)</span><br><span class="line"></span><br><span class="line">  local ok, err &#x3D; self.cluster_events:broadcast(&quot;invalidations&quot;, key, nbf)</span><br><span class="line">  if not ok then</span><br><span class="line">    log(ERR, &quot;failed to broadcast cached entity invalidation: &quot;, err)</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这个接口也是有2个核心的操作：</p><ul><li>self:invalidate_local(key) 使得这个key在所有worker中都失效</li><li>self.cluster_events:broadcast(“invalidations”, key, nbf)，这个是在发布一个集群的事件，目前是使其他的kong节点能够知道某个key已经失效。实现的方式是在数据的cluster_events的表中插入一条记录，其他的节点会定时query这个表，得知某个key失效。因此集群间的同步是有延时的。定时读取数据库cluster_events表的间隔短，同步时间会减少，但是增加数据库压力，反之亦然。</li></ul><p>接着上面说到的”router:version”这个key失效后，对应到一个真实业务请求到达kong监听的接口时，怎么匹配都route呢？而这个key又有什么用呢？</p><p>每个请求在nginx的access执行阶段，都是执行kong/init.lua里的access函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">core.access.before(ctx)</span><br><span class="line"></span><br><span class="line">for plugin, plugin_conf in plugins_iterator(singletons.loaded_plugins, true) do</span><br><span class="line">  if not ctx.delayed_response then</span><br><span class="line">    local err &#x3D; coroutine.wrap(plugin.handler.access)(plugin.handler, plugin_conf)</span><br><span class="line">    if err then</span><br><span class="line">      ctx.delay_response &#x3D; false</span><br><span class="line">      return responses.send_HTTP_INTERNAL_SERVER_ERROR(err)</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>会先执行core.accees.before(ctx)</li><li>再对当前route对应的service绑定的插件进行迭代，以此实现每个插件都会被执行一次。<br>核心的逻辑是在core.access.before上（代码在kong/core/handler.lua）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">access &#x3D; &#123;</span><br><span class="line">   before &#x3D; function(ctx)</span><br><span class="line">     -- ensure routers are up-to-date</span><br><span class="line">     local cache &#x3D; singletons.cache</span><br><span class="line">     -- 省略部分代码</span><br><span class="line">     local version, err &#x3D; cache:get(&quot;router:version&quot;, CACHE_ROUTER_OPTS, utils.uuid)</span><br><span class="line">     if err then</span><br><span class="line">       log(ngx.CRIT, &quot;could not ensure router is up to date: &quot;, err)</span><br><span class="line"></span><br><span class="line">     elseif router_version ~&#x3D; version then</span><br><span class="line">       -- router needs to be rebuilt in this worker</span><br><span class="line">       log(DEBUG, &quot;rebuilding router&quot;)</span><br><span class="line"></span><br><span class="line">       local ok, err &#x3D; build_router(singletons.db, version)</span><br><span class="line">       if not ok then</span><br><span class="line">         router_err &#x3D; err</span><br><span class="line">         log(ngx.CRIT, &quot;could not rebuild router: &quot;, err)</span><br><span class="line">       end</span><br><span class="line">     end</span><br><span class="line"></span><br><span class="line">     --省略下面的代码</span><br></pre></td></tr></table></figure>原来，每次在请求的access阶段，都会从cache中读取到”router:version”这个key，然后判断这个所有的router是否发现了变化，如果发生了变化，就会重新调用build_router(singletons.db, version)去建立router，那么每次发生router的表curd操作的时候，每个worker都会重新调用build_router构建所有的routes。至此，从admin api到kong内部的逻辑识别到数据库发生变化在单个kong节点中已梳理好。</li></ul><h2 id="5-节点间同步的机制"><a href="#5-节点间同步的机制" class="headerlink" title="5. 节点间同步的机制"></a>5. 节点间同步的机制</h2><p>当一个worker收到数据库发生变更的事件后，会将当前节点缓存中的某个key置位无效。代码中会处理key失效的情况，通常实现都是去数据库中重新读取。那么kong的节点怎么知道事件的发生的呢？是kong在将本地的key置为无效后，会调用self.cluster_events:broadcast(“invalidations”, key, nbf)将某个key置为无效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function _M:invalidate(key)</span><br><span class="line">  -- 省略部分代码</span><br><span class="line"></span><br><span class="line">  log(DEBUG, &quot;broadcasting (cluster) invalidation for key: &#39;&quot;, key, &quot;&#39; &quot;,</span><br><span class="line">             &quot;with nbf: &#39;&quot;, nbf or &quot;none&quot;, &quot;&#39;&quot;)</span><br><span class="line"></span><br><span class="line">  local ok, err &#x3D; self.cluster_events:broadcast(&quot;invalidations&quot;, key, nbf)</span><br><span class="line">  if not ok then</span><br><span class="line">    log(ERR, &quot;failed to broadcast cached entity invalidation: &quot;, err)</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>cluster_events.lua中broadcast的实现如下，本质上就是在数据库中插入一条记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function _M:broadcast(channel, data, nbf)</span><br><span class="line"></span><br><span class="line">  -- 省略部分代码</span><br><span class="line"></span><br><span class="line">  local ok, err &#x3D; self.strategy:insert(self.node_id, channel, ngx_now(), data, nbf)</span><br><span class="line">  if not ok then</span><br><span class="line">    return nil, err</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  return true</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面讲的是，如何实现在数据库的cluster_events表插入一条记录使得其他kong节点的缓存失效。那么，其他节点什么时候去读取数据库的cluster_events表呢，kong的实现是定时去读取数据库，这样的做法会导致节点同步时间不一样，是最终一致性。<br>在kong/init.lua中，会初始化一个cache，这个cache初始化的时候，就会启动一个定时器，定时去读取cluster_events这个表的内容。</p><ul><li><p>初始化cache</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">local cache, err &#x3D; kong_cache.new &#123;</span><br><span class="line">    cluster_events    &#x3D; cluster_events,</span><br><span class="line">    worker_events     &#x3D; worker_events,</span><br><span class="line">    propagation_delay &#x3D; configuration.db_update_propagation,</span><br><span class="line">    ttl               &#x3D; configuration.db_cache_ttl,</span><br><span class="line">    neg_ttl           &#x3D; configuration.db_cache_ttl,</span><br><span class="line">    resty_lock_opts   &#x3D; &#123;</span><br><span class="line">      exptime &#x3D; 10,</span><br><span class="line">      timeout &#x3D; 5,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  cache里面的key有：<br>  router:version<br>  api_router:version</p></li><li><p>kong_cache.new的实现细节：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local ok, err &#x3D; self.cluster_events:subscribe(&quot;invalidations&quot;, function(key)</span><br><span class="line">    log(DEBUG, &quot;received invalidate event from cluster for key: &#39;&quot;, key, &quot;&#39;&quot;)</span><br><span class="line">    self:invalidate_local(key)</span><br><span class="line">end)</span><br></pre></td></tr></table></figure><p>关键是 self.cluster_events:subscribe会注册一个定时器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local ok, err &#x3D; timer_at(self.poll_interval, poll_handler, self)</span><br><span class="line">if not ok then</span><br><span class="line">  return nil, &quot;failed to start polling timer: &quot; .. err</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>因此poll_handler会保证在间隔期间内，一个kong节点的所有workers只会poll一次，即读取数据库一次。如果有记录，就将某个key置为无效。比如key router:version变为无效后，跟上一节的节点内缓存失效的机制一样的，会判断到router:version发生了变化，需要去数据库读取route回来。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Kong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能火焰图打印</title>
      <link href="../2021/02/24/%E6%80%A7%E8%83%BD%E7%81%AB%E7%84%B0%E5%9B%BE%E6%89%93%E5%8D%B0/"/>
      <url>../2021/02/24/%E6%80%A7%E8%83%BD%E7%81%AB%E7%84%B0%E5%9B%BE%E6%89%93%E5%8D%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-输出函数调用火焰图"><a href="#1-输出函数调用火焰图" class="headerlink" title="1. 输出函数调用火焰图"></a>1. 输出函数调用火焰图</h1><p>要输出火焰图之前，需要获取到一些统计数据，在Linux平台需要用perf工具进行采样和统计数据的收集。收集完数据后，就是可以使用火焰图制作工具FlameGraph输出火焰图了。</p><p>以Envoy的采样作为例子，步骤如下：</p><ol><li><p>启动Envoy，并且通过ps获取到其Pid: <code>./envoy_debug -c envoy_config.yaml</code></p></li><li><p>对Envoy进行压测: <code>ab -c 10 -t 100 http://127.0.0.1:8000/</code></p></li><li><p>使用perf对Envoy进行采样：<code>perf record -F 99  -g -p 31636 -- sleep 10</code>, 其中<code>-g</code>表示使用采样调用栈，<code>-p</code>表示进程的Pid，<code>-- sleep 10</code>表示采样时间共10s。</p></li><li><p>perf record 执行结束后，会在当前的目录输出perf.data文件。（可以保存这份原始文件用于后续分析，如果不需要输出火焰图，也可以执行:<code>perf report -n --stdio</code>在当前终端输出统计信息）</p></li><li><p>预处理数据：<code>perf script &gt; out.perf</code></p></li><li><p>使用FlameGraph生成火焰图：<code>./stackcollapse-perf.pl out.perf | ./flamegraph.pl &gt; newout.svg</code>, 这个步骤用到的工具在 <a href="https://github.com/brendangregg/FlameGraph">https://github.com/brendangregg/FlameGraph</a> 。</p></li><li><p>在浏览器打开svg图片，效果如下</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210224232314.png"></p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>火焰图打印工具Repo： <a href="https://github.com/brendangregg/FlameGraph">https://github.com/brendangregg/FlameGraph</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Benchmark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>压测方法论</title>
      <link href="../2021/02/24/%E5%8E%8B%E6%B5%8B%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
      <url>../2021/02/24/%E5%8E%8B%E6%B5%8B%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="1-环境准备方面"><a href="#1-环境准备方面" class="headerlink" title="1. 环境准备方面"></a>1. 环境准备方面</h1><ol><li>性能测试的时候，应该要关闭cpu的turbo功能，否则对我们的基础性能影响很大。至少有20%的误差。<code>echo 1 | sudo tee /sys/devices/system/cpu/intel_pstate/no_turbo</code></li><li>排除当前被压测的服务机器上，有其他消耗资源较多的服务在运行。</li></ol><h1 id="2-HTTP-相关压测"><a href="#2-HTTP-相关压测" class="headerlink" title="2. HTTP 相关压测"></a>2. HTTP 相关压测</h1><ul><li><p>首先要注意的是HTTP1.0默认是请求完成后关闭TCP连接的。HTTP1.1则是默认请求完成后不关闭TCP连接。在测试RPS的时候，HTTP请求需要复用TCP连接，在测试CPS的时候，HTTP请求不能复用TCP连接。为了保证压测符合设想，可以在请求的时候主动构造Connection这个Header。</p><ul><li>不复用TCP: `Connection: Close</li><li>复用TCP： <code>Connection: Keep-Alive </code></li></ul></li><li><p>测试RPS的时候，可以指定CPU的核，然后并发的启动压测工具，这样可以保证压测机器可以发挥最大的性能。注意： 需要后台运行压测工具。每个命令的并发数控制为``1`,因为已经单独分配好CPU，就不需要竞争了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 number-of-CPUs`; <span class="keyword">do</span></span><br><span class="line">    taskset -c <span class="variable">$i</span> wrk -t 1 -c 50 -d 180s http://Reverse-Proxy-Server-IP-address/1kb.bin &amp;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>如果只想测试TLS/SSL 的TPS，这时候可以获取返回0 byte数据的接口，这样就可以看到TLS相关的性能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 number-of-CPUs`; <span class="keyword">do</span></span><br><span class="line">    taskset -c <span class="variable">$i</span> wrk -t 1 -c 50 -d 180s -H <span class="string">&#x27;Connection: close&#x27;</span> https://Reverse-Proxy-Server-IP-address/0kb.bin &amp;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>测试吞吐的时候，获取返回1M数据量的接口即可（也可以是4k、8k等，要和实际的业务需求结合起来）。</p></li><li><p>同时测试多张网卡的话，就要访问不同IP了，由路由决定走哪张网卡。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 number-of-CPUs/2`; <span class="keyword">do</span></span><br><span class="line">    n=`<span class="built_in">echo</span> $((<span class="variable">$i</span>+number-of-CPUs/<span class="number">2</span>))`;</span><br><span class="line">    taskset -c <span class="variable">$i</span> ./wrk -t 1 -c 50 -d 180s http://Reverse-Proxy-Server-IP-address-1/1kb.bin &amp;</span><br><span class="line">    taskset -c <span class="variable">$n</span> ./wrk -t 1 -c 50 -d 180s http://Reverse-Proxy-Server-IP-address-2/1kb.bin &amp;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol><li><a href="https://www.nginx.com/blog/nginx-plus-sizing-guide-how-we-tested/">https://www.nginx.com/blog/nginx-plus-sizing-guide-how-we-tested/</a></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Benchmark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Istio如何注入sidecar并拉起</title>
      <link href="../2021/02/24/Istio%E5%A6%82%E4%BD%95%E6%B3%A8%E5%85%A5sidecar%E5%B9%B6%E6%8B%89%E8%B5%B7/"/>
      <url>../2021/02/24/Istio%E5%A6%82%E4%BD%95%E6%B3%A8%E5%85%A5sidecar%E5%B9%B6%E6%8B%89%E8%B5%B7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-利用K8S和Istio组件提供的机制，对Pod进行sidecar的注入"><a href="#1-利用K8S和Istio组件提供的机制，对Pod进行sidecar的注入" class="headerlink" title="1. 利用K8S和Istio组件提供的机制，对Pod进行sidecar的注入"></a>1. 利用K8S和Istio组件提供的机制，对Pod进行sidecar的注入</h1><pre><code>K8S的动态webhook机制可以使得在所有的资源请求经过APIServer的时候进行校验，有两种dynamic webhook，一是MutatingWebhook，二是ValidatingWebhook。注入sidecar的是用到MutatingWebhook，要使用MutatingWebhook需要配置一个MutatingWebhookConfiguration。查看命令： `kubectl get MutatingWebhookConfiguration istio-sidecar-injector  -o yaml -n default`,配置内容如下：</code></pre><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">admissionregistration.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">MutatingWebhookConfiguration</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">sidecarInjectorWebhook</span></span><br><span class="line">    <span class="attr">chart:</span> <span class="string">sidecarInjectorWebhook</span></span><br><span class="line">    <span class="attr">heritage:</span> <span class="string">Tiller</span></span><br><span class="line">    <span class="attr">release:</span> <span class="string">istio</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio-sidecar-injector</span></span><br><span class="line"><span class="attr">webhooks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">admissionReviewVersions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">v1beta1</span></span><br><span class="line">  <span class="attr">clientConfig:</span></span><br><span class="line">    <span class="attr">caBundle:</span> <span class="string">LS0tLS1CRUdJTiBDRVJUSUZ***************</span></span><br><span class="line">    <span class="attr">service:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">istio-sidecar-injector</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/inject</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">  <span class="attr">failurePolicy:</span> <span class="string">Fail</span></span><br><span class="line">  <span class="attr">matchPolicy:</span> <span class="string">Exact</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sidecar-injector.istio.io</span></span><br><span class="line">  <span class="attr">namespaceSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">istio-injection:</span> <span class="string">enabled</span></span><br><span class="line">  <span class="attr">objectSelector:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">reinvocationPolicy:</span> <span class="string">Never</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">apiVersions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">operations:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CREATE</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">    <span class="attr">scope:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  <span class="attr">sideEffects:</span> <span class="string">Unknown</span></span><br><span class="line">  <span class="attr">timeoutSeconds:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><pre><code>可以看到，只有 label有istio-injection: enabled的命令空间的Pod才会注入Sidecar，sidecar的配置是去命名空间istio-system下的istio-sidecar-injector 443端口下的/inject端口获取。采用的是HTTP协议。</code></pre><blockquote><p>kubectl -n istio-system get deployment istio-sidecar-injector<br>NAME                     READY   UP-TO-DATE   AVAILABLE   AGE<br>istio-sidecar-injector   2/2     2            2           32d</p></blockquote><pre><code>istio-sidecar-injector如何注入sidecar的配置，是根据一个模板生成出来的，该模板是在一个configmap中，查看方式如下：`kubectl -n istio-system get cm istio-sidecar-injector`。</code></pre><h1 id="2-sidecar-内部如何启动"><a href="#2-sidecar-内部如何启动" class="headerlink" title="2. sidecar 内部如何启动"></a>2. sidecar 内部如何启动</h1><p>sidecar的进程参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istio-p+       1  0.0  0.0 137124 35088 ?        Ssl   2020  43:32 /usr/<span class="built_in">local</span>/bin/pilot-agent proxy sidecar --domain hello-world.svc.cluster.local --configPath /etc/istio/proxy --binaryPath /usr/<span class="built_in">local</span>/bin/envoy --serviceCluster productpage.hello-world --drainDuration 45s --parentShutdownDuration 1m0s --discoveryAddress istio-pilot.istio-system:15010 --zipkinAddress zipkin.istio-system:9411 --dnsRefreshRate 300s --connectTimeout 10s --proxyAdminPort 15000 --concurrency 2 --controlPlaneAuthPolicy NONE --statusPort 15020 --applicationPorts 9080</span><br><span class="line">istio-p+      65  0.1  0.0 195476 56536 ?        Sl    2020  62:39 /usr/<span class="built_in">local</span>/bin/envoy -c /etc/istio/proxy/envoy-rev1.json --restart-epoch 1 --drain-time-s 45 --parent-shutdown-time-s 60 --service-cluster productpage.hello-world --service-node sidecar~10.216.24.213~productpage-v1-556c4c548f-ld85c.hello-world~hello-world.svc.cluster.local --max-obj-name-len 189 --local-address-ip-version v4 --log-format [Envoy (Epoch 1)] [%Y-%m-%d %T.%e][%t][%l][%n] %v -l warning --component-log-level misc:error --concurrency 2</span><br></pre></td></tr></table></figure><pre><code>可以看到，有一个代理的进程pilot-agent负责转换Istio注入的参数为Envoy的参数，并且生成Envoy的配置文件/etc/istio/proxy/envoy-rev1.json。这样，Istio就通过Pod修改配置的机制，注入了Sidecar的启动参数（通过环境变量注入），然后又通过一个代理进程负责生成Envoy的参数和配置文件，接着再拉起Envoy的进程。其中，有一个关键的参数是`--discoveryAddress istio-pilot.istio-system:15010`,此参数是Envoy的ADS的地址，Envoy就是通过ADS的地址建立GRPC连接，实现Istio的参数动态修改后，Envoy就可以发现，并且在线修改响应的配置。</code></pre><p>​    </p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Istio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Delve调试容器内Go代码</title>
      <link href="../2021/02/24/%E4%BD%BF%E7%94%A8Delve%E8%B0%83%E8%AF%95%E5%AE%B9%E5%99%A8%E5%86%85Go%E4%BB%A3%E7%A0%81/"/>
      <url>../2021/02/24/%E4%BD%BF%E7%94%A8Delve%E8%B0%83%E8%AF%95%E5%AE%B9%E5%99%A8%E5%86%85Go%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><ul><li><p>Delve是一个Go语言的调试器，跟GDB比较，Delve是专用的调试器，能够识别到go routine等语义, 是Go语言调试的不二之选。</p></li><li><p>istio调试代码，如pilot-agent或istiod等，调试的环境构建（构建）比较复杂，需要传入环境变量、参数、挂载的文件、以及运行的网络联性等。如果要在本地调试这些持续，模拟环境非常复杂。因此，需要换个思路，直接调试在k8s集群容器内部运行的代码，所以需要一个远程调试的工具来辅助。以pilot-agent为例子，演示创建调试环境的流程。</p></li></ul><h1 id="2-需要解决的问题"><a href="#2-需要解决的问题" class="headerlink" title="2. 需要解决的问题"></a>2. 需要解决的问题</h1><ol><li>替换容器的Entrypoint，这样我们才可以在容器内重启需要被调试的进程（以pilot-agent为例，不能让pilot-agent作为容器的Entrypoint（pid不能为1），这样我们就算重启pilot-agent，也不会导致容器重启）</li><li>新建一个镜像，安装好日常使用的工具：GDB、dlv（Delve）、go等常用的工具，方便调试。</li><li>sidecar注入的时候，以root的权限运行容器（这样才不会不可预见遇到权限不足的问题，因为是调试环境，权限最大也没问题）。修改容器文件系统的可读写性，文件系统改为可读可写。</li></ol><h1 id="3-准备环境"><a href="#3-准备环境" class="headerlink" title="3. 准备环境"></a>3. 准备环境</h1><ol><li><p>使用一个新的入口，来运行原来容器的Entrypoint。这里使用一个python脚本dumb.py 作为入口即可。 这个脚本会在sidecar启动的时候就会执行，脚本的参数就是原来 pilot-agent的启动命令+参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt;= <span class="number">2</span>:</span><br><span class="line">        print(<span class="string">&#x27;Not enough args&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        subprocess.run(sys.argv[<span class="number">1</span>:], check=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        time.sleep(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li><li><p>重新编译好带有调试符号的pilot-agent二进制</p><ul><li>cd istio/pilot/cmd/pilot-agent</li></ul></li></ol><ul><li>env GOOS=linux     GOARCH=amd64 go build     -gcflags=”all=-N -l”      . (因为在Mac上编译，需要添加目标平台和OS的环境变量，并且传入-gcflags=”all=-N     -l”)</li></ul><ol start="3"><li><p>准备好Devle的Linux版本的二进制</p><ul><li>找一台linux的机器：go get github.com/go-delve/delve/cmd/dlv</li></ul></li></ol><ul><li>去目录~/go/bin下找到二进制dlv</li></ul><ol start="4"><li><p>下载Go并且解压（因为Delve需要Go的运行时的，所以在容器的镜像内也要有Go）</p></li><li><p>基于原有的Istio使用的镜像，构建一个新的镜像.</p><ul><li>Dockerfile内容如下：</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> docker.io/istio/proxyv2:<span class="number">1.8</span>.<span class="number">2</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;/usr/local/go/bin:$&#123;PATH&#125;&quot;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> dumb.py /dumb.py</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> dlv /usr/<span class="built_in">local</span>/bin/dlv</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> go /usr/<span class="built_in">local</span>/go</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x /dumb.py /usr/<span class="built_in">local</span>/bin/dlv /usr/<span class="built_in">local</span>/go/bin/go \</span></span><br><span class="line"><span class="bash">&amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">&amp;&amp; apt-get install gdb vim ssh socat -y</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> pilot-agent /usr/<span class="built_in">local</span>/bin/pilot-agent</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x /usr/<span class="built_in">local</span>/bin/pilot-agent</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;/dumb.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>​    放Dockerfile文件的目录包含的资源有：</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E5%9B%BE%E7%89%87.png" alt="未命名图片"></p><ul><li>编译新的镜像：docker build ./ -t leejiancai/proxyv2:1.8.2_dlv</li></ul></li></ol><ul><li>推送新编译出来的镜像到dockerhub：docker push leejiancai/proxyv2:1.8.2_dlv</li></ul><ol start="6"><li><p>修改Istio的Sidecar-injector的配置</p><ul><li><p>修改配置文件configmap：<code>kubectl -n istio-system edit cm istio-sidecar-injector</code></p></li><li><p>修改sidecar的镜像为自定义的镜像 leejiancai/proxyv2:1.8.2_dlv</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210224030551.png"></p></li><li><p>修改isito-proxy容器的参数</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E5%9B%BE%E7%89%87111.png"></p></li><li><p>修改istio-proxy容器的文件系统可读写性和运行用户为root</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E5%9B%BE%E7%89%8721.png" alt="未命名图片21"></p></li><li><p>istio-proxy容器新增一个开放端口2345(后面进行远程调试需要用到这个端口)</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E5%9B%BE%E7%89%87123213.png" alt="未命名图片123213"></p></li></ul></li></ol><h1 id="4-使用dlv进行远程调试"><a href="#4-使用dlv进行远程调试" class="headerlink" title="4. 使用dlv进行远程调试"></a>4. 使用dlv进行远程调试</h1><ol><li><p>部署httpbin服务：<code>cd istio-1.8.2/samples/httpbin &amp;&amp; kubectl apply -f httpbin.yaml</code></p></li><li><p>进去httpbin的istio-proxy容器：<code>kubectl exec -it httpbin-74fb669cc6-nqr47 -c istio-proxy -- bash</code></p></li><li><p>kill掉pilot-agent和envoy的进程</p></li><li><p>使用dlv拉起一个新的pilot-agent进程：<br><code>dlv exec --headless --listen=:2345 --api-version=2 --accept-multiclient /usr/local/bin/pilot-agent -- proxy sidecar --domain default.svc.cluster.local --serviceCluster httpbin.default --proxyLogLevel=warning --proxyComponentLogLevel=misc:error --concurrency 2</code></p></li><li><p>在调试机器（Mac电脑上）上，使用kubectl port-forward转发当前的2345端口到httpbin的pod的2345端口中：<code>kubectl port-forward pod/httpbin-74fb669cc6-nqr47  2345</code></p></li><li><p>使用GoLAND去本地机器的2345端口进行远程调试</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210224030508.png"></p></li><li><p>在需要进行观察的函数中进行断点，然后再启动调试客户端</p><ul><li><p>断点</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210224030443.png"></p></li><li><p>调试效果</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20210224030403.png"></p></li></ul></li></ol><h1 id="5-补充"><a href="#5-补充" class="headerlink" title="5. 补充"></a>5. 补充</h1><ol><li>在调试客户端不能重启调试：<br>在httpbin的Pod上，kill掉dlv、pilot-agent和envoy的进程，重新按照新调试的流程再执行即可。</li><li>实验环境是：Mac电脑上跑的Minikube实例，Istio的版本是1.8.2</li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Istio </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Wireshark解密Chrome和Curl的TLS包</title>
      <link href="../2021/02/23/%E4%BD%BF%E7%94%A8Wireshark%E8%A7%A3%E5%AF%86Chrome%E5%92%8CCurl%E7%9A%84TLS%E5%8C%85/"/>
      <url>../2021/02/23/%E4%BD%BF%E7%94%A8Wireshark%E8%A7%A3%E5%AF%86Chrome%E5%92%8CCurl%E7%9A%84TLS%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h1><p>本文主要介绍如何解密Chrome浏览器或Curl的TLS请求。原理是：设置环境变量SSLKEYLOGFILE，Chrome（Curl）就会输出TLS握手过程中协商出来用于数据传输加密的密钥。Wireshark读取 这个密钥就可以对传输的数据进行解密了。</p><h1 id="2-准备"><a href="#2-准备" class="headerlink" title="2. 准备"></a>2. 准备</h1><ol><li><p>在Home目录创建一个文件，用于TLS握手中间过程输出的关键数据：touch sshkeylog.log</p></li><li><p>export环境变量SSLKEYLOGFILE，这样浏览器的TLS握手信息才会输出：export SSLKEYLOGFILE=/Users/lijiancai/sshkeylog.log  （注意⚠️：这个路径，当前的用户需要有读写权限，放置在用户Home目录即可)</p></li><li><p>配置Wireshark，【Preferences】-&gt; 【Protocols】-&gt; 【TLS】-&gt; 【(Pre)-Master-Secret】</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20201221213132462.png" alt="image-20201221213132462"></p><h1 id="3-抓Chrome的包"><a href="#3-抓Chrome的包" class="headerlink" title="3. 抓Chrome的包"></a>3. 抓Chrome的包</h1><p>步骤如下：</p><ul><li><p>关闭浏览器，然后重新打开：open -a     ‘Google Chrome’  （启动前需要配置环境变量：export SSLKEYLOGFILE=/Users/lijiancai/sshkeylog.log  ）；或直接运行也可以：SSLKEYLOGFILE=/Users/lijiancai/keylog.log open -a ‘Google Chrome’</p></li><li><p>演示抓知乎的数据包，首先这只捕获的参数:host <a href="http://www.zhihu.com/">www.zhihu.com</a></p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20201221213714543.png" alt="image-20201221213714543"></p></li><li><p>过滤一下http2的流量出来，因为http2一定是使用TLS加密的。我们可以看到原始的数据内容了</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20201221214048935.png" alt="image-20201221214048935"></p></li></ul></li></ol><h1 id="4-抓Curl的包"><a href="#4-抓Curl的包" class="headerlink" title="4. 抓Curl的包"></a>4. 抓Curl的包</h1><ul><li>执行curl的时候，加上环境变量即可：<code> SSLKEYLOGFILE=/Users/lijiancai/keylog.log curl https://www.zhihu.com</code></li></ul><p>为什么curl也支持这个环境变量呢，是因为：所有使用Libcurl构建的应用（curl也是基于这个库开发的），都可以设置环境变量SSLKEYLOGFILE来获取TLS握手协商出来的密钥，去解析TLS的包。所以，检查一下你的应用是否支持Libcurl。</p><blockquote><p>curl –version<br>curl 7.64.1 (x86_64-apple-darwin20.0) libcurl/7.64.1 (SecureTransport) LibreSSL/2.8.3 zlib/1.2.11 nghttp2/1.41.0<br>Release-Date: 2019-03-27<br>Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtsp smb smbs smtp smtps telnet tftp<br>Features: AsynchDNS GSS-API HTTP2 HTTPS-proxy IPv6 Kerberos Largefile libz MultiSSL NTLM NTLM_WB SPNEGO SSL UnixSockets</p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络问题定位工具</title>
      <link href="../2021/02/23/%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E5%B7%A5%E5%85%B7/"/>
      <url>../2021/02/23/%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-网络（进程）吞吐量观测"><a href="#1-网络（进程）吞吐量观测" class="headerlink" title="1. 网络（进程）吞吐量观测"></a>1. 网络（进程）吞吐量观测</h1><ul><li><p>sar -n DEV : 用于观察每个网卡的吞吐量、包收发率和使用率等信息。</p></li><li><p>iftop： 用于观察local和remote连接的吞吐量。常用于定位本地节点与远程节点的数据传输量差别（排序等）</p></li><li><p>nethogs: 用于观察每个进程的吞吐量，可以用来定位某个进程的异常。并且会输出每个进程每个TCP连接的流量。</p><p>例子：</p></li></ul><ol><li><p>sar -n DEV: <code>sar -n DEV 1 10 </code>, 参数中1代表打印间隔为1s。10代表打印10次。输出中，IFACE代表网卡。</p><blockquote><p>sar -n DEV 1 10<br>Linux 4.19.0-5-amd64 (*<strong>****</strong>)     2021年02月23日     _x86_64_    (16 CPU)</p><p>22时54分34秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil<br>22时54分35秒      eth0      2.00      1.00      0.14      0.10      0.00      0.00      0.00      0.00<br>22时54分35秒   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00<br>22时54分35秒        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</p></blockquote></li><li><p>iftop: <code>iftop -n</code>, -n表示输出ip，而不是域名。输出如下</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20210223230610330.png"></p></li><li><p>nethogs: <code>nethogs eth0</code>, eth0代表指定网卡，也可以不指定网卡，所有网卡都输出</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20210223230610330.png" alt="image-20210223230610330"></p></li></ol><h1 id="2-TCP和UDP的观测"><a href="#2-TCP和UDP的观测" class="headerlink" title="2. TCP和UDP的观测"></a>2. TCP和UDP的观测</h1><ul><li>统计TCP和UDP统计输出<ul><li><code>ss -s</code></li></ul></li></ul><h1 id="3-网卡的观测"><a href="#3-网卡的观测" class="headerlink" title="3. 网卡的观测"></a>3. 网卡的观测</h1><ul><li><p>列出当前网络命名空间的网卡：<code>ip ad</code></p></li><li><p>网卡的发送（接收）统计、发送错误的统计： <code>ifconfig</code> 或<code>ifconfig -s</code> , -s 参数会让输出更加简洁（当然，也有一部分数据缺失）</p><blockquote><p>ifconfig -s<br>Iface      MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg<br>docker0   1500    43990      0      0 0        215435      0      0      0 BMU<br>eth0      1400  2013035      0     10 0        261414      0      0      0 BMRU<br>lo       65536     7928      0      0 0          7928      0      0      0 LRU</p></blockquote></li><li><p>网卡当前的吞吐量：<code>sar -n DEV 1 10</code></p></li><li></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Networking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Envoy的ListenerFilter的功能及其分析</title>
      <link href="../2021/02/23/Envoy%E7%9A%84ListenerFilter%E7%9A%84%E5%8A%9F%E8%83%BD%E5%8F%8A%E5%85%B6%E5%88%86%E6%9E%90/"/>
      <url>../2021/02/23/Envoy%E7%9A%84ListenerFilter%E7%9A%84%E5%8A%9F%E8%83%BD%E5%8F%8A%E5%85%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Listener-filters的处理流程"><a href="#1-Listener-filters的处理流程" class="headerlink" title="1. Listener filters的处理流程"></a>1. Listener filters的处理流程</h2><p>envoy支持的listener filter一共有五个</p><ol><li>envoy.listener.http_inspector</li><li>envoy.listener.original_dst</li><li>envoy.listener.original_src</li><li>envoy.listener.proxy_protocol</li><li>envoy.listener.tls_inspector</li></ol><p><strong>注意：</strong>我们下面讨论到的filter指的都是listener filter。</p><h3 id="1-1-回调的调用堆栈"><a href="#1-1-回调的调用堆栈" class="headerlink" title="1.1 回调的调用堆栈"></a>1.1 回调的调用堆栈</h3><p>首先看一下listener监听的socket回调时候的堆栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#0  Envoy::Server::ConnectionHandlerImpl::ActiveTcpSocket::continueFilterChain (this&#x3D;0x555559ae3810, success&#x3D;true)</span><br><span class="line">    at source&#x2F;server&#x2F;connection_handler_impl.cc:204</span><br><span class="line">#1  0x0000555557c20fa2 in Envoy::Server::ConnectionHandlerImpl::ActiveTcpListener::onAcceptWorker (</span><br><span class="line">    this&#x3D;0x555559b0e300, socket&#x3D;..., hand_off_restored_destination_connections&#x3D;false, rebalanced&#x3D;false)</span><br><span class="line">    at source&#x2F;server&#x2F;connection_handler_impl.cc:293</span><br><span class="line">#2  0x0000555557c21730 in Envoy::Server::ConnectionHandlerImpl::ActiveTcpListener::onAccept (this&#x3D;0x555559b0e300,</span><br><span class="line">    socket&#x3D;...) at source&#x2F;server&#x2F;connection_handler_impl.cc:273</span><br><span class="line">#3  0x0000555557c5d69f in Envoy::Network::ListenerImpl::listenCallback (fd&#x3D;46, remote_addr&#x3D;0x7fffeebd8508,</span><br><span class="line">    remote_addr_len&#x3D;16, arg&#x3D;0x555559b09bc0) at source&#x2F;common&#x2F;network&#x2F;listener_impl.cc:46</span><br><span class="line">#4  0x000055555834d4b9 in listener_read_cb (fd&#x3D;47, what&#x3D;2, p&#x3D;0x555559afce70)</span><br></pre></td></tr></table></figure><p>重点关注#0的continueFilterChain和#4的listener_read_cb。详见1.2和1.3。</p><h3 id="1-2-listener-read-cb的实现"><a href="#1-2-listener-read-cb的实现" class="headerlink" title="1.2 listener_read_cb的实现"></a>1.2 listener_read_cb的实现</h3><p>libevent的源码中listener_read_cb的实现大致是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">listener_read_cb(evutil_socket_t fd, short what, void *p)</span><br><span class="line">&#123;</span><br><span class="line">    ...省略</span><br><span class="line">while (1) &#123;</span><br><span class="line">struct sockaddr_storage ss;</span><br><span class="line">ev_socklen_t socklen &#x3D; sizeof(ss);</span><br><span class="line">evutil_socket_t new_fd &#x3D; evutil_accept4_(fd, (struct sockaddr*)&amp;ss, &amp;socklen, lev-&gt;accept4_flags);</span><br><span class="line">if (new_fd &lt; 0)</span><br><span class="line">break;</span><br><span class="line">if (socklen &#x3D;&#x3D; 0) &#123;</span><br><span class="line">&#x2F;* This can happen with some older linux kernels in</span><br><span class="line"> * response to nmap. *&#x2F;</span><br><span class="line">evutil_closesocket(new_fd);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        ...省略</span><br><span class="line">++lev-&gt;refcnt;</span><br><span class="line">cb &#x3D; lev-&gt;cb;</span><br><span class="line">user_data &#x3D; lev-&gt;user_data;</span><br><span class="line">UNLOCK(lev);</span><br><span class="line">cb(lev, new_fd, (struct sockaddr*)&amp;ss, (int)socklen,</span><br><span class="line">    user_data);</span><br><span class="line">    ...省略</span><br><span class="line">&#125;</span><br><span class="line">    ...省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>listen的socket收到读事件后，调用accept生成一个新的socket（新连接的socket）然后执行回调cb（#3的listenCallback）。</p><h3 id="1-3-continueFilterChain的实现"><a href="#1-3-continueFilterChain的实现" class="headerlink" title="1.3 continueFilterChain的实现"></a>1.3 continueFilterChain的实现</h3><p>continueFilterChain是取出当前listener配置的所有listener_fileters，按照配置的顺序执行每个filter，如果某个filter需要的数据（data）的数量（字节数）还不够，当前的循环会被中断，在这个filter内部会重新注册一个事件去监听socket的读事件。等到新的读事件来。continueFilterChain的处理具体逻辑先不具体讲，后面2.1讲http_inspector的时候再回头讲。</p><p>如果所有的filter执行（执行是调用每个filter的onAccept函数）都没问题，就行执行newConnection()创建一个新的connection（这里的连接不是tcp连接，而是envoy内的概念）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ConnectionHandlerImpl::ActiveTcpSocket::continueFilterChain(<span class="keyword">bool</span> success) &#123;</span><br><span class="line">  <span class="keyword">if</span> (success) &#123;</span><br><span class="line">    <span class="keyword">bool</span> no_error = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//重新开始执行循环？？ 下面有一行代码在退出前，执行了iter_ = accept_filters_.end();</span></span><br><span class="line">    <span class="keyword">if</span> (iter_ == accept_filters_.end()) &#123;</span><br><span class="line">      iter_ = accept_filters_.begin();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      iter_ = <span class="built_in">std</span>::next(iter_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; iter_ != accept_filters_.end(); iter_++) &#123;</span><br><span class="line">      Network::FilterStatus status = (*iter_)-&gt;onAccept(*<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (status == Network::FilterStatus::StopIteration) &#123;</span><br><span class="line">        <span class="comment">// The filter is responsible for calling us again at a later time to continue the filter</span></span><br><span class="line">        <span class="comment">// chain from the next filter.</span></span><br><span class="line">        <span class="comment">// 有的listener_filter需要执行完后中断本次循环</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!socket().ioHandle().isOpen()) &#123;</span><br><span class="line">          <span class="comment">// break the loop but should not create new connection</span></span><br><span class="line">          no_error = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// Blocking at the filter but no error</span></span><br><span class="line">          <span class="comment">// return 调用栈退出，等待下一个事件的到来（本次事件处理结束，把CPU让给event_base)</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Successfully ran all the accept filters.</span></span><br><span class="line">    <span class="keyword">if</span> (no_error) &#123;</span><br><span class="line">      newConnection();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Signal the caller that no extra filter chain iteration is needed.</span></span><br><span class="line">      iter_ = accept_filters_.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Filter execution concluded, unlink and delete this ActiveTcpSocket if it was linked.</span></span><br><span class="line">  <span class="keyword">if</span> (inserted()) &#123;</span><br><span class="line">  <span class="comment">// 删除ActiveTcpSocket对象，这个连接已经断了</span></span><br><span class="line">    unlink();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-listener-filters的执行顺序"><a href="#1-4-listener-filters的执行顺序" class="headerlink" title="1.4 listener filters的执行顺序"></a>1.4 listener filters的执行顺序</h3><p>在listener的配置中，listener filters的配置是在一个数组中的，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;listenerFilters&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;envoy.listener.tls_inspector&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;envoy.listener.http_inspector&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先执行的是tls_inspector再到http_inspector。</p><h2 id="2-filter的功能"><a href="#2-filter的功能" class="headerlink" title="2. filter的功能"></a>2. filter的功能</h2><h3 id="2-1envoy-listener-http-inspector功能"><a href="#2-1envoy-listener-http-inspector功能" class="headerlink" title="2.1envoy.listener.http_inspector功能"></a>2.1envoy.listener.http_inspector功能</h3><p>http_inspector的功能是：检查是否是HTTP的请求（HTTP需要是RawBuffer,不是RawBuffer，这个逻辑执行会退出，继续执行下一个filter的逻辑。 RawBuffer是没有经过加密的，换言之是不是TLS、也不是QUIC）。HTTP的请求类型包括：HTTP/1.0、 HTTP/1.1和HTTP/2（h2c)。如果不是HTTP请求，这个filter也不会截流，直接交到下一个filter处理。</p><p>来看一下具体实现的代码看continueFilterChain和http_inspector的onAccept代码：</p><p>在continueFilterChain的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for (; iter_ !&#x3D; accept_filters_.end(); iter_++) &#123;</span><br><span class="line">  Network::FilterStatus status &#x3D; (*iter_)-&gt;onAccept(*this);</span><br><span class="line">  if (status &#x3D;&#x3D; Network::FilterStatus::StopIteration) &#123;</span><br><span class="line">   </span><br><span class="line">    if (!socket().ioHandle().isOpen()) &#123;</span><br><span class="line">      &#x2F;&#x2F; break the loop but should not create new connection</span><br><span class="line">      no_error &#x3D; false;</span><br><span class="line">      break;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; Blocking at the filter but no error</span><br><span class="line">      &#x2F;&#x2F; return 调用栈退出，等待下一个事件的到来（本次事件处理结束，把CPU让给event_base)</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在continueFilterChain的(*iter_)-&gt;onAccept(*this)中执行到了http_inspector的onAccept代码。如果http_inspector返回Network::FilterStatus::StopIteration，那么这个事件的回调暂时return掉，直接退出了。http_inspector返回Network::FilterStatus::StopIteration之前做的一件事就是注册一个回调函数cb（cb最终还是会调用continueFilterChain函数）等待这个TCP连接的下一个事件到来时候重新执行cb。</p><p>http_inspector的onAccept代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Network::FilterStatus Filter::onAccept(Network::ListenerFilterCallbacks&amp; cb) &#123;</span><br><span class="line">  ENVOY_LOG(debug, &quot;http inspector: new connection accepted&quot;);</span><br><span class="line"></span><br><span class="line">  const Network::ConnectionSocket&amp; socket &#x3D; cb.socket();</span><br><span class="line"></span><br><span class="line">  const absl::string_view transport_protocol &#x3D; socket.detectedTransportProtocol();</span><br><span class="line">  &#x2F;&#x2F; 如果有其他listener filter设置了这个不是HTTP（RawBuffer是指HTTP）</span><br><span class="line">  if (!transport_protocol.empty() &amp;&amp;</span><br><span class="line">      transport_protocol !&#x3D; TransportSockets::TransportProtocolNames::get().RawBuffer) &#123;</span><br><span class="line">    ENVOY_LOG(trace, &quot;http inspector: cannot inspect http protocol with transport socket &#123;&#125;&quot;,</span><br><span class="line">              transport_protocol);</span><br><span class="line">    return Network::FilterStatus::Continue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cb_ &#x3D; &amp;cb;</span><br><span class="line">  const ParseState parse_state &#x3D; onRead();</span><br><span class="line">  switch (parse_state) &#123;</span><br><span class="line">  case ParseState::Error:</span><br><span class="line">    &#x2F;&#x2F; As per discussion in https:&#x2F;&#x2F;github.com&#x2F;envoyproxy&#x2F;envoy&#x2F;issues&#x2F;7864</span><br><span class="line">    &#x2F;&#x2F; we don&#39;t add new enum in FilterStatus so we have to signal the caller</span><br><span class="line">    &#x2F;&#x2F; the new condition.</span><br><span class="line">    cb.socket().close();</span><br><span class="line">    return Network::FilterStatus::StopIteration;</span><br><span class="line">  case ParseState::Done:</span><br><span class="line">    return Network::FilterStatus::Continue;</span><br><span class="line">  case ParseState::Continue:</span><br><span class="line">    &#x2F;&#x2F; do nothing but create the event</span><br><span class="line">    ASSERT(file_event_ &#x3D;&#x3D; nullptr);</span><br><span class="line">    file_event_ &#x3D; cb.dispatcher().createFileEvent(</span><br><span class="line">        socket.ioHandle().fd(),</span><br><span class="line">        [this](uint32_t events) &#123;</span><br><span class="line">         ..省略回调函数的实现</span><br><span class="line">        &#125;,</span><br><span class="line">        Event::FileTriggerType::Edge, Event::FileReadyType::Read | Event::FileReadyType::Closed);</span><br><span class="line">    return Network::FilterStatus::StopIteration;</span><br><span class="line">  &#125;</span><br><span class="line">  NOT_REACHED_GCOVR_EXCL_LINE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们重点关注：</p><ul><li>onRead()</li><li>cb.dispatcher().createFileEvent(）</li></ul><p>其中，onRead（详见2.1.1）做的事情就是读取(peek)当前连接的数据包（data），然后看看是不是HTTP的请求（具体实现是读取最大8K的数据，然后查看第一行的数据（每行一\r\n结尾））是否是一个HTTP的请求。</p><ul><li>如果还没读到第一行数据，并且数据没有8K，onRead就会返回ParseState::Continue。（前面讲过，http_inspector有没有检测到HTTP请求不重要，都不会截流，因此这里只关心是否读到第一行数据）</li><li>如果读到了第一行数据，onRead就会返回ParseState::Done，onAccept就会返回Network::FilterStatus::Continue，继续执行下一个filter的逻辑。</li></ul><p>我们重点关注没有读到第一行数据的情况，没有读到第一行后，onAccpet就会执行cb.dispatcher().createFileEvent（）创建一个监听read和closed的事件。注册完事件监听后，返回一个Network::FilterStatus::StopIteration让continueFilterChain让出当前的CPU（执行return）。因为cb.dispatcher().createFileEvent（）已经注册过回调函数了，下次新连接有事件到的时候，会有回调函数会被执行的。</p><p>刚刚注册的回调函数就是如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ENVOY_LOG(trace, &quot;http inspector event: &#123;&#125;&quot;, events);</span><br><span class="line">&#x2F;&#x2F; inspector is always peeking and can never determine EOF.</span><br><span class="line">&#x2F;&#x2F; Use this event type to avoid listener timeout on the OS supporting</span><br><span class="line">&#x2F;&#x2F; FileReadyType::Closed.</span><br><span class="line">bool end_stream &#x3D; events &amp; Event::FileReadyType::Closed;</span><br><span class="line"></span><br><span class="line">const ParseState parse_state &#x3D; onRead();</span><br><span class="line">switch (parse_state) &#123;</span><br><span class="line">case ParseState::Error:</span><br><span class="line">file_event_.reset();</span><br><span class="line">cb_-&gt;continueFilterChain(false);</span><br><span class="line">break;</span><br><span class="line">case ParseState::Done:</span><br><span class="line">  &#x2F;&#x2F; file_event_.reset掉，表明这个listener_filter已经处理完了本次的所有逻辑，就算没有检测到HTTP的版本，也是不会报错的。</span><br><span class="line">&#x2F;&#x2F; reset会删除事件，释放内存时候调用ImplBase的析构函数</span><br><span class="line">file_event_.reset();</span><br><span class="line">&#x2F;&#x2F; Do not skip following listener filters.</span><br><span class="line">cb_-&gt;continueFilterChain(true);</span><br><span class="line">break;</span><br><span class="line">case ParseState::Continue:</span><br><span class="line">if (end_stream) &#123;</span><br><span class="line">  &#x2F;&#x2F; Parser fails to determine http but the end of stream is reached. Fallback to</span><br><span class="line">  &#x2F;&#x2F; non-http.</span><br><span class="line">  done(false);</span><br><span class="line">  file_event_.reset();</span><br><span class="line">  cb_-&gt;continueFilterChain(true);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; do nothing but wait for the next event</span><br><span class="line">&#x2F;&#x2F; 这里面的break相当于return掉函数，直接等待下一个事件（正常是读事件，除非客户端close掉了连接）</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是内部再次执行onRead函数，读取第一行数据，如果读取到了，就调用cb_-&gt;continueFilterChain(true)重新回到下一个filter的执行逻辑中（这里又回到了continueFilterChain的逻辑了）。如果还是读不到第一行数据，就暂时return掉本次的回调，再次等到事件的到来。总之，这个filter一定会等到第一行的数据读取到（或者超过8K的数据）才执行下一个的filter的onAccept(如果配置了的话)</p><p>因此，这里就回答了continueFilterChain为什么会被多次调用的问题了。因为如果filter要读取更多的数据去决策，但是当前的数据还不够决策的时候，只能让出当前的执行CPU，等到下一次事件到来时候再去判断，再在回调函数中执行continueFilterChain函数。</p><h4 id="2-1-1-http-inspector的onRead函数"><a href="#2-1-1-http-inspector的onRead函数" class="headerlink" title="2.1.1 http inspector的onRead函数"></a>2.1.1 http inspector的onRead函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ParseState Filter::onRead() &#123;</span><br><span class="line">  auto&amp; os_syscalls &#x3D; Api::OsSysCallsSingleton::get();</span><br><span class="line">  const Network::ConnectionSocket&amp; socket &#x3D; cb_-&gt;socket();</span><br><span class="line">  const Api::SysCallSizeResult result &#x3D;</span><br><span class="line">      os_syscalls.recv(socket.ioHandle().fd(), buf_, Config::MAX_INSPECT_SIZE, MSG_PEEK);</span><br><span class="line">  ENVOY_LOG(trace, &quot;http inspector: recv: &#123;&#125;&quot;, result.rc_);</span><br><span class="line">  if (result.rc_ &#x3D;&#x3D; -1 &amp;&amp; result.errno_ &#x3D;&#x3D; EAGAIN) &#123;</span><br><span class="line">    return ParseState::Continue;</span><br><span class="line">  &#125; else if (result.rc_ &lt; 0) &#123;</span><br><span class="line">    config_-&gt;stats().read_error_.inc();</span><br><span class="line">    return ParseState::Error;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const auto parse_state &#x3D;</span><br><span class="line">      parseHttpHeader(absl::string_view(reinterpret_cast&lt;const char*&gt;(buf_), result.rc_));</span><br><span class="line">  switch (parse_state) &#123;</span><br><span class="line">  case ParseState::Continue:</span><br><span class="line">    &#x2F;&#x2F; do nothing but wait for the next event</span><br><span class="line">    return ParseState::Continue;</span><br><span class="line">  case ParseState::Error:</span><br><span class="line">    done(false);</span><br><span class="line">    return ParseState::Done;</span><br><span class="line">  case ParseState::Done:</span><br><span class="line">    done(true);</span><br><span class="line">    return ParseState::Done;</span><br><span class="line">  &#125;</span><br><span class="line">  NOT_REACHED_GCOVR_EXCL_LINE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是PEEK一下当前的连接的数据包（并不是真正读取出来，然后执行parseHttpHeader的函数（具体不再深入，怎么判断一个请求是HTTP请求了）。</p><h3 id="2-2-envoy-listener-tls-inspector的功能"><a href="#2-2-envoy-listener-tls-inspector的功能" class="headerlink" title="2.2 envoy.listener.tls_inspector的功能"></a>2.2 envoy.listener.tls_inspector的功能</h3><p>tls的处理逻辑跟http inspector大同小异，也是通过读取一些数据来判断，跟continueFilterChain的交互流程相似，不再细说，下面只讨论功能。</p><p><strong>功能：</strong>检查是否是tls的请求，如果是tls请求则:</p><ol><li>设置当前的requestServerName</li></ol><blockquote><p>cb_-&gt;socket().setRequestedServerName(name);</p></blockquote><ol start="2"><li>这是transportProtocol为TLS</li></ol><blockquote><p>cb_-&gt;socket().setDetectedTransportProtocol(<br>        TransportSockets::TransportProtocolNames::get().Tls);</p></blockquote><p>如果不是tls请求，则跳过（认为没有问题），不会因为这个请求没有加密（tls）就不让请求通过</p><h3 id="2-3-envoy-listener-original-dst的功能"><a href="#2-3-envoy-listener-original-dst的功能" class="headerlink" title="2.3 envoy.listener.original_dst的功能"></a>2.3 envoy.listener.original_dst的功能</h3><p>功能：获取原始的目的地址，修改local_address(因为envoy的local地址就是客户端的dst地址）</p><p>代码逻辑比较简单，不需要读取数据，只需要看当前连接的一些信息就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Network::FilterStatus OriginalDstFilter::onAccept(Network::ListenerFilterCallbacks&amp; cb) &#123;</span><br><span class="line">  ENVOY_LOG(debug, &quot;original_dst: New connection accepted&quot;);</span><br><span class="line">  Network::ConnectionSocket&amp; socket &#x3D; cb.socket();</span><br><span class="line">  const Network::Address::Instance&amp; local_address &#x3D; *socket.localAddress();</span><br><span class="line"></span><br><span class="line">  if (local_address.type() &#x3D;&#x3D; Network::Address::Type::Ip) &#123;</span><br><span class="line">    Network::Address::InstanceConstSharedPtr original_local_address &#x3D;</span><br><span class="line">        getOriginalDst(socket.ioHandle().fd());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; A listener that has the use_original_dst flag set to true can still receive</span><br><span class="line">    &#x2F;&#x2F; connections that are NOT redirected using iptables. If a connection was not redirected,</span><br><span class="line">    &#x2F;&#x2F; the address returned by getOriginalDst() matches the local address of the new socket.</span><br><span class="line">    &#x2F;&#x2F; In this case the listener handles the connection directly and does not hand it off.</span><br><span class="line">    if (original_local_address) &#123;</span><br><span class="line">      &#x2F;&#x2F; Restore the local address to the original one.</span><br><span class="line">      socket.restoreLocalAddress(original_local_address);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Network::FilterStatus::Continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重点关注</p><ul><li>original_local_address =<pre><code>getOriginalDst(socket.ioHandle().fd())</code></pre></li><li>socket.restoreLocalAddress(original_local_address);</li></ul><p>流程就是获取原来的目的地址（只有经过DNAT或REDIRECT才有原来的目的地址），如果获取到了原来的目的地址，就把当前连接的localAddress设置为原来的目的地址。localAddress其实就是envoy这边的连接地址，如果这个连接是经过DNAT（举例），然后又设置了这个filter，那么在envoy内部的元数据localAddress就改为原来的目的地址。</p><h3 id="2-4-envoy-listener-original-src的功能"><a href="#2-4-envoy-listener-original-src的功能" class="headerlink" title="2.4 envoy.listener.original_src的功能"></a>2.4 envoy.listener.original_src的功能</h3><p>数据的走向可以简化为：</p><blockquote><p>downstream &lt;–&gt; envoy &lt;–&gt; upstream</p></blockquote><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">OriginalSrcFilter::OriginalSrcFilter(const Config&amp; config) : config_(config) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Network::FilterStatus OriginalSrcFilter::onAccept(Network::ListenerFilterCallbacks&amp; cb) &#123;</span><br><span class="line">  auto&amp; socket &#x3D; cb.socket();</span><br><span class="line">  auto address &#x3D; socket.remoteAddress();</span><br><span class="line">  ASSERT(address);</span><br><span class="line"></span><br><span class="line">  ENVOY_LOG(debug,</span><br><span class="line">            &quot;Got a new connection in the original_src filter for address &#123;&#125;. Marking with &#123;&#125;&quot;,</span><br><span class="line">            address-&gt;asString(), config_.mark());</span><br><span class="line"></span><br><span class="line">  if (address-&gt;type() !&#x3D; Network::Address::Type::Ip) &#123;</span><br><span class="line">    &#x2F;&#x2F; nothing we can do with this.</span><br><span class="line">    return Network::FilterStatus::Continue;</span><br><span class="line">  &#125;</span><br><span class="line">  auto options_to_add &#x3D;</span><br><span class="line">      Filters::Common::OriginalSrc::buildOriginalSrcOptions(std::move(address), config_.mark());</span><br><span class="line">  socket.addOptions(std::move(options_to_add));</span><br><span class="line">  return Network::FilterStatus::Continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重点关注buildOriginalSrcOptions设置了和socket.addOptions。配置了一些socket的参数（没细看）使得envoy连接到upstream的时候使用的源ip地址变成downstream的地址，这样upstream就认为请求是downstream发送过来的。</p><p>官网上的功能描述比较详细：</p><ol><li>使用downstream的地址情况</li></ol><blockquote><p>The original source listener filter replicates the downstream remote address of the connection on the upstream side of Envoy. For example, if a downstream connection connects to Envoy with IP address 10.1.2.3, then Envoy will connect to the upstream with source IP 10.1.2.3.</p></blockquote><ol start="2"><li>使用pp包内部的地址情况<br>另外还有一个就是proxy Protocol和这个filter的配合使用</li></ol><blockquote><p>Interaction with Proxy Protocol<br>If the connection has not had its source address translated or proxied, then Envoy can simply use the existing connection information to build the correct downstream remote address. However, if this is not true, a Proxy Protocol filter may be used to extract the downstream remote address.</p></blockquote><p>也就是说，如果这个listener配置了original_src和proxy_protocol（这个先配置），那么连接到upstream时候使用的源地址改为pp包内的地址。</p><h3 id="2-5-envoy-listener-proxy-protocol的功能"><a href="#2-5-envoy-listener-proxy-protocol的功能" class="headerlink" title="2.5 envoy.listener.proxy_protocol的功能"></a>2.5 envoy.listener.proxy_protocol的功能</h3><p>功能：读取（首先是PEEK，如果PEEK到时发现是pp包就真正读取出来）连接的数据，获取到真正的源ip和源端口。需要注意的是：<strong>如果配置了这个filter，一定要带proxy protocol</strong>，不然正常的访问会得到（识别不到请求）</p><blockquote><p>lijiancai@LAPTOP-U28497J3:~$curl <a href="http://192.168.42.128:78/">http://192.168.42.128:78</a></p><p>curl: (52) Empty reply from server</p></blockquote><p>这个就是proxy_protocol与其他四个filter不一样的地方，其他四个filter不会截流，这个filter会（当然是只有在没有识别到pp包的情况下会截流）</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Envoy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Envoy扩展功能—Webassembly</title>
      <link href="../2021/02/23/Envoy%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD%E2%80%94Webassembly/"/>
      <url>../2021/02/23/Envoy%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD%E2%80%94Webassembly/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="1-软件版本声明"><a href="#1-软件版本声明" class="headerlink" title="1. 软件版本声明"></a>1. 软件版本声明</h2><ul><li>Istio的版本是release-1.8，对应的源码地址是：<a href="https://github.com/istio/istio/tree/release-1.8">https://github.com/istio/istio/tree/release-1.8</a></li><li>Envoy的版本（Istio官方自己维护了一份Envoy的代码，方便其功能扩展）是 release-1.8，对应的源码地址是：<a href="https://github.com/istio/envoy/tree/release-1.8">https://github.com/istio/envoy/tree/release-1.8</a> </li></ul><h2 id="2-Envoy目前支持Wasm扩展的功能有哪些"><a href="#2-Envoy目前支持Wasm扩展的功能有哪些" class="headerlink" title="2. Envoy目前支持Wasm扩展的功能有哪些"></a>2. Envoy目前支持Wasm扩展的功能有哪些</h2><ul><li><p>Network Filter （TCP或UDP）上扩展，代码路径是<code>source/extensions/filters/network/wasm</code></p></li><li><p>HTTP Filter 上扩展,代码路径是<code>source/extensions/filters/http/wasm</code> </p></li><li><p>Access Logger 上扩展，代码路径是<code>source/extensions/access_loggers/wasm</code></p><p>日志输出能够拿到的上下文不多，所以目前这个功能比较鸡肋。</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20210304181032014.png" alt="image-20210304181032014"></p></li><li><p>Boostrap 上扩展，代码路径是<code>source/extensions/bootstrap/wasm</code></p></li><li><p>Stat Sink 上扩展，代码路径是`source/extensions/stat_sinks/wasm. (V8的运行时还没支持，应该说除了NullVM都还没支持)</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20210304173647637.png" alt="image-20210304173647637"></p></li></ul><h2 id="3-目前Envoy支持的虚拟机运行时"><a href="#3-目前Envoy支持的虚拟机运行时" class="headerlink" title="3. 目前Envoy支持的虚拟机运行时"></a>3. 目前Envoy支持的虚拟机运行时</h2><ul><li>V8</li><li>NullVM</li><li>Wavm</li><li>WasmVMBase</li></ul><p>本文只介绍两种运行时，一种是NullVM和V8。首先说一下NullVM这种运行时，加载Wasm的代码的方式是和V8不一样的。NullVM这种要在Envoy二进制编译时候注册虚拟机的。我们可以看一下NullVM是如何创建一个虚拟机的</p><p>现看一下Istio中的Envoy里面是如何配置NullVM这种虚拟机的:</p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20210304162428704.png" alt="image-20210304162428704" style="zoom: 67%;" /><p>inline_string： 指虚拟机的模板是什么</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NullVm::load</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">bool</span> <span class="comment">/* allow_precompiled */</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!null_vm_plugin_factories_)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// null_vm_plugin_factories_要有inline_string中指定的名字才行，不然虚拟机创建不出来</span></span><br><span class="line">  <span class="keyword">auto</span> factory = (*null_vm_plugin_factories_)[name];</span><br><span class="line">  <span class="keyword">if</span> (!factory)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  plugin_name_ = name;</span><br><span class="line">  plugin_ = factory();</span><br><span class="line">  plugin_-&gt;wasm_vm_ = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数RegisterNullVmPluginFactory在被调用的时候，就会注册inline_string指定的虚拟机工厂类</span></span><br><span class="line">RegisterNullVmPluginFactory::RegisterNullVmPluginFactory(<span class="built_in">std</span>::string_view name,</span><br><span class="line">                                                         NullVmPluginFactory factory) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!null_vm_plugin_factories_)</span><br><span class="line">    null_vm_plugin_factories_ =</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">std</span>::remove_reference&lt;<span class="keyword">decltype</span>(*null_vm_plugin_factories_)&gt;::type;</span><br><span class="line">  (*null_vm_plugin_factories_)[<span class="built_in">std</span>::<span class="built_in">string</span>(name)] = factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实， NullVM就没有实现WASM的功能，代码还是运行在和Envoy的源码一样，没什么区别。这些inline_string 使用的虚拟机，都是Istio自己扩展的，详细代码在：<a href="https://github.com/istio/proxy/tree/1.8.2/extensions">https://github.com/istio/proxy/tree/1.8.2/extensions</a></p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20210304164505184.png" alt="image-20210304164505184"></p><p>至于V8虚拟机，则是我们代码Demo使用的运行时，其在最新版本的Envoy中可以做到一些权限的控制（fd、内存等资源的限制）。</p><h2 id="4-Wasm的运行模型和隔离性"><a href="#4-Wasm的运行模型和隔离性" class="headerlink" title="4. Wasm的运行模型和隔离性"></a>4. Wasm的运行模型和隔离性</h2><p>因为Envoy中的WASM机制话题比较大，具体的运行模型会另起一个文档说明，下面说一些结论。</p><ul><li><p>Envoy使用vm_key用于标识不同的虚拟机，vm_key由三个元素组成： vm_id , vm_config 和 code(wasm编译出来后的字节码)</p></li><li><p>每个worker线程中的虚拟机都是独立的，同一个vm_key在不同的worker线程之间都是不同的实例。</p></li><li><p>代码执行过程中，不可抛异常，否则虚拟机会退出。下面代码是不能执行的，有异常捕捉。(<a href="https://github.com/envoyproxy/envoy-wasm/issues/9">https://github.com/envoyproxy/envoy-wasm/issues/9</a>)</p></li><li><p>WASM运行中，不能使用条件变量、锁等用于同步的机制。</p></li><li><p>WASM中向外部发起http或grpc都需要通过Envoy来代理的。</p></li></ul><h2 id="5-Network-Filter中的Wasm插件开发和部署"><a href="#5-Network-Filter中的Wasm插件开发和部署" class="headerlink" title="5. Network Filter中的Wasm插件开发和部署"></a>5. Network Filter中的Wasm插件开发和部署</h2><p>Demo的代码如下,重点放在ExampleContext::onDownstreamData和ExampleContext::onUpstreamData上，这两个函数是是Neteork Filter中会被调用的。至于Envoy是如何和这两个函数联系在一起以及其运行的模型，需要较大的篇幅描述，放在一篇独立的文章中详述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;proxy_wasm_intrinsics.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleRootContext</span> :</span> <span class="keyword">public</span> RootContext &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; count&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ExampleRootContext</span><span class="params">(<span class="keyword">uint32_t</span> id, <span class="built_in">std</span>::string_view root_id)</span></span></span><br><span class="line"><span class="function">      : <span class="title">RootContext</span><span class="params">(id, root_id)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">atomicAdd</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count++; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">onStart</span><span class="params">(<span class="keyword">size_t</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">onConfigure</span><span class="params">(<span class="keyword">size_t</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleContext</span> :</span> <span class="keyword">public</span> Context &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ExampleContext</span><span class="params">(<span class="keyword">uint32_t</span> id, RootContext* root)</span> : <span class="title">Context</span><span class="params">(id, root)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">FilterHeadersStatus <span class="title">onRequestHeaders</span><span class="params">(<span class="keyword">uint32_t</span> headers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">bool</span> end_of_stream)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">FilterDataStatus <span class="title">onRequestBody</span><span class="params">(<span class="keyword">size_t</span> body_buffer_length,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">bool</span> end_of_stream)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">FilterHeadersStatus <span class="title">onResponseHeaders</span><span class="params">(<span class="keyword">uint32_t</span> headers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">bool</span> end_of_stream)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">FilterStatus <span class="title">onUpstreamData</span><span class="params">(<span class="keyword">size_t</span> bz, <span class="keyword">bool</span> end)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">FilterStatus <span class="title">onDownstreamData</span><span class="params">(<span class="keyword">size_t</span> bz, <span class="keyword">bool</span> end)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">FilterStatus <span class="title">onNewConnection</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">FilterDataStatus <span class="title">onResponseBody</span><span class="params">(<span class="keyword">size_t</span> body_buffer_length,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">bool</span> end_of_stream)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onDone</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onLog</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onDelete</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterContextFactory <span class="title">register_ExampleContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    CONTEXT_FACTORY(ExampleContext), ROOT_FACTORY(ExampleRootContext),</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;network_filter_demo&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ExampleRootContext::onStart</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>&#123;</span><br><span class="line">  LOG_TRACE(<span class="string">&quot;onStart&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ExampleRootContext::onConfigure</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>&#123;</span><br><span class="line">  LOG_TRACE(<span class="string">&quot;onConfigure&quot;</span>);</span><br><span class="line">  proxy_set_tick_period_milliseconds(<span class="number">1000</span>);  <span class="comment">// 1 sec</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleRootContext::onTick</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleContext::onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LOG_WARN(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;onCreate &quot;</span> + <span class="built_in">std</span>::to_string(id())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FilterStatus <span class="title">ExampleContext::onNewConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FilterStatus::Continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FilterStatus <span class="title">ExampleContext::onDownstreamData</span><span class="params">(<span class="keyword">size_t</span> bz, <span class="keyword">bool</span> end)</span> </span>&#123;</span><br><span class="line">  LOG_WARN(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;onDownStreamData recieve bytes size:&quot;</span> + <span class="built_in">std</span>::to_string(bz)));</span><br><span class="line">  <span class="keyword">return</span> FilterStatus::Continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FilterStatus <span class="title">ExampleContext::onUpstreamData</span><span class="params">(<span class="keyword">size_t</span> bz, <span class="keyword">bool</span> end)</span> </span>&#123;</span><br><span class="line">  LOG_WARN(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;onUpstreamData recieve bytes size:&quot;</span> + <span class="built_in">std</span>::to_string(bz)));</span><br><span class="line">  <span class="keyword">return</span> FilterStatus::Continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FilterHeadersStatus <span class="title">ExampleContext::onRequestHeaders</span><span class="params">(<span class="keyword">uint32_t</span>, <span class="keyword">bool</span>)</span> </span>&#123;</span><br><span class="line">  LOG_DEBUG(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;onRequestHeaders &quot;</span>) + <span class="built_in">std</span>::to_string(id()));</span><br><span class="line">  <span class="keyword">return</span> FilterHeadersStatus::Continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FilterHeadersStatus <span class="title">ExampleContext::onResponseHeaders</span><span class="params">(<span class="keyword">uint32_t</span>, <span class="keyword">bool</span>)</span> </span>&#123;</span><br><span class="line">  LOG_DEBUG(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;onResponseHeaders &quot;</span>) + <span class="built_in">std</span>::to_string(id()));</span><br><span class="line">  <span class="keyword">return</span> FilterHeadersStatus::Continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FilterDataStatus <span class="title">ExampleContext::onRequestBody</span><span class="params">(<span class="keyword">size_t</span> body_buffer_length,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">bool</span> <span class="comment">/* end_of_stream */</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FilterDataStatus::Continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FilterDataStatus <span class="title">ExampleContext::onResponseBody</span><span class="params">(<span class="keyword">size_t</span> <span class="comment">/* body_buffer_length */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">bool</span> <span class="comment">/* end_of_stream */</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FilterDataStatus::Continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleContext::onDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LOG_WARN(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;onDone &quot;</span> + <span class="built_in">std</span>::to_string(id())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleContext::onLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LOG_WARN(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;onLog &quot;</span> + <span class="built_in">std</span>::to_string(id())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleContext::onDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LOG_WARN(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;onDelete &quot;</span> + <span class="built_in">std</span>::to_string(id())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExampleContext::onDownstreamData是客户端（DownStream）发送数据到Envoy的时候会被调用，ExampleContext::onUpstreamData是上游服务器中（Upstream）发送数据回Envoy的时候会被调用。</p><p>envoy的配置文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">admin:</span></span><br><span class="line">  <span class="attr">access_log_path:</span> <span class="string">&quot;/home/lijiancai/admin_access.log&quot;</span></span><br><span class="line">  <span class="attr">address:</span></span><br><span class="line">    <span class="attr">socket_address:</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">      <span class="attr">port_value:</span> <span class="number">9901</span></span><br><span class="line"><span class="attr">static_resources:</span></span><br><span class="line">  <span class="attr">listeners:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">listener_0</span></span><br><span class="line">      <span class="attr">address:</span></span><br><span class="line">        <span class="attr">socket_address:</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">          <span class="attr">port_value:</span> <span class="number">10000</span></span><br><span class="line">      <span class="attr">filter_chains:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.network.wasm</span></span><br><span class="line">              <span class="attr">typed_config:</span></span><br><span class="line">                <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/udpa.type.v1.TypedStruct</span></span><br><span class="line">                <span class="attr">type_url:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.network.wasm.v3.Wasm</span></span><br><span class="line">                <span class="attr">value:</span></span><br><span class="line">                  <span class="attr">config:</span></span><br><span class="line">                    <span class="attr">name:</span> <span class="string">my_plugin</span></span><br><span class="line">                    <span class="attr">root_id:</span> <span class="string">network_filter_demo</span></span><br><span class="line">                    <span class="attr">vm_config:</span></span><br><span class="line">                      <span class="attr">runtime:</span> <span class="string">envoy.wasm.runtime.v8</span></span><br><span class="line">                      <span class="attr">vm_id:</span> <span class="string">demo1</span></span><br><span class="line">                      <span class="attr">code:</span></span><br><span class="line">                        <span class="attr">local:</span></span><br><span class="line">                          <span class="attr">filename:</span> <span class="string">&quot;./network_filter_demo.wasm&quot;</span></span><br><span class="line">                      <span class="attr">allow_precompiled:</span> <span class="literal">true</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.network.tcp_proxy</span></span><br><span class="line">              <span class="attr">typed_config:</span></span><br><span class="line">                <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy</span></span><br><span class="line">                <span class="attr">stat_prefix:</span> <span class="string">service_goole_tcp</span></span><br><span class="line">                <span class="attr">cluster:</span> <span class="string">service_google</span></span><br><span class="line">  <span class="attr">clusters:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">service_google</span></span><br><span class="line">      <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">LOGICAL_DNS</span></span><br><span class="line">      <span class="attr">dns_lookup_family:</span> <span class="string">V4_ONLY</span></span><br><span class="line">      <span class="attr">lb_policy:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line">      <span class="attr">load_assignment:</span></span><br><span class="line">        <span class="attr">cluster_name:</span> <span class="string">service_google</span></span><br><span class="line">        <span class="attr">endpoints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">                  <span class="attr">address:</span></span><br><span class="line">                    <span class="attr">socket_address:</span></span><br><span class="line">                      <span class="attr">address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">                      <span class="attr">port_value:</span> <span class="number">8888</span></span><br></pre></td></tr></table></figure><p>调试步骤：</p><ol><li><p>启动upstream ：<code>nc -l -p 8888</code></p></li><li><p>启动envoy： ./envoy -c network_filter_demo.yaml</p></li><li><p>启动downstream: nc 127.0.0.1 10000</p></li><li><p>在upstream和downstream都发送一些数据看一下日志输出，日志输出如下</p><blockquote><p>[2021-02-23 16:34:17.408][23601][warning][wasm] [source/extensions/common/wasm/context.cc:1168] wasm log: [envoy-wasm-demo/network_filter_demo.cc:70]::onDownstreamData() onDownStreamData recieve bytes size:2<br>[2021-02-23 16:34:19.189][23601][warning][wasm] [source/extensions/common/wasm/context.cc:1168] wasm log: [envoy-wasm-demo/network_filter_demo.cc:70]::onDownstreamData() onDownStreamData recieve bytes size:4<br>[2021-02-23 16:34:22.677][23601][warning][wasm] [source/extensions/common/wasm/context.cc:1168] wasm log: [envoy-wasm-demo/network_filter_demo.cc:75]::onUpstreamData() onUpstreamData recieve bytes size:5<br>[2021-02-23 16:34:25.094][23601][warning][wasm] [source/extensions/common/wasm/context.cc:1168] wasm log: [envoy-wasm-demo/network_filter_demo.cc:75]::onUpstreamData() onUpstreamData recieve bytes size:3</p></blockquote></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Envoy </tag>
            
            <tag> Webassembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络性能指标</title>
      <link href="../2021/02/23/%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/"/>
      <url>../2021/02/23/%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h1 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h1><p>在讨论网络相关的性能压测工具前，需要知道有哪些指标是用来观察网络性能的。常见的网络性能指标有：</p><ul><li><p>带宽： 链路理论上最大的传输速率，单位是b/s</p></li><li><p>吞吐量：链路在不丢包的情况下最大的数据传输率。</p></li><li><p>网络链路使用率：吞吐量/带宽 ，因为带宽只是理论上的最大传输速率（但是理论往往是比较难达到的），因此在测量的时候，一般都是测量吞吐量（或使用率）。</p></li><li><p>延时： 网络请求发出后，一直到收到响应为止。在不同的维度，延时的意涵有所区别，比如在TCP握手常见，延时表示TCP连接建立时间；如果在3层的数据包的维度，延时就是数据包往返的时间RTT；如果是在TLS握手的维度，延时又是对称加密的密钥协商的用时。主要用于评估网络在不同的压力情况下，网络延时是否符合需求。如果网络压力过大，中间的节点可能会出现排队导致延时变大。</p></li><li><p>PPS：Packet Per Second，表示网络包（以包为单位）的传输速率，常用于评估网络的转发能力。</p></li><li><p>CPS： Connection Per Second，每秒新建连接数，主要用于评估处理新增连接的能力。</p></li><li><p>QPS：Query Per Second，每秒查询数量，主要用于评估业务处理请求的极限。在短连接的场景，QPS～=CPS；在长连接的场景CPS&lt;QPS。</p></li></ul><p>上述的网络指标中，不同的使用场景，需要关注的指标又不太一样。比如</p><ul><li>Web应用或APP等应用层，我们一般需要关注的是HTTP（s）/GRPC的性能，这时候我们关注的是业务的QPS或CPS。</li><li>对于一些游戏服务器或IM的应用，为了支持更大的同时在线人数，通常会基于TCP或UDP的基础上进行客户端和服务端的连接，这些场景需要测试TCP或UDP的性能，关注的指标可以是PPS和延时。</li><li>虚拟化网络设备的运行服务器场景，更多的是3层上的路由转发或UDP包处理，这时候更多关注的是PPS。</li></ul><h1 id="转发层面的性能测试"><a href="#转发层面的性能测试" class="headerlink" title="转发层面的性能测试"></a>转发层面的性能测试</h1><h2 id="带宽测试"><a href="#带宽测试" class="headerlink" title="带宽测试"></a>带宽测试</h2><p>使用工具iperf，步骤如下：</p><ol><li>需要准备两台机器，一台为server，一台为client。在server端，监听一个TCP端口：<code>iperf -s</code>, 此命令会让服务器监听5001端口。</li><li>客户对服务端进行带宽测试，执行 : <code>iperf -c server_ip -t 5</code></li></ol><p>测试报告，客户端输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------</span><br><span class="line">Client connecting to *.*.*.s, TCP port 5001</span><br><span class="line">TCP window size: 64.0 KByte (default)</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">[  3] <span class="built_in">local</span> *.*.*.c port 36582 connected with *.*.*.s port 5001</span><br><span class="line">[ ID] Interval       Transfer     Bandwidth</span><br><span class="line">[  3]  0.0- 5.1 sec   437 MBytes   713 Mbits/sec</span><br></pre></td></tr></table></figure><p>可以看到带宽是713Mb/s,iperf默认是使用TCP进行压测。也可以使用UDP。在业务使用场景，压测时间应该调得更大，减少误差。</p><h2 id="PPS测试"><a href="#PPS测试" class="headerlink" title="PPS测试"></a>PPS测试</h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Networking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go性能基础测试</title>
      <link href="../2021/02/23/Go%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E6%B5%8B%E8%AF%95/"/>
      <url>../2021/02/23/Go%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Go的性能测试Demo"><a href="#Go的性能测试Demo" class="headerlink" title="Go的性能测试Demo"></a>Go的性能测试Demo</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> letterBytes = <span class="string">&quot;dfads;joasdjIFIOSHUIOFHwfhjad;fhjSIDphdfads&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomString</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> b &#123;</span><br><span class="line">b[i]= letterBytes[rand.Intn(<span class="built_in">len</span>(letterBytes))]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> genString <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringsBuilder</span><span class="params">(n <span class="keyword">int</span>, s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> builder strings.Builder</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">builder.WriteString(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> builder.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bytesBuffer</span><span class="params">(n <span class="keyword">int</span>, s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">buf.WriteString(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmark</span><span class="params">(b *testing.B, f genString)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s = randomString(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">f(<span class="number">10000</span>, s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStringsBuilderConcat</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">benchmark(b, stringsBuilder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkBytesBufferConcat</span><span class="params">(b *testing.B)</span></span>  &#123;</span><br><span class="line">benchmark(b, bytesBuffer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行下面的命令，即可进行基准测试。<code>go test -bench=&quot;.*&quot; -benchmem .</code></p><p>输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: helloWorld</span><br><span class="line">BenchmarkStringsBuilderConcat-8             5256            198909 ns/op         1120229 B/op         25 allocs/op</span><br><span class="line">BenchmarkBytesBufferConcat-8                6309            189714 ns/op          903523 B/op         14 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      helloWorld      3.295s</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符编码格式</title>
      <link href="../2021/02/22/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/"/>
      <url>../2021/02/22/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="什么是Unicode"><a href="#什么是Unicode" class="headerlink" title="什么是Unicode"></a>什么是Unicode</h2><p>Unicode可以理解为字符集，由一个国际组织给每个字符分配一个编号（或者叫ID）。记住：Unicode只负责分配ID。</p><p>计算机只能保存0101的二进制格式的数据，所谓在一个字符保存到计算机中其实有两个步骤：</p><ul><li>找到某个字符的Unicode字符编号</li><li>根据字符编号，选择响应的编码格式生成对应的二机制数据</li></ul><p>举个例子：</p><p>Unicode字符集中，“中”的编码编号是4E2D，“国”的编码编号是56FD。但是编码编号相当于一个数字，怎么保存到计算机的存储设备上呢？这时候就是编码对应的存储格式的任务的，Unicode的存储格式有UTF-8、utf-16等存储格式。其中UTF-8的应用比较广泛，就以UTF-8 为例子：“中”的UTF-8格式是：E4B8AD。“国”的UTF-8格式是：E59BBD。 UTF-8是真正保存在计算机存储设备上的数据格式。</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20201230175802402.png" alt="image-20201230175802402"></p><p>Unicode可以理解为一本字典，里面记录了每个字符的编号。至于这些编号怎么对应保存到计算机中呢？就是UTF-8把Unicode的编号转义后保存到计算机中去。因此，Unicode与uft-8不是同一个层次上的东西，UTF-8格式可以说是Unicode的一种实现方式而已。</p><p>因此，我们可以看到Unicode经常推出一些新的字符、表情（😊）等emoji，其实就是在做字符编码编号的事情，给每个字符一个ID。</p><p>资源链接：</p><ul><li>中文的Unicode编码编号查询：<a href="http://www.chi2ko.com/tool/CJK.htm">http://www.chi2ko.com/tool/CJK.htm</a></li><li>中文的UTF-8格式查询：<a href="http://www.shabsin.com/~rshabsin/chineseutf8chars.html">http://www.shabsin.com/~rshabsin/chineseutf8chars.html</a></li><li>Unicode组织的官网：<a href="https://home.unicode.org/">https://home.unicode.org/</a></li></ul><p>编码格式全景图：</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20201230162147496.png" alt="image-20201230162147496"></p><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p>ASCII全称<strong>American Standard Code for Information Interchange</strong>，只有128个字符，从名字就能看出来，一开始设置的时候只考虑到了英文字符的编码，毕竟美帝128个字符就够用了。但是随着计算机技术的发展和普及，非英文语系国家使用就会出现字符编码的问题的。所以就出现了Unicode、GBK和GB2312这些编码格式。</p><p>ASCII编码表：</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/875px-ASCII-Table-wide.svg.png" alt="ASCII - Simple English Wikipedia, the free encyclopedia"></p><h2 id="UTF-8编码格式"><a href="#UTF-8编码格式" class="headerlink" title="UTF-8编码格式"></a>UTF-8编码格式</h2><p>UTF-8编码格式是一种变长的编码格式，从一个字节到四个字节不等，并且兼容ASCII格式，这也就是为什么UTF-8格式为什么这么流行和被这么多系统采用的原因。因为兼容ASCII，原来使用ASCII格式保存的数据，可以直接使用UTF-8格式的解码系统解码，并且不会增加原有文档的使用空间。如果UTF-8是定长的，比如四个字节，那么原来有ASCII保存的文件是1KB的，使用UTF-8编码后，占用的空间就需要4KB了。</p><p>现在我们来探讨一下UTF-8怎么实现变成编码和兼容ASCII格式的。编码规则有两条</p><ul><li>1个字节的符号，字节第一位设置0。后面7位作为这个符号的Unicode码。因此，UTF-8就可以与ASCII兼容了</li><li>对于n个字节的符号（n&gt;1&amp;&amp;n&lt;=4)。第1个字节的前n位都是1，第n+1位是0。后面的n-1个字节的前两位都设置为10。剩余没有提及到的bit，为这个符号的Unicode码。</li></ul><p>Unicode字符集和UTF-8编码的对应表格如下：</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/utf8-encoding-table.png"></p><ul><li>Unicode编码是00到7F的，使用一个字节表示。所以0xxx xxxx中的x表示，x可以为0也可以为1，取决于这个编码是什么。</li><li>Unicode编码是80到7FF的，使用2个字节表示。110x xxxx 10xx xxxx是固定的格式，剩余的11个x，表示只有11个bits用来填充Unicode</li><li>Unicode编码是800到FFFF的，使用3个字节表示</li><li>Unicode编码是10000到10FFFF的，使用4个字节表示。</li></ul><p>“中”的Unicode编码是4E2D，“国”的Unicode编码是56FD，都需要使用3个字节表示。三个字节表示的UTF-8编码中，1110 xxxx 10xx xxxx 10xx xxxx都是固定的格式，剩余的x就需要使用Unicode的二进制( 国：101011011111101)，从最右边的x开始填充，如果不够就填Unicode的二进制编码0。下面以“国”字为例子，演示转换的过程</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/image-20201230172653720.png" alt="image-20201230172653720"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello world</title>
      <link href="../2021/02/22/hello-world/"/>
      <url>../2021/02/22/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>hello world</p><p>20210224</p><p>test 123</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">static_resources:</span></span><br><span class="line">  <span class="attr">listeners:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span></span><br><span class="line">      <span class="attr">socket_address:</span></span><br><span class="line">        <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        <span class="attr">port_value:</span> <span class="number">8001</span></span><br><span class="line">    <span class="attr">filter_chains:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">filters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.network.http_connection_manager</span></span><br><span class="line">        <span class="attr">typed_config:</span></span><br><span class="line">          <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager</span></span><br><span class="line">          <span class="attr">codec_type:</span> <span class="string">auto</span></span><br><span class="line">          <span class="attr">stat_prefix:</span> <span class="string">ingress_http</span></span><br><span class="line">          <span class="attr">route_config:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">local_route</span></span><br><span class="line">            <span class="attr">virtual_hosts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">local_service</span></span><br><span class="line">              <span class="attr">domains:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">              <span class="attr">request_headers_to_add:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">header:</span></span><br><span class="line">                  <span class="attr">key:</span> <span class="string">host</span></span><br><span class="line">                  <span class="attr">value:</span> <span class="string">www.baidu.com</span></span><br><span class="line">                <span class="attr">append:</span> <span class="literal">false</span></span><br><span class="line">              <span class="attr">routes:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">                  <span class="attr">prefix:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">                <span class="attr">route:</span></span><br><span class="line">                  <span class="attr">cluster:</span> <span class="string">web_service</span></span><br><span class="line">          <span class="attr">http_filters:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.wasm</span></span><br><span class="line">            <span class="attr">typed_config:</span></span><br><span class="line">              <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/udpa.type.v1.TypedStruct</span></span><br><span class="line">              <span class="attr">type_url:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm</span></span><br><span class="line">              <span class="attr">value:</span></span><br><span class="line">                <span class="attr">config:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">&quot;my_plugin2&quot;</span></span><br><span class="line">                  <span class="attr">root_id:</span> <span class="string">&quot;my_root_id2&quot;</span></span><br><span class="line">                  <span class="attr">configuration:</span></span><br><span class="line">                    <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">&quot;type.googleapis.com/google.protobuf.StringValue&quot;</span></span><br><span class="line">                    <span class="attr">value:</span> <span class="string">|</span></span><br><span class="line">                      &#123;&#125;</span><br><span class="line">                  <span class="attr">vm_config:</span></span><br><span class="line">                    <span class="attr">runtime:</span> <span class="string">&quot;envoy.wasm.runtime.v8&quot;</span></span><br><span class="line">                    <span class="attr">vm_id:</span> <span class="string">&quot;my_vm_id&quot;</span></span><br><span class="line">                    <span class="attr">code:</span></span><br><span class="line">                      <span class="attr">local:</span></span><br><span class="line">                        <span class="attr">filename:</span> <span class="string">&quot;envoy_filter_http_wasm_example.wasm&quot;</span></span><br><span class="line">                    <span class="attr">configuration:</span> &#123;&#125;</span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.router</span></span><br><span class="line">            <span class="attr">typed_config:</span> &#123;&#125;</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span></span><br><span class="line">      <span class="attr">socket_address:</span></span><br><span class="line">        <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        <span class="attr">port_value:</span> <span class="number">8000</span></span><br><span class="line">    <span class="attr">filter_chains:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">filters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.network.http_connection_manager</span></span><br><span class="line">        <span class="attr">typed_config:</span></span><br><span class="line">          <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager</span></span><br><span class="line">          <span class="attr">codec_type:</span> <span class="string">auto</span></span><br><span class="line">          <span class="attr">stat_prefix:</span> <span class="string">ingress_http</span></span><br><span class="line">          <span class="attr">route_config:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">local_route</span></span><br><span class="line">            <span class="attr">virtual_hosts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">local_service</span></span><br><span class="line">              <span class="attr">domains:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">              <span class="attr">request_headers_to_add:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">header:</span></span><br><span class="line">                  <span class="attr">key:</span> <span class="string">host</span></span><br><span class="line">                  <span class="attr">value:</span> <span class="string">www.baidu.com</span></span><br><span class="line">                <span class="attr">append:</span> <span class="literal">false</span></span><br><span class="line">              <span class="attr">routes:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">                  <span class="attr">prefix:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">                <span class="attr">route:</span></span><br><span class="line">                  <span class="attr">cluster:</span> <span class="string">web_service</span></span><br><span class="line">          <span class="attr">http_filters:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.wasm</span></span><br><span class="line">            <span class="attr">typed_config:</span></span><br><span class="line">              <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/udpa.type.v1.TypedStruct</span></span><br><span class="line">              <span class="attr">type_url:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm</span></span><br><span class="line">              <span class="attr">value:</span></span><br><span class="line">                <span class="attr">config:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">&quot;my_plugin&quot;</span></span><br><span class="line">                  <span class="attr">root_id:</span> <span class="string">&quot;my_root_id&quot;</span></span><br><span class="line">                  <span class="attr">configuration:</span></span><br><span class="line">                    <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">&quot;type.googleapis.com/google.protobuf.StringValue&quot;</span></span><br><span class="line">                    <span class="attr">value:</span> <span class="string">|</span></span><br><span class="line">                      &#123;&#125;</span><br><span class="line">                  <span class="attr">vm_config:</span></span><br><span class="line">                    <span class="attr">runtime:</span> <span class="string">&quot;envoy.wasm.runtime.v8&quot;</span></span><br><span class="line">                    <span class="attr">vm_id:</span> <span class="string">&quot;my_vm_id&quot;</span></span><br><span class="line">                    <span class="attr">code:</span></span><br><span class="line">                      <span class="attr">local:</span></span><br><span class="line">                        <span class="attr">filename:</span> <span class="string">&quot;envoy_filter_http_wasm_example.wasm&quot;</span></span><br><span class="line">                    <span class="attr">configuration:</span> &#123;&#125;</span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.router</span></span><br><span class="line">            <span class="attr">typed_config:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">clusters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web_service</span></span><br><span class="line">    <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">LOGICAL_DNS</span></span><br><span class="line">    <span class="attr">lb_policy:</span> <span class="string">round_robin</span></span><br><span class="line">    <span class="attr">load_assignment:</span></span><br><span class="line">      <span class="attr">cluster_name:</span> <span class="string">service1</span></span><br><span class="line">      <span class="attr">endpoints:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">            <span class="attr">address:</span></span><br><span class="line">              <span class="attr">socket_address:</span></span><br><span class="line">                <span class="attr">address:</span> <span class="string">www.baidu.com</span></span><br><span class="line">                <span class="attr">port_value:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Demo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcp-protocol</title>
      <link href="../2020/06/09/tcp-protocol/"/>
      <url>../2020/06/09/tcp-protocol/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP协议是什么？"><a href="#TCP协议是什么？" class="headerlink" title="TCP协议是什么？"></a>TCP协议是什么？</h2><p>​        TCP（Transmission Control Protoco 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内。如图1所示，TCP工作在4层，它的下一层是网络层，主要的协议有IP协议。</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190610001644.png"></p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图1 OSI七层模型</p><h2 id="TCP握手和挥手"><a href="#TCP握手和挥手" class="headerlink" title="TCP握手和挥手"></a>TCP握手和挥手</h2><p>本文先讲述TCP的握手和挥手的流程，让大家对TCP连接的建立以及连接的断开先有一个感性的认识。</p><p>实践：</p><ol><li><p>监听一个端口：nc -l -p 1234</p></li><li><p>查看系统当前的监听的端口：ss -l4 -t -n</p></li></ol><blockquote><p>​     State      Recv-Q Send-Q       Local Address:Port         Peer Address:Port      LISTEN     0           1                        *:1234                            <em>:</em></p></blockquote><ol start="3"><li><p>握手的建立： nc 127.0.0.1 1234</p></li><li><p>使用tcpdump保存当前握手的过程：tcpdump -i any port 1234 -w 1234.pcap</p></li><li><p>使用Wireshark查看保存的1234.pcap文件：</p></li></ol><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190610001714.png"></p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图2 TCP握手的抓包</p><h3 id="TCP握手的流程："><a href="#TCP握手的流程：" class="headerlink" title="TCP握手的流程："></a>TCP握手的流程：</h3><p>​       首先发起TCP连接的客户端，发送一个SYN包（序列号seq=A）到服务端，服务端收到SYN包后，回复一个SYN-ACK包（seq=B，ack=A+1），ack=A+1指的是确认了客户端发来的序列号seq为A的包，接着客户端收到SYN-ACK包后又回复了ACK包（seq=A+1,ack=B+1)的包。双方三次握手后建立了连接，服务端和客户端都进入了ESTABLISHED状态。 连接建立后，双方可以进行数据的传输。</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190610001854.png"></p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图3 TCP握手过程</p><h3 id="TCP挥手的流程："><a href="#TCP挥手的流程：" class="headerlink" title="TCP挥手的流程："></a>TCP挥手的流程：</h3><p>TCP连接的端口，称之为挥手。在协议中是经过四个步骤完成连接的断开。</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190610001922.png"></p><p>​                                        图4 TCP挥手的抓包</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190610001940.png"></p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图5 TCP挥手过程</p><p>​    在图5中，描述的是TCP挥手过程的完整流程（当然是在协议中）。为了方便描述，下面主动断开连接的一方称为client，被动关闭的一方称为server。</p><ol><li>client发送一个FIN包（seq=M）给server，表示client将要断开连接，请server也做相应的准备和回复确认。</li><li>server收到FIN包后，回复一个ACK包（ack=M+1）给client，表示我已经收到你的断开连接请求了，等我准备好了后告诉你断开连接，现在还不能断开连接。</li><li>server再接着发送一个FIN包（seq=N）给client端，表示我已经准备好断开连接了。</li><li>client收到FIN包后，回复一个ACK包（ack=N+1）表示我也收到你断开连接的请求了，我们可以愉快地一起断开连接。</li></ol><p>​    经过上述的四个步骤，TCP的连接断开了。但是看图4我们知道，真正实现TCP协议上是有优化的，优化后的步骤是：</p><ol><li>client发送一个FIN-ACK包（seq=M，ack=N）给server，表示client将要断开连接。为什么这里没有一个单独的FIN包，而是有一个ACK包也在里面？后面再详细解说</li><li>server收到FIN-ACK包后，知道client要断开连接，此时server端已经没有要发送的数据了，可以立即断开连接，因此回复的一个FIN-ACK包（seq=N，ack=M+1）的包给client。其实就是讲上面的2和3步骤一起做了，在一个TCP包里发过去，提高效率。</li><li>client收到FIN-ACK包后，回复一个ACK包（ack=N+1）给server端，完成连接的断开。</li></ol><p>​    上述第一个步骤中，为什么client会发送一个FIN-ACK包，而不是协议中的FIN包给server呢？原因是，在一个TCP的包中，ACK的包只是协议中的一个字段，这个字段的有置位，表示这个包是ACK包，另外ack号也是TCP包中一个预留的字段。换言之，一个FIN包和一个FIN-ACK包的大小是一样大的。在网络传输过程中，并不会增加任何的代价。另外我们知道，网络是不稳定的，在client断开连接前，绝大部分情况大都会有数据传输的发送，因此，在client挥手前，必然有发送过一个ACK包给server端，那么这个ACK包在网络中有可能丢失，后续client有可能要重发，所以在client断开连接的时候，也把最近一个的ACK包也一起发过去（不发白不发，反正不占用额外的带宽）。所以，发一个FIN-ACK包不会带来额外的代价，带来的收益是减少重发一个ACK包的可能，何乐而不为。关于FIN-ACK包，你也可以参考：<a href="https://cs.stackexchange.com/questions/76393/tcp-connection-termination-fin-fin-ack-ack">https://cs.stackexchange.com/questions/76393/tcp-connection-termination-fin-fin-ack-ack</a></p><h2 id="TCP协议的状态"><a href="#TCP协议的状态" class="headerlink" title="TCP协议的状态"></a>TCP协议的状态</h2><p>了解TCP协议，一定要了解TCP协议的状态，以及状态之间的转换。</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190610002755.png"></p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图6 TCP的状态</p><p><strong>各个状态之间的含义：</strong></p><ol><li>CLOSED ：初始化状态，以及连接断开后，双方都会进入的状态</li><li>LISTEN：监听状态，只有服务端调用了listen系统调用后才会进入</li><li>SYN SENT：SYN包已发送，只有客户端才有的状态</li><li>SYN RECEIVED：SYN包已收到，只有服务端才有的转态</li><li>ESTABLISHED：连接已建立状态</li><li>FIN WAIT 1：主动断开连接一放发送FIN包后进入的转态，等待ACK包回来</li><li>FIN WAIT 2：FIN WAIT 1状态的一端收到ACK包后进入的转态</li><li>CLOSING： 主动断开连接的一端发了FIN1包，还没收到这个FIN1包的ACK1包之前就收到对端的FIN2包，并且发送回ACK2后进入的状态</li><li>TIME WAIT：主动断开连接的放，发送完最后一个ACK包后进入的状态</li><li>CLOSE WAIT：被动关闭一端收到FIN包，并且回复此FIN包的ACK包后进入的状态</li><li>LAST ACK：被动关闭一端发送FIN包后进入的状态</li></ol><blockquote><p>PS：状态转换图中，每一个状态之间的连线有一个标签 FIN/ACK、CLOSE/FIN之类的，指的是：收到的包/发送出去的包。比如FIN WAIT 1和 CLOSING 之间的线有个标签FIN/ACK,表示的是，一个对象从FIN WAIT 1状态转换到CLOSING状态，需要经过收到一个FIN包，再发送一个ACK包后才能完成转换。另外如果标签中有-表示null，不需要操作。</p></blockquote><p><strong>TIME WAIT状态的补充说明，主动关闭一端在四次挥手的最后一个ACK包发送后，会进入TIME WAIT状态，并且经过一段时间超时后才进入CLOSED状态。</strong></p><p><strong>为什么要有TIME WAIT状态？</strong></p><blockquote><p>TCP握手过程关闭连接，TIME WAIT状态的作用是尽力保证TCP连接的正常关闭。当关闭TCP连接时，主动关闭的一端（A）在发送最后的ACK后，如果这个ACK消息丢失，那么另会超时未收到这个ACK而重传FIN，因此A端必须在TIME WAIT状态下保留连接的状态信息等待着可能再次收到FIN时进⾏行行ACK答复。如果不设置TIME WAIT状态，那么A端再次FIN消息时，则是返回RST信息，B端收到RST信息时则认为连接非正常关闭。虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME WAIT状态就是用来重发可能丢失的ACK报文。</p></blockquote><p><strong>超时时间是多少？</strong></p><blockquote><p>2MSL（maximum segment lifetime），这个和操作系统有关，一般根据RFC793的定义，MSL时间是2分钟，即TIME WAIT的时间为4分钟，但实际应用上MSL也有定义为30秒、1分钟的。Linux上一般是1分钟（cat /proc/sys/net/ipv4/tcp_fin_timeout 可以看到超时时间）</p></blockquote><h3 id="TCP滑动窗口协议"><a href="#TCP滑动窗口协议" class="headerlink" title="TCP滑动窗口协议"></a>TCP滑动窗口协议</h3><p>滑动窗口协议解决的是什么问题？</p><blockquote><p>提高TCP的传输效率。如果每次client给server发送包的时候，都要等到上一个包的确认ack已回来，那么整个TCP的传输效率会非常低下。</p></blockquote><p>TCP中有两个窗口，一个是发送端的窗口( congestion window ，cwnd)，一个是接收端的窗口（receiver window， rwnd）。发送端的窗口值取两者的最小值，用数学方式表达就是：发送方窗口的上限值 = Min [ rwnd, cwnd ]。窗口的协商在握手的过程中有，在数据传输的过程中，接收端也会按需动态调整接收端的窗口值。</p><p>所谓滑动窗口协议就是，发送端根据下面的变量，决定当前是否还能发送数据包：</p><blockquote><p>发送方窗口的上限值（Min [ rwnd, cwnd ]）<br>已发送当还没确认的数据size1<br>还没发送的数据size2</p></blockquote><p><strong>滑动窗口的机制：</strong></p><p>对发送端的TCP buffer做一个快照，TCP buffer的数据存在四个状态：</p><ul><li>已发送并且已经确认</li><li>已发送但还没确认</li><li>未发送，但服务端已经准备好接收</li><li>未发送，服务端也还没准备好接收</li></ul><p><strong>接收方也存在对于的状态：</strong></p><ul><li><p>已接收并且已确认</p></li><li><p>未接收，但已准备好接收</p></li><li><p>未接收，也还没准备好接收</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190610003348.png"></p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图7 发送端维护的窗口1        </p></li></ul><p><strong>发送端维护的结构有</strong></p><ul><li>已发送并且已经确认（0-4 字节）</li><li>已发送但还没确认 （5-10字节）</li><li>未发送，但服务端已经准备好接收（11-16字节）</li><li>未发送，服务端也还没准备好接收 （17-21字节）</li></ul><p><strong>相关定义：</strong></p><p><strong>发送窗口：</strong>接收方允许发送方一次发送未确认的字节数：是第二和第三种类型的和，即5-16字节，共12个字节。</p><p><strong>可用窗口</strong>： 发送端目前还可以发送的的字节数，即11-16字节，共6个字节。</p><p><strong>窗口缩放：</strong>接收方会发送上一次成功接收后的最长字节数，然后发送方会根据最长字节数进行窗口缩放。</p><p>假设，已发送但还没确认的数据分为三段传输5-6，7-8，9-10，共三段，但是接收方只收到了，5-6和9-10这两段数据，这时候接收端之后返回6作为最大成功接收字节数，不选取10，因为7-8没有认为成功接收，因此发送方收到6作为最长字节数后，会将窗口缩放为：</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190610003625.png">               </p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图8 发送端维护的窗口2</p><p>接收方已经收到的9-10，在收到7-8之前不会返回确认，也不会放回10作为最长的字节数，发送端收到6作为最长字节数返回后，可将第三类窗口放大至11-18（因为对比之前有两个字节已经确认了）,然后发送端将11-18的字节发送过去，接着发送端会停止发送其他的包。</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190610003719.png">                </p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图9 发送端维护的窗口3</p><p>发送完11-18字节后的buffer状态</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190610003915.png"></p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图10 发送端维护的窗口4</p><p>滑动窗口是发送端控制的行为，发送端最多发送的数据量就是Win=MIN（rwnd，cwnd），因此，所有的这个机制的行为都在围绕这个值来。可以想象成Win值就是一个副卡牌的所有牌，要发送的每个字节都拿走一张卡牌，确认后将卡牌换回来，因此当卡牌的数量不足的时候，就不能再发送数据了。等到卡牌换回来后再发送。另外，卡牌的数量也会发生变化，随着rwnd和cwnd的值发送变化，rwnd是由接收端决定的，那么cwnd是由发送端决定的。那么cwnd的值怎么变化呢？那就跟下面要讲的拥塞控制有关。</p><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>TCP连接建立后，会进入慢启动的过程。先将cwnd设为一个MSS。</p><p><strong>慢启动算法：</strong>最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生。具体来说，当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(Round Trip Time,RTT)呈指数级增长，事实上，慢启动的速度一点也不慢，只是它的起点比较低一点而已。我们可以简单计算下：</p><blockquote><p>开始 —&gt; cwnd = 1<br>经过1个RTT后 —&gt; cwnd = 2<em>1 = 2<br>经过2个RTT后 —&gt; cwnd = 2</em>2= 4<br>经过3个RTT后 —&gt; cwnd = 4*2 = 8</p></blockquote><p>当cwnd不断指数增长，这个值就会变得很大，此时，慢启动算法就不适用了，cwnd的变化开始进入一个<strong>拥塞避免状态</strong>。</p><p><strong>拥塞避免</strong>（慢启动已经结束）：从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，但是cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，当cwnd超过该值后，慢启动过程结束，进入拥塞避免阶段。对于大多数TCP实现来说，ssthresh的值是65536(同样以字节计算)。拥塞避免的主要思想是加法增大，也就是cwnd的值不再指数级往上升，开始加法增加。此时当窗口中所有的报文段都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。</p><p>除了慢启动和拥塞避免会影响到cwnd的值，还有重传也会改变cwnd的值。其中重传有两种，一是客户端重传，而是服务端要求的快速重传。</p><p><strong>客户端重传算法：</strong>首先来看TCP是如何确定网络进入了拥塞状态的，TCP认为网络拥塞的主要依据是它重传了一个报文段。上面提到过，TCP对每一个报文段都有一个定时器，称为重传定时器(RTO)，当RTO超时且还没有得到数据确认，那么TCP就会对该报文段进行重传，当发生超时时，那么出现拥塞的可能性就很大，某个报文段可能在网络中某处丢失，并且后续的报文段也没有了消息，在这种情况下，TCP反应比较大，会有以下行为：</p><blockquote><p>1.把ssthresh降低为cwnd值的一半<br>2.把cwnd重新设置为1<br>3.重新进入慢启动过程</p></blockquote><p><strong>快速重传算法</strong>：服务端连发3个相同的ack，客户端被动进入快速重传）其实TCP还有一种情况会进行重传：那就是收到3个相同的ACK。TCP在收到乱序到达包时就会立即发送ACK，TCP利用3个相同的ACK来判定数据包的丢失，此时进行快速重传，快速重传做的事情有：</p><blockquote><p>1.把ssthresh设置为cwnd的一半<br>2.把cwnd再设置为ssthresh的值(具体实现有些为ssthresh+3)<br>3.重新进入拥塞避免阶段。</p></blockquote><p>当发送端进入快速重传算法后，必然要回复回去原来的状态，这就是快速恢复算法了。</p><p><strong>快速恢复算法</strong>：</p><blockquote><p>1.当收到3个重复ACK时，把ssthresh设置为cwnd的一半，把cwnd设置为ssthresh的值加3，然后重传丢失的报文段，加3的原因是因为收到3个重复的ACK，表明有3个“老”的数据包离开了网络。<br>2.再收到重复的ACK时，拥塞窗口增加1。<br>3.当收到新的数据包的ACK时，把cwnd设置为第一步中的ssthresh的值。原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。</p></blockquote><p>PS这里指的新ACK指：不是导致出现快速重传的ACK，而是一个ack号更大的ACK包。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p><strong>TCP协议的内容跟实现上是有出入的。其实协议就是为了peer之间有一个通信的语言，大家在这个语言框架下进行通信。从TCP的发送端的cwnd值的变化过程看得出，TCP是一个君子协议，发送端完全可以多发送数据，不用进入重传的阶段和将cwnd的值变小。</strong></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm">http://tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm</a><br><a href="https://cs.stackexchange.com/questions/76393/tcp-connection-termination-fin-fin-ack-ack">https://cs.stackexchange.com/questions/76393/tcp-connection-termination-fin-fin-ack-ack</a><br><a href="https://www.cnblogs.com/zlingh/p/6161088.html">https://www.cnblogs.com/zlingh/p/6161088.html</a><br><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">https://en.wikipedia.org/wiki/Transmission_Control_Protocol</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> tcp </tag>
            
            <tag> networking </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iptables</title>
      <link href="../2020/06/06/iptables/"/>
      <url>../2020/06/06/iptables/</url>
      
        <content type="html"><![CDATA[<h3 id="First-sight-of-iptables"><a href="#First-sight-of-iptables" class="headerlink" title="First sight of iptables"></a>First sight of iptables</h3><p>​          内核防火墙模块（或者Netfilter）提供了相关的机制去管理网络防火墙，iptables就是这样一个用户态的工具，提供了一系列的接口，使得用户可以使用内核提供的能力。 </p><p>​    举个例子，使用iptables禁用所有的端口的tcp连接，除了22端口外。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -A INPUT -p tcp --dport 22  -j ACCEPT</span><br><span class="line">iptables -t filter -A INPUT -p tcp -j DROP</span><br></pre></td></tr></table></figure><p>​    通过以上两条命令，就可以使得除了SSH连接外的，其他所有tcp连接都建立不起来，注意的是，这两条命令的实行顺序不能调转，如果先执行了<strong>iptables -t filter -A INPUT -p tcp -j DROP</strong> 会使得所有的端口，包括SSH的连接都会断掉，你的机器就永远登录不了了。SSH的端口非22的，改成对应的端口即可。</p><p>​    iptables在日常的使用中，很大一部分的功能就是开放服务的端口，除了服务的端口，其他的端口都DROP掉，另外，如果某些端口，比如SSH的22端口，只开放给一部分的机器访问，那么可以添加一条规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -A INPUT -p tcp --dport 22 -s 10.10.10.10  -j ACCEPT</span><br></pre></td></tr></table></figure><p>​    -s 指定了请求的源地址，一定要是10.10.10.10的机器才能访问22端口，其他端口不匹配这条规则。通过这样，我们可以实现一个白名单的功能，使得一部分的机器可以访问受限制的端口。至于对外提供服务的端口，设置成全开放即可。-s的地址格式可以是CIDR的格式，因此可以表达一批的IP地址。</p><p>​    为什么需要配置防火墙，限制端口被访问呢？因为<strong>最小权限原则</strong>。</p><blockquote><p>在计算机科学领域中，最小权限原则是要求计算环境中的特定抽象层的每个模块如进程、用户或者计算机程序只能访问当下所必需的信息或者资源。 赋予每一个合法动作最小的权限，就是为了保护数据以及功能避免受到错误或者恶意行为的破坏。</p></blockquote><p>​    暴露更多的接口可以对外访问，意味着有更大的机会受到恶意的工具。还有也是防止系统管理员，在服务器上误操作启动了一个服务，而这个服务并不是对外开放的，这样，如果没有限制端口的开放，这个服务就暴露出去了。</p><p>​    另外，还有一条比较特殊的规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -I INPUT  -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br></pre></td></tr></table></figure><p>​    这条规则指定了两个状态，ESTABLISHED和RELATED，其中ESTABLISHED状态指定的是，如果是由服务器（本机器）本身发起的连接，那么对端其他端口发过来的请求就可以接受，因为是ESTABLISHED的状态。另外RELATED的状态指的是，在一个已经正常建立连接基础上新建的连接，也是开放对应的端口。下面详细解释一下这两种状态：</p><pre><code> 1. ESTABLISHED： 简单粗暴一点的解释是，如果是由服务器本身发起的连接，后面对端发过来的Packet都会认为是ESTABLISHED状态。对于应用层来说，就是服务器发起的连接，能够正常使用，INPUT链不需要再额外的设置。服务器发起请求的时候，在OUTPUT链出去的时候，会记录这个流的转态为NEW，那么对端返回数据包的时候能，发现状态之前是NEW，那么收到对端的时候后，认为这个流的状态就是ESATBLISHED的了。 2. RELATED： 具体实现的细节我并没有深究。FTP的场景就是这样，一个数据通道一个控制通道。FTP首先建立的是控制通道的连接，那么在传输文件的时候，会建立一条数据通道的连接。那么这条数据通道的连接就会被标记为RELATED。</code></pre><h3 id="iptables的三表五链"><a href="#iptables的三表五链" class="headerlink" title="iptables的三表五链"></a>iptables的三表五链</h3><h4 id="netfilter提供的hook"><a href="#netfilter提供的hook" class="headerlink" title="netfilter提供的hook"></a>netfilter提供的hook</h4><p>​    iptables其实是利用了内核提供的钩子，iptables通过往这些钩子中注册这些规则进去，来实现对数据流的操作。iptables就是通过检查每个数据包，看这些数据包符合了哪些规则，要是数据包匹配到了规则，就会执行指定的动作，常见的动作就是：DROP和ACCEPT。如果某一条DROP的规则，描述的是443端口的数据都DROP掉，那么443端口的连接就建立不起来。当然，出了DROP和ACCEPT还有其他的动作，后面再详述。</p><p>​    常说iptables有三表五链，其实iptables一共有五个表，常用的是三个，分别为：filter， nat，raw。还有两个表是：mangle 和 security。</p><p>​    在说五链之前，先说一下内核实现iptables功能的机制。内核的Netfilter模块提供了一个框架去跟内核的网络栈交互，一个数据包从网卡进来到网卡出去的整个生命周期。Netfilter提供了五个hook，使得用户层可以实现的数据包的控制。</p><p>五个hook分别是（懒得翻译了=.=）：</p><ul><li><code>NF_IP_PRE_ROUTING</code>: This hook will be triggered by any incoming traffic very soon after entering the network stack. This hook is processed before any routing decisions have been made regarding where to send the packet.</li><li><code>NF_IP_LOCAL_IN</code>: This hook is triggered after an incoming packet has been routed if the packet is destined for the local system.</li><li><code>NF_IP_FORWARD</code>: This hook is triggered after an incoming packet has been routed if the packet is to be forwarded to another host.</li><li><code>NF_IP_LOCAL_OUT</code>: This hook is triggered by any locally created outbound traffic as soon it hits the network stack.</li><li><code>NF_IP_POST_ROUTING</code>: This hook is triggered by any outgoing or forwarded traffic after routing has taken place and just before being put out on the wire.</li></ul><h4 id="五链"><a href="#五链" class="headerlink" title="五链"></a>五链</h4><p>​    五链其实就是对应内核模块netfilter提供的五个hook：</p><ul><li><code>PREROUTING</code>: Triggered by the <code>NF_IP_PRE_ROUTING</code> hook.</li><li><code>INPUT</code>: Triggered by the <code>NF_IP_LOCAL_IN</code> hook.</li><li><code>FORWARD</code>: Triggered by the <code>NF_IP_FORWARD</code> hook.</li><li><code>OUTPUT</code>: Triggered by the <code>NF_IP_LOCAL_OUT</code> hook.</li><li><code>POSTROUTING</code>: Triggered by the <code>NF_IP_POST_ROUTING</code> hook.</li></ul><p>​    iptables最小的管理单元就是一条规则，每个hook上面都可以注册很多的规则。一个数据包，从网卡进入到从网卡出去，在整个的生命周期中，会触发这五个hook（理论上是会触发，除非在前面的hook的某个规则DROP掉或者标记了后面不再做检查）都会被触发。整个数据的生命周期流程如下图：</p><p><img src="https://raw.githubusercontent.com/leejiancai/image_repo/master/img/20190609174841.png"></p><p>​                        </p><p>也就是说，PREROUTING上的规则会先于INPUT执行。链的执行顺序是：PREROUTING &gt; INPUT &gt; FORWARD &gt; OUTPUT &gt; POSTROUTING。 那么我们的表有什么用了，既然规则是绑定到hook上去了，那么好像表没有什么用了。其实表在实现上，只是为了方便规则的管理，还有也是将不同的规则分类，方便用户去查看不同的表。不同的表主要的功能是不一样的。比如filter表，主要是为了过滤数据包，禁止不允许的数据进入到内核；nat表就是对数据包的源地址和目的地址进行转换。将不同的业务逻辑，不同的功能的规则，放在不同的表上，方便管理。我认为这是表设计的初衷（最新内核的nftable已经开放了多个自定义的表的功能了，先挖坑，后面再写一遍关于nftable的文章）。</p><p><strong>既然hook有执行顺序，那么表有执行的顺序吗？</strong></p><p>答案是有的，表（表的执行顺序从上到下）和链（链的执行的顺序从左到右）如下图所示，同一张表并且同一条链中的执行顺序，则看规则的排列顺序了：</p><table><thead><tr><th>Tables↓/Chains→</th><th>PREROUTING</th><th>INPUT</th><th>FORWARD</th><th>OUTPUT</th><th>POSTROUTING</th></tr></thead><tbody><tr><td>(routing decision)</td><td></td><td></td><td></td><td>✓</td><td></td></tr><tr><td><strong>raw</strong></td><td>✓</td><td></td><td></td><td>✓</td><td></td></tr><tr><td>(connection tracking enabled)</td><td>✓</td><td></td><td></td><td>✓</td><td></td></tr><tr><td><strong>mangle</strong></td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td><strong>nat</strong> (DNAT)</td><td>✓</td><td></td><td></td><td>✓</td><td></td></tr><tr><td>(routing decision)</td><td>✓</td><td></td><td></td><td>✓</td><td></td></tr><tr><td><strong>filter</strong></td><td></td><td>✓</td><td>✓</td><td>✓</td><td></td></tr><tr><td><strong>security</strong></td><td></td><td>✓</td><td>✓</td><td>✓</td><td></td></tr><tr><td><strong>nat</strong> (SNAT)</td><td></td><td>✓</td><td></td><td></td><td>✓</td></tr></tbody></table><p>从上面的图标可以看出来，不是所有的表都支持五个链（hook)，因此不同的功能是要划分到不同的表中去。</p><h3 id="目标-target"><a href="#目标-target" class="headerlink" title="目标 target"></a>目标 target</h3><p>规则匹配后，会有对应的目标，目标有两大类，一类是动作，另外一类就是用户自定义的链。</p><h4 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h4><p>动作有三种（这里没有列全，只列出了常用的）：</p><ol><li>权限相关：ACCEPT、DROP、DENY、 RETURN</li><li>日志相关：LOG</li><li>地址相关：SNAT、DNAT、MASQUERADE</li></ol><h5 id="第一类动作：ACCEPT、DROP、DENY、-RETURN"><a href="#第一类动作：ACCEPT、DROP、DENY、-RETURN" class="headerlink" title="第一类动作：ACCEPT、DROP、DENY、 RETURN"></a>第一类动作：ACCEPT、DROP、DENY、 RETURN</h5><p>​    表示匹配规则后，这个包要怎么处理。ACCEPT表示，这个包允许进入下一个链的判断；DROP表示直接丢包，不响应客户端；DENY表示，返回拒绝访问给客户端；RETURN在这里有两个语义，如果是在主链（五条链）上表示不再判断这条链剩下的规则，target是什么就取决于这条链的policy。链的policy是一条链默认的target，没有匹配到规则或者被RETURN的话，都是会使用默认的规则policy的;</p><h5 id="第二类动作-LOG"><a href="#第二类动作-LOG" class="headerlink" title="第二类动作: LOG"></a>第二类动作: LOG</h5><p>就是这事一条打印日志的规则，需要注意的是，打印日志的规则是需要放在其他规则的前面，否则可能打印日志的规则还没匹配到就已经被前面的规则匹配了。dmesg 可以查看相关的日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -D POSTROUTING -d 127.0.0.1  -p tcp --dport 9000 -j LOG --log-prefix &quot;REALSANT9000:&quot;</span><br></pre></td></tr></table></figure><h5 id="第三类动作就是地址的转换：SNAT、DNAT、MASQUERADE"><a href="#第三类动作就是地址的转换：SNAT、DNAT、MASQUERADE" class="headerlink" title="第三类动作就是地址的转换：SNAT、DNAT、MASQUERADE"></a>第三类动作就是地址的转换：SNAT、DNAT、MASQUERADE</h5><p>​    SNAT是对源地址和源端口的转换；DNAT是对目的端口和目的地址转换；MASQUERADE比较特殊，它是对源地址的转换，但是它是使用网卡的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat  -I PREROUTING -p tcp --dport 7777 -j DNAT --to-destination 8.8.8.8:9000</span><br><span class="line">iptables -t nat -I POSTROUTING -p tcp -d 8.8.8.8 --dport 9000  -j MASQUERADE</span><br></pre></td></tr></table></figure><p>​    这个就是DNAT和MASQUERAED匹配使用，就可以将本地7777端口收到的流量转发到8.8.8.8机器上的9000端口，另外流量转发需要打开内核转发的模块：<strong>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</strong></p><h4 id="自定义的链"><a href="#自定义的链" class="headerlink" title="自定义的链"></a>自定义的链</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT  -p tcp --dport 2003  -j DOCKER</span><br><span class="line">iptables -I DOCKER  -p tcp -s 8.8.8.8  -j ACCEPT</span><br></pre></td></tr></table></figure><p>这里有个自定义的表作为target，那么一个端口2003的数据包匹配到这条规则的时候，它的action是什么，要由DOCKER表进行判断。DOCKER表中有一条规则，表明8.8.8.8主机访问是被允许的。</p><p>创建一个自定义的链：<strong>iptables -N DOCKER</strong> </p><p>另外一个自定义链中，如果动作是RETURN则表明剩下的规则不匹配了，跟函数的返回是一样的，再交由上一层的链处理，如果上一层的链还有规则，则再计算剩下的规则，看看哪个匹配。</p><h3 id="policy"><a href="#policy" class="headerlink" title="policy"></a>policy</h3><p>一个policy引发的转发问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ables -t nat  -I PREROUTING -p tcp --dport 7777 -j DNAT --to-destination 8.8.8.8:9000</span><br><span class="line">iptables -t nat -I POSTROUTING -p tcp -d 8.8.8.8 --dport 9000  -j MASQUERADE</span><br></pre></td></tr></table></figure><p>通过上述两条命配置好转发后，发现数据也没转发到8.8.8.8主机的9000端口，仔细检查后发现，FORWARD的链没有配置任何规则，并且policy是DROP。这就是问题所在，在数据进行转发出去的时候，DROP的policy将数据包丢了，导致数据没转出去。</p><p><strong>iptables -t filter -L -nv</strong> 查看FORWARD链的规则：</p><blockquote><p>Chain FORWARD (policy DROP 10 packets, 520 bytes)</p></blockquote><p>表示默认的动作是DROP（后面的是这条链的计数器，10个包，520个字节）</p><p>通过修改policy或者添加一个FORWARD的规则就可以了：<strong>iptables -t filter -P FORWARD ACCEPT</strong></p><h3 id="常用的命令行"><a href="#常用的命令行" class="headerlink" title="常用的命令行"></a>常用的命令行</h3><ul><li>表计数器的清空：iptables -t nat -Z</li><li>查看nat表： iptables -t nat -L -nv</li><li>查看filter表：iptables -t filter -L -nv</li><li>清空nat表的规则：iptables -F nat</li><li>查看filter表的INPUT链：iptables -t filter -L INPUT -nv</li><li>保存当前系统的iptables配置： iptables-save</li><li>应用一份iptables的配置文件: iptables-restore configFileName</li></ul><h4 id="raw表的使用"><a href="#raw表的使用" class="headerlink" title="raw表的使用"></a>raw表的使用</h4><p>​    raw表的规则作为最新匹配的规则，利用raw表，我们可以解决一部分的iptables性能问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t raw -A PREROUTING -p tcp --dport 80 -j NOTRACK</span><br><span class="line">iptables -A FORWARD -m state --state UNTRACKED -j ACCEPT</span><br></pre></td></tr></table></figure><p>比如转发到本地的WEB端口80的流量，标记为NOTRACK。</p><p>raw表中包含PREROUTING链和OUTPUT链，优先级最高，可以对数据包在进入NAT表的PREROUTING链之前对消息进行处理。当用户启用了RAW表，消息在经过RAW表的PREROUTING链处理后，将跳过NAT表和ip_conntrack处理，不再做地址转换和数据包的链接跟踪处理。所以raw表可以用在那些不需要做nat和链接跟踪的情况，提升系统性能。因为启用链接跟踪时，系统会建立一个链接跟踪表，每个消息进来时，都会去查询链接跟踪表，当系统业务量过大时，可能会引发系统CPU消耗过高。</p><h3 id="iptables的问题"><a href="#iptables的问题" class="headerlink" title="iptables的问题"></a>iptables的问题</h3><ol><li><p>iptables每次从新应用restore配置文件，首先是先flush掉所有的表，再配置规则。那么这样就存在一个中间态，这个系统是没有任何保护的。</p></li><li><p>iptables的性能问题，规则数的数量多了之后，就会存在性能问题。</p><p>因为，最新的内核推出了nftable代替iptables，志在解决上述的问题。</p></li></ol><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><a href="https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture">https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture</a></p><p><a href="https://www.linuxtopia.org/Linux_Firewall_iptables/c1265.html">https://www.linuxtopia.org/Linux_Firewall_iptables/c1265.html</a></p><p><a href="https://www.frozentux.net/iptables-tutorial/chunkyhtml/x4193.html">https://www.frozentux.net/iptables-tutorial/chunkyhtml/x4193.html</a></p><p><a href="https://www.jianshu.com/p/5f38e7253fc8">https://www.jianshu.com/p/5f38e7253fc8</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> networking </tag>
            
            <tag> tool </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="about/index.html"/>
      <url>about/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><p>一个热爱技术的中国人🇨🇳。</p><p>Email： <a href="mailto:&#57;&#53;&#56;&#48;&#x30;&#48;&#52;&#51;&#50;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#109;">&#57;&#53;&#56;&#48;&#x30;&#48;&#52;&#51;&#50;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#109;</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="categories/index.html"/>
      <url>categories/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>search</title>
      <link href="search/index.html"/>
      <url>search/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="tags/index.html"/>
      <url>tags/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
    </entry>
    
    
  
</search>
